#!/usr/bin/env ruby

module Histlog
  # Parse --duration flag value into {op: :lt|:gt, value: float, unit: :s|:m|:h|:d|:w}
  module Utils
    module_function

    # Parse --duration flag value into a hash describing the filter.
    # Supports:
    #   10s         => ±10% range (9s..11s)
    #   <10s, >10s  => less/greater than
    #   10s..12s    => explicit range
    #   ..10.3s     => <=10.3s
    #   2.3d..      => >=2.3d
    def parse_duration_flag(str)
      s = str.strip
      # Helper to parse compound duration (e.g. 1d3m, 12m34s)
      parse_compound = ->(s) do
        total = 0.0
        s.scan(/([\d.]+)([smhdw])/i) do |num, unit|
          mult = case unit.downcase
                 when 's' then 1
                 when 'm' then 60
                 when 'h' then 3600
                 when 'd' then 86400
                 when 'w' then 604800
                 else 1
                 end
          total += num.to_f * mult
        end
        total > 0 ? total : nil
      end

      # Range: a..b (support compound)
      if s =~ /^([\dsmhdw.]+)\.\.([\dsmhdw.]+)$/i
        a, b = $1, $2
        amin = parse_compound.call(a)
        bmax = parse_compound.call(b)
        return { type: :range, min: { value: amin, unit: :s }, max: { value: bmax, unit: :s } }
      end
      # Open-ended: ..b (support compound)
      if s =~ /^\.\.([\dsmhdw.]+)$/i
        b = $1
        bmax = parse_compound.call(b)
        return { type: :lte, value: bmax, unit: :s }
      end
      # Open-ended: a.. (support compound)
      if s =~ /^([\dsmhdw.]+)\.\.$/i
        a = $1
        amin = parse_compound.call(a)
        return { type: :gte, value: amin, unit: :s }
      end
      # Less/greater than: <10s, >10s (support compound)
      if s =~ /^([<>])\s*([\dsmhdw.]+)$/i
        op, val = $1, $2
        v = parse_compound.call(val)
        return { type: (op == '<' ? :lt : :gt), value: v, unit: :s }
      end
      # Default: ±10% range (support compound)
      if (v = parse_compound.call(s))
        return { type: :approx, value: v, unit: :s, tol: 0.1 }
      end

      raise ArgumentError, "Invalid duration format: #{str}"
    end

    # Convert duration hash to seconds
    def duration_to_seconds(dur)
      mult = case dur[:unit]
             when :s then 1
             when :m then 60
             when :h then 3600
             when :d then 86400
             when :w then 604800
             else 1
             end
      dur[:value] * mult
    end

    # Convert a short pattern into a fuzzy SQL LIKE pattern.
    # Example: "git" -> "%g%i%t%" which emulates simple fzf-like fuzzy matching.
    def fuzzy_like_pattern(str)
      return "%" if str.nil? || str.empty?

      "%" + str.chars.map { |c| Regexp.escape(c) }.join('%') + "%"
    end

    # Parse --time flag value into [start_unix, end_unix] (nil for open-ended)
    # Supports:
    #   2022-12-20 08:00..09:10:40 (on a specific date)
    #   2022-12-20..2022-12-21
    #   ..2022-12-20
    #   2022-12-20..
    #   3w (last 3 weeks)
    #   09:00..10:00 (today)
    #   2022-12-20+2w-2w (centered window)
    def parse_time_flag(str)
      s = str.strip
      now = Time.now
      # Helper: parse date/time string to Time object
      parse_dt = ->(t, ref_date = nil) do
        # If only time-of-day, use ref_date or today
        if t =~ /^\d{1,2}:\d{2}(:\d{2})?$/
          base = ref_date || now
          h, m, sec = t.split(':').map(&:to_i)
          Time.new(base.year, base.month, base.day, h, m, sec || 0)
        elsif t =~ /^\d{4}-\d{2}-\d{2}( \d{1,2}:\d{2}(:\d{2})?)?$/
          Time.parse(t)
        elsif t =~ /^\d{4}-\d{2}-\d{2}$/
          Time.parse(t)
        else
          # Try relative (e.g., 3w, 2d, 4h)
          seconds = Histlog::Utils.parse_time_span_to_seconds(t)
          seconds ? now - seconds : nil
        end
      end

      # Range: a..b
      if s =~ /^(.+)\.\.(.+)$/
        a, b = $1.strip, $2.strip
        t1 = parse_dt.call(a)
        t2 = parse_dt.call(b, t1)
        return [t1&.to_f, t2&.to_f]
      end
      # Open-ended: ..b
      if s =~ /^\.\.(.+)$/
        b = $1.strip
        t2 = parse_dt.call(b)
        return [nil, t2&.to_f]
      end
      # Open-ended: a..
      if s =~ /^(.+)\.\.$/
        a = $1.strip
        t1 = parse_dt.call(a)
        return [t1&.to_f, nil]
      end
      # Centered window: 2022-12-20+2w-2w
      if s =~ /^(.+)\+([\ddhmws.]+)-([\ddhmws.]+)$/
        base, plus, minus = $1.strip, $2, $3
        t0 = parse_dt.call(base)
        psec = Histlog::Utils.parse_time_span_to_seconds(plus)
        msec = Histlog::Utils.parse_time_span_to_seconds(minus)
        return [t0.to_f - msec, t0.to_f + psec]
      end
      # Relative: 3w (last 3 weeks)
      if s =~ /^([\ddhmws.]+)$/
        sec = Histlog::Utils.parse_time_span_to_seconds(s)
        return [now.to_f - sec, now.to_f]
      end
      # Time-of-day only: 09:00..10:00 (today)
      if s =~ /^(\d{1,2}:\d{2}(:\d{2})?)\.\.(\d{1,2}:\d{2}(:\d{2})?)$/
        t1 = parse_dt.call($1)
        t2 = parse_dt.call($3)
        return [t1.to_f, t2.to_f]
      end
      # Date only: 2022-12-20
      if s =~ /^\d{4}-\d{2}-\d{2}$/
        t1 = Time.parse(s)
        t2 = t1 + 86400 - 1
        return [t1.to_f, t2.to_f]
      end
      # Specific timestamp with minute precision: 2025-09-29 10:40
      if s =~ /^\d{4}-\d{2}-\d{2} \d{1,2}:\d{2}$/
        t1 = Time.parse(s)
        t2 = t1 + 60 - 1 # Add 59 seconds to cover the entire minute
        return [t1.to_f, t2.to_f]
      end
      # Specific timestamp with second precision: 2025-09-29 10:40:30
      if s =~ /^\d{4}-\d{2}-\d{2} \d{1,2}:\d{2}:\d{2}$/
        t1 = Time.parse(s)
        t2 = t1 + 1 - 0.001 # Add ~1 second to match that exact second
        return [t1.to_f, t2.to_f]
      end
      # Time-of-day only with minute precision: 10:40
      if s =~ /^\d{1,2}:\d{2}$/
        t1 = parse_dt.call(s)
        t2 = t1 + 60 - 1 # Cover the entire minute
        return [t1.to_f, t2.to_f]
      end
      # Time-of-day only with second precision: 10:40:30
      if s =~ /^\d{1,2}:\d{2}:\d{2}$/
        t1 = parse_dt.call(s)
        t2 = t1 + 1 - 0.001 # Cover that exact second
        return [t1.to_f, t2.to_f]
      end
      # Absolute time (fallback for other formats)
      t = parse_dt.call(s)
      t ? [t.to_f, nil] : [nil, nil]
    end
    # ...existing code...
  end

  module Config
    module_function

    # Local helper: format bytes human-readably for DB reports
    def format_bytes(bytes)
      units = ['B', 'KB', 'MB', 'GB', 'TB']
      size = bytes.to_f
      unit_index = 0

      while size >= 1024 && unit_index < units.length - 1
        size /= 1024
        unit_index += 1
      end

      "#{size.round(2)} #{units[unit_index]}"
    end

    def build_cleanup_option_parser(options)
      OptionParser.new do |opts|
        opts.on("--fuzzy", "Enable fuzzy (fzf-like) matching for command text") { options[:fuzzy] = true }
        opts.on("--command [PATTERN]", "Filter by command text (with optional fuzzy matching)") do |pattern|
          options[:command_pattern] = pattern
        end
        opts.banner = "Usage: histlog db cleanup [options]"
        opts.on("-v", "--verbose", "Show detailed cleanup progress") { options[:verbose] = true }
        opts.on("-n", "--dry-run", "Show what would be cleaned without making changes") { options[:dry_run] = true }
        opts.on("-h", "--help", "Show this help") do
          puts opts
          exit 0
        end
      end
    end

    def build_info_option_parser(options)
      OptionParser.new do |opts|
        opts.banner = "Usage: histlog db info [options]"
        opts.on("-v", "--verbose", "Show detailed system information") { options[:verbose] = true }
        opts.on("-h", "--help", "Show this help") do
          puts opts
          exit 0
        end
      end
    end

    DEFAULT_DB_PATH = File.expand_path('~/.local/share/histlog/histlog.db')

    COMMAND_OPTION_DEFAULTS = {
      paths: {
        files: false,
        dirs: false,
        searchterm: nil,
        regex: false,
        count: false,
        lift_files: false,
        roll_up_dirs: false,
        asc: false,
        desc: false,
        sort_by: nil,
        format: nil
      },
      cleanup: {
        verbose: false,
        dry_run: false
      },
      info: {
        verbose: false
      }
    }.freeze

    COLOR_PALETTES = {
      general: {
        reset: "\e[0m"
      },
      paths: {
        exec: "\e[38;5;207m",
        args: "\e[38;5;80m",
        dir_path: "\e[38;5;12m"
      },
      history: {
        timestamp: "\e[38;5;14m",
        duration: "\e[33m",
        status_success: "\e[38;5;84m",
        status_fail: "\e[38;5;203m",
        # Use terminal color 8 (grey/dark) for null/unknown values
        status_null: "\e[38;5;8m",
        status_header: "\e[38;5;141m"
      }
    }.freeze

    def command_options(command)
      COMMAND_OPTION_DEFAULTS.fetch(command, {}).dup
    end

    # Return the default history file path for a given shell name (zsh, bash, fish, nu)
    def default_history_for_shell(shell_name)
      home = Dir.home
      case shell_name
      when 'fish'
        fish_hist = File.join(home, '.local/share/fish/fish_history')
        return fish_hist if File.exist?(fish_hist)
      when 'zsh'
        candidates = [File.join(home, '.zsh_history'), File.join(home, '.zhistory'), ENV['HISTFILE']].compact
        candidates.each { |c| return c if File.exist?(c) }
      when 'nu', 'nushell'
        nu_config_dir = ENV['XDG_CONFIG_HOME'] || File.join(home, '.config')
        candidate = File.join(nu_config_dir, 'nushell/history.txt')
        return candidate if File.exist?(candidate)

        candidate2 = File.join(home, '.config/nushell/history.txt')
        return candidate2 if File.exist?(candidate2)
      when 'bash'
        bash_hist = File.join(home, '.bash_history')
        return bash_hist if File.exist?(bash_hist)
      end
      nil
    end

    def colors(context = nil)
      palette = COLOR_PALETTES[:general].dup
      palette.merge!(COLOR_PALETTES[context]) if context && COLOR_PALETTES.key?(context)
      palette
    end

    def db_path
      env_path = ENV['HISTLOG_DB']&.strip
      if env_path && !env_path.empty?
        File.expand_path(env_path)
      else
        DEFAULT_DB_PATH
      end
    end
  end

  # CLI command handling module
  module CLI
    # Common utilities shared across CLI modules
    module Common
      module_function

      # Formatting utilities
      def format_bytes(bytes)
        units = ['B', 'KB', 'MB', 'GB', 'TB']
        size = bytes.to_f
        unit_index = 0

        while size >= 1024 && unit_index < units.length - 1
          size /= 1024
          unit_index += 1
        end

        "#{size.round(2)} #{units[unit_index]}"
      end

      def format_time(timestamp)
        return 'unknown' unless timestamp

        # Convert from Julian Day to Unix timestamp
        unix_time = (timestamp - 2440587.5) * 86400
        Time.at(unix_time).strftime('%Y-%m-%d %H:%M:%S')
      end

      def format_duration(duration)
        return 'N/A' unless duration

        if duration < 1
          "#{(duration * 1000).round(1)}ms"
        elsif duration < 60
          "#{duration.round(2)}s"
        elsif duration < 3600
          minutes = (duration / 60).to_i
          seconds = (duration % 60).round(1)
          "#{minutes}m #{seconds}s"
        else
          hours = (duration / 3600).to_i
          minutes = ((duration % 3600) / 60).to_i
          "#{hours}h #{minutes}m"
        end
      end

      # Database utilities
      def ensure_database_exists(db_path)
        unless File.exist?(db_path)
          raise "Database not found: #{db_path}"
        end

        true
      end

      def format_database_error(error)
        "Database error: #{error.message}"
      end

      # Option parsing
      def build_cleanup_option_parser(options)
        OptionParser.new do |opts|
          opts.banner = "Usage: histlog db cleanup [options]"
          opts.on("-v", "--verbose", "Show detailed cleanup progress") { options[:verbose] = true }
          opts.on("-n", "--dry-run", "Show what would be cleaned without making changes") { options[:dry_run] = true }
          opts.on("-h", "--help", "Show this help") do
            puts opts
            exit 0
          end
        end
      end

      def build_info_option_parser(options)
        OptionParser.new do |opts|
          opts.banner = "Usage: histlog db info [options]"
          opts.on("-v", "--verbose", "Show detailed system information") { options[:verbose] = true }
          opts.on("-h", "--help", "Show this help") do
            puts opts
            exit 0
          end
        end
      end

      # Color palette access (delegate to Config)
      def colors(context = nil)
        Histlog::Config.colors(context)
      end
    end

    module_function

    # Print top-level help. If all is true, include porcelain/internal commands as well.
    def show_help(all = false)
      puts "Usage: histlog <command> [options]"
      puts ""

      puts "Available commands:"
      puts "  query       - Flexible interactive query of your command history"
      puts "  history     - Show recent commands (supports many filters)"
      puts "  sessions    - List and inspect recorded shell sessions"
      puts "  import      - Import shell history from files (json, yaml, fish, zsh, nu, bash)"
      puts "  paths       - Show tracked file/directory paths and usage counts"
      puts "  db          - Database operations (cleanup, info, stats, maintain)"
      puts "  init        - Print shell integration snippets for supported shells"
      puts "  mcp         - Run the MCP server (developer feature)"
      puts "  help        - Show this help"

      puts ""
      puts "Global flags:"
      puts "  -h, --help        Show top-level help (this page)"
      puts "  --help-all        Show full help including porcelain/internal commands"
      puts ""
      puts "Environment variables (affect behavior):"
      puts "  HISTLOG_DB        Path to the histlog SQLite database (overrides default)"

      if all
        puts ""
        puts "Porcelain / internal commands (normally hidden):"
        puts "  _on_session - Initialize a new shell session (internal)"
        puts "  _on_preexec - Record command start (internal)"
        puts "  _on_postcmd - Record command completion (internal)"
      end

      puts ""
      puts "For command-specific help run: histlog <command> --help"
    end

    def build_paths_option_parser(options)
      OptionParser.new do |opts|
        opts.banner = "Usage: histlog paths [--files] [--dirs] [SEARCHTERM] [--regex] [--count] [--asc|--desc] [--sort-by FIELD]"
        opts.on("--files", "Show all unique file paths") { options[:files] = true }
        opts.on("--dirs", "Show all unique directory paths") { options[:dirs] = true }
        opts.on("--regex", "Interpret searchterm as a Ruby regex") { options[:regex] = true }
        opts.on("--count", "Show usage frequency for each path") { options[:count] = true }
        opts.on("--asc", "Order results ascending") { options[:asc] = true }
        opts.on("--desc", "Order results descending") { options[:desc] = true }
        opts.on("--sort-by FIELD", "Sort by exec, args, path, or type") { |field| options[:sort_by] = field }
        opts.on("-a", "--lift-files", "Lift file usage counts to their parent directories") {
          options[:lift_files] = true
        }
        opts.on("-A", "--roll-up-dirs", "Roll up directory usage counts to their ancestor directories") {
          options[:roll_up_dirs] = true
        }
        opts.on("--plain", "Output only paths, one per line") { options[:format] = 'plain' }
        opts.on("--fuzzy", "Enable fuzzy matching for path searchterm") { options[:fuzzy] = true }
      end
    end

    def show_paths_command(args)
      options = Histlog::Config.command_options(:paths)
      build_paths_option_parser(options).parse!(args)
      # Accept positional searchterm
      if args.length > 0 && !args[0].start_with?('-')
        options[:searchterm] = args.shift
      end

      db_path = Histlog::Utils.get_db_path
      unless File.exist?(db_path)
        puts "No histlog.db found in current directory"
        return
      end

      db = nil
      begin
        db = SQLite3::Database.new(db_path)
        db.results_as_hash = true

        types = []
        types << 'file' if options[:files]
        types << 'dir' if options[:dirs]
        types = ['file', 'dir'] if types.empty?

        order = options[:desc] ? 'DESC' : 'ASC'
        select_count = options[:count] ? ', COUNT(*) as usage_count' : ''
        group_by = options[:count] ? ' GROUP BY path' : ''
        type_cond = types.length == 2 ? "type IN ('f','d')" : "type = '#{types[0] == 'file' ? 'f' : 'd'}'"
        query = "SELECT path, type#{select_count} FROM paths WHERE #{type_cond}"
        params = []
        if options[:searchterm]
          if options[:regex]
            query << " AND path REGEXP ?"
            params << options[:searchterm]
          else
            query << " AND path LIKE ?"
            params << "%#{options[:searchterm]}%"
          end
        end
        query << group_by
        query << " ORDER BY "
        if options[:count]
          query << "usage_count #{order}, path #{order}"
        else
          query << "path #{order}"
        end

        rows = []
        begin
          rows = db.execute(query, params)
        rescue SQLite3::SQLException => e
          if options[:regex] && options[:searchterm] && e.message =~ /no such function: REGEXP/
            fallback_query = query.sub(/path REGEXP \?/, '1')
            rows = db.execute(fallback_query, params[0..-2])
            begin
              re = Regexp.new(options[:searchterm])
              rows = rows.select { |row| row['path'] =~ re }
            rescue RegexpError => re_err
              STDERR.puts "Invalid regex: #{re_err.message}"
              rows = []
            end
          else
            raise e
          end
        end

        if options[:format] == 'plain'
          begin
            rows.each do |row|
              path_value = row['path']
              if row['type'] == 'd'
                puts path_value.end_with?('/') ? path_value : (path_value + '/')
              else
                puts path_value
              end
            end
          rescue Errno::EPIPE
            return
          end
          return
        end

        if rows.empty?
          puts "No results found."
          return
        end

        data_rows = rows.map do |row|
          canonical_type = row['type']
          canonical_path = canonicalize_path(row['path'], canonical_type)
          path_id = db.get_first_value("SELECT id FROM paths WHERE path = ?", row['path'])
          args_count = 0
          exec_count = 0
          if path_id
            args_count = db.get_first_value("SELECT COUNT(*) FROM path_args WHERE path_id = ?", path_id) || 0
            exec_count = db.get_first_value(
              "SELECT COUNT(*) FROM commands WHERE path_old_id = ? OR path_new_id = ?",
              path_id,
              path_id
            ) || 0
          end

          {
            'path' => canonical_path,
            'type' => canonical_type,
            'exec' => exec_count.to_i,
            'args' => args_count.to_i
          }
        end

        if options[:lift_files] || options[:roll_up_dirs]
          data_rows = apply_path_aggregation(data_rows, options)
        end

        data_rows = sort_path_rows(data_rows, options)

        palette = Histlog::Config.colors(:paths)
        exec_col = palette[:exec]
        args_col = palette[:args]
        dir_path_col = palette[:dir_path]
        reset_col = palette[:reset]

        begin
          printf("%s%6s%s %s%6s%s %s\n", exec_col, "Exec", reset_col, args_col, "Args", reset_col, "Path")
          puts "-------------------------"
        rescue Errno::EPIPE
          return
        end

        data_rows.each do |row|
          exec_count = row['exec'].to_i
          args_count = row['args'].to_i
          exec_str = exec_count.to_s.rjust(6)
          args_str = args_count.to_s.rjust(6)

          display_path = if row['type'] == 'd'
                           if row['path'] == '/'
                             "#{dir_path_col}/#{reset_col}"
                           else
                             base = row['path'].end_with?('/') ? row['path'].chomp('/') : row['path']
                             "#{dir_path_col}#{base}#{reset_col}/"
                           end
                         else
                           row['path']
                         end

          begin
            puts "#{exec_col}#{exec_str}#{reset_col} #{args_col}#{args_str}#{reset_col} #{display_path}"
          rescue Errno::EPIPE
            return
          end
        end
      ensure
        db&.close
      end
    end

    # Database subcommand helpers (group DB-related CLI operations)
    module DB
      module_function

      # OptionParser for `histlog db info` - delegates to Common
      def build_info_option_parser(options)
        Histlog::CLI::Common.build_info_option_parser(options)
      end

      def db_cleanup(args)
        options = Histlog::Config.command_options(:cleanup)
        Histlog::CLI::Common.build_cleanup_option_parser(options).parse!(args)

        db_path = Histlog::Utils.get_db_path
        unless File.exist?(db_path)
          puts "No histlog.db found in current directory"
          return
        end

        db = SQLite3::Database.new(db_path)
        db.results_as_hash = true

        if options[:dry_run]
          puts "=== Dry Run: Orphaned Entries Found ==="

          # Count orphaned paths
          orphan_paths = db.get_first_value(<<-SQL)
            SELECT COUNT(*) FROM paths p
            LEFT JOIN commands c1 ON p.id = c1.path_old_id
            LEFT JOIN commands c2 ON p.id = c2.path_new_id
            LEFT JOIN path_args pa ON p.id = pa.path_id
            WHERE c1.id IS NULL AND c2.id IS NULL AND pa.command_id IS NULL
          SQL
          puts "Would remove #{orphan_paths} orphaned paths"

          # Count orphaned cmd_texts
          orphan_cmd_texts = db.get_first_value(<<-SQL)
            SELECT COUNT(*) FROM cmd_texts ct
            LEFT JOIN commands c ON ct.id = c.cmd_text_id
            WHERE c.id IS NULL
          SQL
          puts "Would remove #{orphan_cmd_texts} orphaned cmd_texts"

          # Count orphaned path_args
          orphan_path_args = db.get_first_value(<<-SQL)
            SELECT COUNT(*) FROM path_args pa
            LEFT JOIN paths p ON pa.path_id = p.id
            LEFT JOIN commands c ON pa.command_id = c.id
            WHERE p.id IS NULL OR c.id IS NULL
          SQL
          puts "Would remove #{orphan_path_args} orphaned path_args"

          # Count orphaned ttys, shells, sessions (with error handling)
          begin
            orphan_ttys = db.get_first_value(<<-SQL)
              SELECT COUNT(*) FROM ttys t
              LEFT JOIN sessions s ON t.id = s.tty_id
              WHERE s.id IS NULL
            SQL
            puts "Would remove #{orphan_ttys} orphaned ttys"
          rescue SQLite3::SQLException => e
            puts "Cannot check ttys: #{e.message}"
          end

          begin
            orphan_shells = db.get_first_value(<<-SQL)
              SELECT COUNT(*) FROM shells s
              LEFT JOIN sessions sess ON s.id = sess.shell_id
              WHERE sess.id IS NULL
            SQL
            puts "Would remove #{orphan_shells} orphaned shells"
          rescue SQLite3::SQLException => e
            puts "Cannot check shells: #{e.message}"
          end

          begin
            orphan_sessions = db.get_first_value(<<-SQL)
              SELECT COUNT(*) FROM sessions s
              LEFT JOIN commands c ON s.id = c.session_id
              WHERE c.id IS NULL
            SQL
            puts "Would remove #{orphan_sessions} orphaned sessions"
          rescue SQLite3::SQLException => e
            puts "Cannot check sessions: #{e.message}"
          end

          puts "\nRun 'histlog cleanup' without --dry-run to perform cleanup."
        else
          Histlog::DB.cleanup_orphaned_entries(db, options[:verbose])
        end

        db.close
      end

      def db_info(args)
        options = Histlog::Config.command_options(:info)
        build_info_option_parser(options).parse!(args)

        db_path = Histlog::Utils.get_db_path

        puts "=== Histlog Database Information ==="
        puts "Database path: #{db_path}"

        if File.exist?(db_path)
          puts "Database exists: Yes"
          puts "Database size: #{Histlog::CLI::Common.format_bytes(File.size(db_path))}"
          puts "Last modified: #{File.mtime(db_path).strftime('%Y-%m-%d %H:%M:%S')}"

          # Connect to get database info
          db = SQLite3::Database.new(db_path)
          db.results_as_hash = true

          # Print schema_version (if present) near the top-level info
          begin
            sv = db.get_first_value("SELECT value FROM metadata WHERE key = 'schema_version'")
            puts "DB schema version: #{sv}" if sv
          rescue SQLite3::SQLException
            # ignore if metadata table is missing
          end

          # Get table counts
          puts "\n=== Table Statistics ==="
          tables = %w[commands cmd_texts paths path_args sessions shells ttys]
          tables.each do |table|
            begin
              count = db.get_first_value("SELECT COUNT(*) FROM #{table}")
              puts "#{table.ljust(12)}: #{count} records"
            rescue SQLite3::SQLException => e
              puts "#{table.ljust(12)}: (error: #{e.message})"
            end
          end

          # Database settings
          puts "\n=== Database Configuration ==="
          begin
            journal_mode = db.get_first_value("PRAGMA journal_mode")
            synchronous = db.get_first_value("PRAGMA synchronous")
            cache_size = db.get_first_value("PRAGMA cache_size")
            page_size = db.get_first_value("PRAGMA page_size")

            puts "Journal mode: #{journal_mode}"
            puts "Synchronous: #{synchronous}"
            puts "Cache size: #{cache_size} pages"
            puts "Page size: #{page_size} bytes"
          rescue SQLite3::SQLException => e
            puts "Could not retrieve database settings: #{e.message}"
          end

          # Integrity check
          puts "\n=== Database Health ==="
          begin
            integrity = db.get_first_value("PRAGMA integrity_check")
            puts "Integrity check: #{integrity}"
          rescue SQLite3::SQLException => e
            puts "Integrity check failed: #{e.message}"
          end

          if options[:verbose]
            # Show recent activity
            puts "\n=== Recent Activity ==="
            begin
              recent = db.execute(<<-SQL, [Time.now.to_f - 86400])
                SELECT COUNT(*) as count, DATE(start_time, 'unixepoch') as date
                FROM commands
                WHERE start_time > ?
                GROUP BY DATE(start_time, 'unixepoch')
                ORDER BY date DESC
                LIMIT 7
              SQL

              if recent.any?
                puts "Commands executed in last 7 days:"
                recent.each do |row|
                  puts "  #{row['date']}: #{row['count']} commands"
                end
              else
                puts "No recent command activity found"
              end
            rescue SQLite3::SQLException => e
              puts "Could not retrieve recent activity: #{e.message}"
            end

            # Show schema_version and migration metadata if present
            puts "\n=== Schema / Migration Metadata ==="
            begin
              # metadata table may not exist on very old DBs
              meta_exists = db.get_first_value("SELECT name FROM sqlite_master WHERE type='table' AND name='metadata'")
              if meta_exists
                rows = db.execute("SELECT key, value FROM metadata ORDER BY key")
                if rows && rows.any?
                  rows.each do |r|
                    puts "#{r['key'].ljust(20)}: #{r['value']}"
                  end
                else
                  puts "No metadata entries found."
                end
              else
                puts "No metadata table found in DB."
              end
            rescue SQLite3::SQLException => e
              puts "Could not read metadata: #{e.message}"
            end
            # Show table sizes
            puts "\n=== Detailed Table Information ==="
            tables.each do |table|
              begin
                result = db.execute("SELECT COUNT(*) as count, MIN(created_at) as first, MAX(created_at) as last FROM #{table}").first
                if result && result['count'] > 0
                  first_date = result['first'] ? Time.at((result['first'] - 2440587.5) * 86400).strftime('%Y-%m-%d') : 'unknown'
                  last_date = result['last'] ? Time.at((result['last'] - 2440587.5) * 86400).strftime('%Y-%m-%d') : 'unknown'
                  puts "#{table}:"
                  puts "  Records: #{result['count']}"
                  puts "  First entry: #{first_date}"
                  puts "  Last entry: #{last_date}"
                end
              rescue SQLite3::SQLException => e
                puts "#{table}: (error: #{e.message})"
              end
            end
          end

          db.close
        else
          puts "Database exists: No"
          puts "Run 'histlog help' to get started"
        end

        # System information
        puts "\n=== System Information ==="
        puts "Histlog script: #{File.expand_path(__FILE__)}"
        puts "Ruby version: #{RUBY_VERSION}"
        puts "SQLite3 gem: #{SQLite3::VERSION}" rescue puts "SQLite3 gem: (not available)"
        puts "Operating system: #{RUBY_PLATFORM}"

        # Environment variables
        puts "\n=== Environment ==="
        puts "HISTLOG_DB: #{ENV['HISTLOG_DB'] || '(not set)'}"
        puts "Session ID: #{ENV['__histlog_session_id'] || '(not set)'}"
        puts "Current shell: #{ENV['SHELL'] || '(unknown)'}"
        puts "Current TTY: #{Histlog::Utils.get_tty rescue '(unknown)'}"

        if options[:verbose]
          puts "\n=== Shell Integration Status ==="
          shells = {
            'fish' => '~/.config/fish/config.fish',
            'zsh' => '~/.zshrc',
            'bash' => '~/.bashrc'
          }

          shells.each do |shell, config_file|
            expanded_path = File.expand_path(config_file)
            if File.exist?(expanded_path)
              content = File.read(expanded_path)
              if content.include?('histlog')
                puts "#{shell.capitalize}: ✓ Integrated (found in #{config_file})"
              else
                puts "#{shell.capitalize}: ✗ Not integrated (#{config_file} exists but no histlog found)"
              end
            else
              puts "#{shell.capitalize}: ? Config file not found (#{config_file})"
            end
          end
        end
      end

      def db_stats(args)
        OptionParser.new do |opts|
          opts.banner = "Usage: histlog stats [options]"
          opts.on("-h", "--help", "Show this help message") do
            puts opts
            puts
            puts "Shows a summary of command history, most frequent commands, most accessed paths, and common failures."
            puts "Example output:"
            puts "\n=== Command History Summary ==="
            puts "Total commands executed: 56"
            puts "Unique commands: 42"
            puts "Failed commands: 7 (12.5%)"
            puts "Arguments tracked as paths: 12"
            puts "\n=== Most Frequent Commands ==="
            puts "Count  Avg Time Command"
            exit 0
          end
        end.parse!(args)

        # Connect to database
        db_path = Histlog::Utils.get_db_path
        unless File.exist?(db_path)
          puts "No histlog.db found in current directory"
          return
        end

        db = SQLite3::Database.new(db_path)
        db.results_as_hash = true

        puts "=== Command History Summary ==="
        puts

        # Basic stats
        total_commands = db.execute("SELECT COUNT(*) as count FROM commands")[0]['count']
        unique_commands = db.execute("SELECT COUNT(*) as count FROM cmd_texts")[0]['count']
        failed_commands = db.execute("SELECT COUNT(*) as count FROM commands WHERE exit_code != 0")[0]['count']
        tracked_paths = db.execute("SELECT COUNT(*) as count FROM path_args")[0]['count']

        puts "Total commands executed: #{total_commands}"
        puts "Unique commands: #{unique_commands}"
        puts "Failed commands: #{failed_commands} (#{(failed_commands.to_f / total_commands * 100).round(2)}%)" if total_commands > 0
        puts "Arguments tracked as paths: #{tracked_paths}"

        if total_commands > 0
          # Most used commands
          puts "\n=== Most Frequent Commands ==="
          frequent_commands = db.execute(<<-SQL)
            SELECT
              cmd_texts.command AS cmd_text,
              COUNT(*) as count,
              AVG(c.duration) as avg_duration,
              MAX(c.created_at) as last_seen
            FROM commands c
            JOIN cmd_texts ON c.cmd_text_id = cmd_texts.id
            WHERE c.duration IS NOT NULL
            GROUP BY cmd_texts.id
            ORDER BY count DESC
            LIMIT 10
          SQL

          if frequent_commands.any?
            puts "% -6s %-8s %-50s %-s" % ["Count", "Avg Time", "Command", "Last Used"]
            puts "-" * 85
            frequent_commands.each do |cmd|
              avg_time = Histlog::Utils.format_duration(cmd['avg_duration'])
              last_used = Histlog::Utils.format_time(cmd['last_seen'])
              command_text = Histlog::Utils.truncate_command(cmd['cmd_text'], 45)
              puts "% -6s %-8s %-50s %-s" % [cmd['count'], avg_time, command_text, last_used]
            end
          end

          # Most accessed paths
          puts "\n=== Most Accessed Paths ==="
          frequent_paths = db.execute(<<-SQL)
            SELECT
              p.path,
              p.type,
              COUNT(*) as usage_count
            FROM path_args ca
            JOIN paths p ON ca.path_id = p.id
            GROUP BY p.path
            ORDER BY usage_count DESC
            LIMIT 10
          SQL

          if frequent_paths.any?
            puts "% -6s %-4s %-s" % ["Count", "Type", "Path"]
            puts "-" * 60
            frequent_paths.each do |path_data|
              type_name = path_data['type'] == 'd' ? 'dir' : 'file'
              puts "% -6s %-4s %-s" % [path_data['usage_count'], type_name, path_data['path']]
            end
          else
            puts "No path arguments tracked yet"
          end

          # Most common failures
          if failed_commands > 0
            puts "\n=== Most Common Failures ==="
            common_failures = db.execute(<<-SQL)
              SELECT
                cmd_texts.command AS cmd_text,
                c.exit_code,
                COUNT(*) as count,
                MAX(c.created_at) as last_failure
              FROM commands c
              JOIN cmd_texts ON c.cmd_text_id = cmd_texts.id
              WHERE c.exit_code != 0
              GROUP BY cmd_texts.id, c.exit_code
              ORDER BY count DESC
              LIMIT 10
            SQL

            puts "% -6s %-4s %-50s %-s" % ["Count", "Exit", "Command", "Last Failure"]
            puts "-" * 85
            common_failures.each do |failure|
              command_text = Histlog::Utils.truncate_command(failure['cmd_text'], 45)
              last_fail = Histlog::Utils.format_time(failure['last_failure'])
              puts "% -6s %-4s %-50s %-s" % [failure['count'], failure['exit_code'], command_text, last_fail]
            end
          end
        end
        db.close
      end

      def db_maintain(args)
        require 'optparse'
        options = {
          cleanup: false,
          optimize: false,
          vacuum: false,
          integrity: false,
          all: false
        }

        OptionParser.new do |opts|
          opts.banner = "Usage: histlog db maintain [options]"
          opts.on("--cleanup", "Clean up orphaned entries") { options[:cleanup] = true }
          opts.on("--optimize", "Optimize database performance") { options[:optimize] = true }
          opts.on("--vacuum", "Vacuum database") { options[:vacuum] = true }
          opts.on("--integrity", "Check database integrity") { options[:integrity] = true }
          opts.on("--all", "Run all maintenance operations") { options[:all] = true }
          opts.on("--migrate", "Run database migrations") { options[:migrate] = true }
        end.parse!(args)

        db_path = Histlog::DB.path

        # If migrate option provided, run migrations and return (initialize_db will create DB and run migrations)
        if options[:migrate]
          migrate_database
          return
        end

        unless File.exist?(db_path)
          puts "No histlog.db found in current directory"
          return
        end

        # Always set original_size before any actions
        original_size = File.size(db_path) rescue 0

        db = SQLite3::Database.new(db_path)
        db.results_as_hash = true

        actions = []
        actions << :cleanup if options[:cleanup] || options[:all]
        actions << :optimize if options[:optimize] || options[:all]
        actions << :vacuum if options[:vacuum] || options[:all]
        actions << :integrity if options[:integrity] || options[:all]

        if actions.empty?
          # No options: show short report and ask for confirmation
          puts "=== Histlog Maintenance Preview ==="
          # Preview orphaned entries
          orphan_paths = db.get_first_value(<<-SQL)
              SELECT COUNT(*) FROM paths p
              LEFT JOIN commands c1 ON p.id = c1.path_old_id
              LEFT JOIN commands c2 ON p.id = c2.path_new_id
              LEFT JOIN path_args pa ON p.id = pa.path_id
              WHERE c1.id IS NULL AND c2.id IS NULL AND pa.command_id IS NULL
          SQL
          orphan_cmd_texts = db.get_first_value(<<-SQL)
              SELECT COUNT(*) FROM cmd_texts ct
              LEFT JOIN commands c ON ct.id = c.cmd_text_id
              WHERE c.id IS NULL
          SQL
          orphan_path_args = db.get_first_value(<<-SQL)
              SELECT COUNT(*) FROM path_args pa
              LEFT JOIN paths p ON pa.path_id = p.id
              LEFT JOIN commands c ON pa.command_id = c.id
              WHERE p.id IS NULL OR c.id IS NULL
          SQL
          orphan_sessions = db.get_first_value(<<-SQL)
              SELECT COUNT(*) FROM sessions s
              LEFT JOIN commands c ON s.id = c.session_id
              WHERE c.id IS NULL
          SQL
          puts "Orphaned paths:      #{orphan_paths}"
          puts "Orphaned cmd_texts:  #{orphan_cmd_texts}"
          puts "Orphaned path_args:  #{orphan_path_args}"
          puts "Orphaned sessions:   #{orphan_sessions}"
          # Integrity check
          integrity = db.get_first_value("PRAGMA integrity_check")
          puts "Integrity check:     #{integrity}"
          # Database size
          puts "Database size:      #{Histlog::CLI::Common.format_bytes(original_size)}"
          puts "\nThis will run: cleanup, optimize, vacuum, integrity check."
          print "Proceed with all maintenance steps? [y/N]: "
          answer = STDIN.gets.chomp.downcase
          if answer == 'y' || answer == 'yes'
            actions = [:cleanup, :optimize, :vacuum, :integrity]
          else
            puts "Maintenance cancelled."
            db.close if db
            return
          end
        end

        actions.each do |action|
          case action
          when :cleanup
            puts "\n--- Running cleanup ---"
            Histlog::DB.cleanup_orphaned_entries(db, true)
          when :optimize
            puts "\n--- Running optimize ---"
            begin
              puts "Running ANALYZE..."
              db.execute "ANALYZE"
              puts "Rebuilding indexes..."
              db.execute "REINDEX"
              puts "Running VACUUM..."
              db.execute "VACUUM"
              puts "Optimize complete."
            rescue => e
              STDERR.puts "Error optimizing database: #{e.message}"
            end
          when :vacuum
            puts "\n--- Running VACUUM ---"
            begin
              db.execute "VACUUM"
              puts "VACUUM complete."
            rescue => e
              STDERR.puts "Error running VACUUM: #{e.message}"
            end
          when :integrity
            puts "\n--- Running integrity check ---"
            begin
              integrity = db.get_first_value("PRAGMA integrity_check")
              puts "Integrity check: #{integrity}"
            rescue => e
              STDERR.puts "Integrity check failed: #{e.message}"
            end
          end
        end

        # Print summary after execution
        db.close if db
        puts "\n=== Maintenance Summary ==="
        old_size = defined?(original_size) ? original_size : File.size(db_path)
        new_size = File.size(db_path)
        puts "Database size before: #{Histlog::CLI::Common.format_bytes(old_size)}"
        puts "Database size after:  #{Histlog::CLI::Common.format_bytes(new_size)}"
        savings = old_size - new_size
        percentage = savings > 0 ? (savings.to_f / old_size * 100).round(2) : 0
        if savings > 0
          puts "Space saved:         #{Histlog::CLI::Common.format_bytes(savings)} (#{percentage}%)"
        else
          puts "Space saved:         0 (already optimized)"
        end
        # Reopen DB for integrity check
        db2 = SQLite3::Database.new(db_path)
        db2.results_as_hash = true
        integrity = db2.get_first_value("PRAGMA integrity_check")
        puts "Integrity check:     #{integrity}"
        db2.close if db2
        puts "Maintenance complete."
      end

      def db_migrate(args)
        migrate_database
      end

      def migrate_database
        begin
          # initialize_db will create DB and run migrations (idempotent)
          Histlog::DB.initialize_db
          puts "Database schema updated successfully!"
          puts "You can now use histlog normally."
        rescue => e
          STDERR.puts "Migration failed: #{e.message}"
          STDERR.puts "Try running: histlog db migrate"
          exit 1
        end
      end

      def db_optimize(args)
        db_maintain(['--optimize'])
      end

      def db_integrity(args)
        db_maintain(['--integrity'])
      end

      def db_full_maintenance(args)
        db_maintain(['--all'])
      end

      def show_db_help
        puts "Usage: histlog db <subcommand> [options]"
        puts ""
        puts "Database operations:"
        puts "  cleanup           Remove orphaned database entries"
        puts "  info              Show database information"
        puts "  stats             Show command statistics"
        puts "  integrity         Check database integrity"
        puts "  migrate           Update database schema"
        puts "  optimize          Optimize database performance"
        puts "  full-maintenance  Run all maintenance operations (cleanup, optimize, vacuum, integrity check)"
        puts ""
        puts "Run 'histlog db <subcommand> --help' for command-specific help where available."
      end
    end

    def sort_path_rows(rows, options)
      sorted = rows.map do |row|
        {
          'path' => row['path'],
          'type' => row['type'],
          'exec' => row['exec'].to_i,
          'args' => row['args'].to_i
        }
      end

      if options[:sort_by]
        case options[:sort_by]
        when 'exec'
          sorted.sort_by! { |row| [row['exec'], row['path']] }
        when 'args'
          sorted.sort_by! { |row| [row['args'], row['path']] }
        when 'type'
          sorted.sort_by! { |row| [row['type'], row['path']] }
        else
          sorted.sort_by! { |row| row['path'] }
        end
      elsif options[:count]
        sorted.sort_by! { |row| [row['exec'] + row['args'], row['path']] }
      else
        sorted.sort_by! { |row| row['path'] }
      end

      sorted.reverse! if options[:desc]
      sorted
    end

    def canonicalize_path(path, type)
      return nil unless path

      normalized = path.strip
      normalized = '/' if normalized.empty?

      return '/' if normalized == '/'

      if type == 'd'
        normalized = normalized.end_with?('/') ? normalized : "#{normalized}/"
      elsif type == 'f'
        normalized = normalized.end_with?('/') ? normalized.chomp('/') : normalized
      end

      normalized.gsub!(%r{/+}, '/')
      normalized
    end

    def get_parent_directory(path)
      return nil if path.nil? || path == '/'

      normalized = path.end_with?('/') ? path.chomp('/') : path
      parent = File.dirname(normalized)
      return '/' if parent == '/' || parent.empty?

      canonicalize_path(parent, 'd')
    end

    def get_ancestor_directories(path)
      canonical = canonicalize_path(path, 'd')
      ancestors = []
      current = get_parent_directory(canonical)
      while current
        ancestors << canonicalize_path(current, 'd')
        break if current == '/'

        current = get_parent_directory(current)
      end
      ancestors
    end

    def is_ancestor_of?(ancestor_path, child_path)
      # Check if ancestor_path is actually an ancestor of child_path
      # Both paths should be canonicalized (directories end with /)
      return false if ancestor_path == child_path

      # Simple string prefix check for canonicalized paths
      child_path.start_with?(ancestor_path)
    end

    def apply_path_aggregation(rows, options)
      aggregated = rows.map do |row|
        {
          'path' => canonicalize_path(row['path'], row['type']),
          'type' => row['type'],
          'exec' => row['exec'].to_i,
          'args' => row['args'].to_i
        }
      end

      index = {}
      aggregated.each { |row| index[row['path']] = row }

      if options[:lift_files]
        aggregated.select { |row| row['type'] == 'f' && row['args'] > 0 }.each do |file_row|
          parent_path = get_parent_directory(file_row['path'])
          next unless parent_path

          if parent_path == '/' && !index.key?('/') && !options[:roll_up_dirs]
            next
          end

          parent = index[parent_path]
          unless parent
            parent = {
              'path' => canonicalize_path(parent_path, 'd'),
              'type' => 'd',
              'exec' => 0,
              'args' => 0
            }
            aggregated << parent
            index[parent['path']] = parent
          end

          parent['args'] += file_row['args']
        end
      end

      if options[:roll_up_dirs]
        # Create a snapshot of current directories for roll-up to avoid modifying while iterating
        dir_snapshot = aggregated.select { |row| row['type'] == 'd' }.dup

        dir_snapshot.each do |dir_row|
          next if dir_row['path'] == '/'

          # Get all ancestors for this directory
          ancestors = get_ancestor_directories(dir_row['path'])

          ancestors.each do |ancestor_path|
            next if ancestor_path == dir_row['path'] # Skip self

            parent = index[ancestor_path]
            unless parent
              parent = {
                'path' => canonicalize_path(ancestor_path, 'd'),
                'type' => 'd',
                'exec' => 0,
                'args' => 0
              }
              aggregated << parent
              index[parent['path']] = parent
            end

            # Only add counts if this ancestor is actually an ancestor of the current directory
            # This prevents cross-contamination between unrelated directory trees
            if is_ancestor_of?(ancestor_path, dir_row['path'])
              parent['exec'] += dir_row['exec']
              parent['args'] += dir_row['args']
            end
          end
        end
      end

      aggregated
    end

    # Handle init command - print shell integration snippets
    def handle_init(args = [])
      shell = args.first&.downcase

      unless shell
        STDERR.puts "Usage: histlog init <shell>"
        STDERR.puts "Supported shells: fish, zsh, nu"
        exit 1
      end

      case shell
      when 'fish'
        puts "# Add to ~/.config/fish/config.fish:"
        puts "# histlog init fish | source"
        puts ""
        puts fish_config
      when 'zsh'
        puts "# Add to ~/.zshrc:"
        puts "# eval \"$(histlog init zsh)\""
        puts ""
        puts zsh_config
      when 'nu', 'nushell'
        puts "# Add to ~/.config/nushell/config.nu:"
        puts "# histlog init nu | save /tmp/histlog-nu-config.nu; source /tmp/histlog-nu-config.nu"
        puts ""
        puts nu_config
      else
        STDERR.puts "Error: Unsupported shell '#{shell}'"
        STDERR.puts "Supported shells: fish, zsh, nu"
        STDERR.puts "Usage: histlog init <shell>"
        exit 1
      end
    end

    # ...existing code...

    def show_history_list(args)
      options = {
        limit: 20,
        show_all: false,
        show_paths: false,
        filter_command: nil,
        filter_path: nil
      }

      OptionParser.new do |opts|
        opts.banner = "Usage: histlog history [options]"
        opts.on("-l", "--limit N", Integer,
                "Number of recent commands to show (default: 20). Negative N returns the first (earliest) N results.") { |n|
          options[:limit] = n
        }
        opts.on("-a", "--all", "Show all commands (ignore limit)") { options[:show_all] = true }
        opts.on("-p", "--paths", "Show path arguments for commands") { options[:show_paths] = true }
        opts.on("-c", "--command PATTERN", "Filter commands containing pattern") { |p| options[:filter_command] = p }
        opts.on("-d", "--dir PATH", "Filter commands that used specific directory") { |p|
          options[:filter_path] = File.expand_path(p)
        }
      end.parse!(args)

      db_path = Histlog::Utils.get_db_path
      unless File.exist?(db_path)
        puts "No histlog.db found in current directory"
        return
      end

      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true

      where_conditions = []
      params = []

      if options[:filter_command]
        where_conditions << "cmd.command LIKE ?"
        params << "%#{options[:filter_command]}%"
      end

      if options[:filter_path]
        where_conditions << "(p_old.path = ? OR p_new.path = ?)"
        params << options[:filter_path] << options[:filter_path]
      end

      where_clause = where_conditions.empty? ? "" : "WHERE #{where_conditions.join(' AND ')}"
      limit_clause = options[:show_all] ? "" : "LIMIT #{options[:limit]}"

      recent_commands_query = <<-SQL
        SELECT
          c.id as command_id,
          cmd.command AS cmd_text,
          c.start_time,
          c.duration,
          c.exit_code,
          p_old.path as cwd_old,
          p_new.path as cwd_new
        FROM commands c
        JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
        LEFT JOIN paths p_old ON c.path_old_id = p_old.id
        LEFT JOIN paths p_new ON c.path_new_id = p_new.id
        #{where_clause}
        ORDER BY c.start_time DESC
        #{limit_clause}
      SQL

      recent_commands = db.execute(recent_commands_query, params)

      if recent_commands.empty?
        puts "No commands found."
        return
      end

      # Print header matching interactive layout: Timestamp, Duration, Status, Command
      palette = Histlog::Config.colors(:history)
      ts_col = palette[:timestamp]
      dur_col = palette[:duration]
      status_col = palette[:status_header]
      success_col = palette[:status_success]
      reset_col = palette[:reset]
      printf("%s%-19s%s  %s%8s%s %s%-4s%s %s\n", ts_col, "Timestamp", reset_col, dur_col, "Duration", reset_col,
             success_col, "Exit", reset_col, "Command")
      puts "-" * 43
      # Color palette for history output
      palette = Histlog::Config.colors(:history)
      dur_col = palette[:duration]
      success_col = palette[:status_success]
      fail_col = palette[:status_fail]
      null_col = palette[:status_null]
      reset_col = palette[:reset]

      recent_commands.each do |cmd|
        duration = Histlog::Utils.format_duration(cmd['duration'])
        exit_code_raw = cmd['exit_code'] # could be nil for imported rows
        # Clean up command text: remove newlines/tabs and collapse multiple spaces
        raw_cmd = cmd['cmd_text'] || ''
        clean_cmd = raw_cmd.gsub(/\s+/, ' ').strip
        command_text = Histlog::Utils.truncate_command(clean_cmd, 80)
        timestamp = cmd['start_time'] ? Time.at(cmd['start_time']).strftime('%Y-%m-%d %H:%M:%S') : nil

        # Determine exit display: ✓ for 0, '/' for nil, or ✗<code>
        exit_text = if exit_code_raw == 0
                      "✓"
                    elsif exit_code_raw.nil?
                      "/"
                    else
                      "✗#{exit_code_raw}"
                    end

        exit_padded = exit_text[0, 4].ljust(4)
        colored_exit = if exit_code_raw == 0
                         "#{success_col}#{exit_padded}#{reset_col}"
                       elsif exit_code_raw.nil?
                         "#{null_col}#{exit_padded}#{reset_col}"
                       else
                         "#{fail_col}#{exit_padded}#{reset_col}"
                       end

        ts_display = timestamp || "????-??-?? ??:??:??"
        dur_display = duration || ' ?.??? '
        ts_color = timestamp ? ts_col : null_col
        dur_color = duration ? dur_col : null_col

        # duration field gets one extra left padding when null
        dur_field = duration ? sprintf('%8s', dur_display) : sprintf('%9s', dur_display)

        printf("%s%-19s%s  %s%s%s %s    %s\n", ts_color, ts_display, reset_col, dur_color, dur_field, reset_col,
               colored_exit, command_text)

        if options[:show_paths]
          path_args = db.execute(<<-SQL, [cmd['command_id']])
            SELECT p.path, p.type, ca.arg_position
            FROM path_args ca
            JOIN paths p ON ca.path_id = p.id
            WHERE ca.command_id = ?
            ORDER BY ca.arg_position
          SQL

          if path_args.any?
            path_args.each do |path_arg|
              type_indicator = path_arg['type'] == 'd' ? '📁' : '📄'
              puts "       #{' ' * 8}     #{type_indicator} [#{path_arg['arg_position']}] #{path_arg['path']}"
            end
          end
        end
      end
      db.close
    end

    def query_sessions(args)
      # Connect to database
      db_path = Histlog::Utils.get_db_path
      unless File.exist?(db_path)
        puts "No histlog.db found in current directory"
        return
      end

      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true

      puts "=== Sessions Summary ==="
      puts

      # Count sessions
      session_count = db.execute("SELECT COUNT(*) as count FROM sessions")[0]['count']
      puts "Total sessions: #{session_count}"

      if session_count > 0
        # Latest sessions
        puts "\n=== Recent Sessions ==="
        puts "%-10s %-15s %-15s %-10s %-30s %-s" % ["Session", "Shell", "TTY", "Timezone", "Created",
                                                    "Working Directory"]
        puts "-" * 160

        latest_sessions = db.execute(<<-SQL)
          SELECT
            s.id as session_id,
            sh.path as shell_path,
            t.device as tty_device,
            s.timezone,
            s.created_at,
            p.path as working_directory
    FROM sessions s
    LEFT JOIN shells sh ON s.shell_id = sh.id
    LEFT JOIN ttys t ON s.tty_id = t.id
    LEFT JOIN paths p ON s.path_id = p.id
          ORDER BY s.created_at DESC
          LIMIT 10
        SQL

        latest_sessions.each do |session|
          shell_name = session['shell_path'] ? File.basename(session['shell_path']) : 'unknown'
          tty_short = session['tty_device']&.gsub('/dev/', '') || 'unknown'
          timezone = session['timezone'] || 'unknown'
          created_time = Histlog::Utils.format_time(session['created_at'])

          puts "%-10s %-15s %-15s %-10s %-30s %-s" % [
            session['session_id'],
            shell_name,
            tty_short,
            timezone,
            created_time,
            session['working_directory']
          ]
        end

        # Session analysis
        puts "\n=== Session Analysis ==="
        shells = db.execute(<<-SQL)
          SELECT sh.path, COUNT(*) as count
    FROM sessions s
    LEFT JOIN shells sh ON s.shell_id = sh.id
          GROUP BY sh.id, sh.path
          ORDER BY count DESC
        SQL

        puts "Shells used:"
        shells.each do |shell_data|
          shell_name = shell_data['path'] ? File.basename(shell_data['path']) : 'unknown'
          puts "  #{shell_name}: #{shell_data['count']} sessions"
        end

        # TTY analysis
        puts "\nTTYs used:"
        ttys = db.execute(<<-SQL)
          SELECT t.device, COUNT(*) as count
    FROM sessions s
    LEFT JOIN ttys t ON s.tty_id = t.id
          GROUP BY t.id, t.device
          ORDER BY count DESC
        SQL

        ttys.each do |tty_data|
          tty_name = tty_data['device']&.gsub('/dev/', '') || 'unknown'
          puts "  #{tty_name}: #{tty_data['count']} sessions"
        end
      end

      db.close
    end

    def query_interactive(args)
      # Remove stray opts.on lines; these should be inside OptionParser.new do |opts| ... end
      # Parse command line options
      options = {
        search_term: nil,
        session: false,
        session_id: nil,
        current: false,
        dir: false,
        dir_path: nil,
        failed: false,
        success: false,
        exit_code: nil,
        today: false,
        yesterday: false,
        week: false,
        since: nil,
        after: nil,
        has_paths: false,
        path: nil,
        long: false,
        quick: false,
        slow: false,
        private: false,
        no_private: false,
        assisted: false,
        no_assisted: false,
        fast: false,
        instant: false,
        background: false,
        rare: false,
        frequent: false,
        unique: false,
        shell: nil,
        tty: nil,
        with_args: false,
        no_args: false,
        arg_count: nil,
        limit: nil,
        format: nil,
        no_session: false,
        no_start_time: false,
        no_exit_code: false,
        no_duration: false
      }

      OptionParser.new do |opts|
        opts.on("--regex PATTERN", "Filter commands using Ruby or SQLite regex (PATTERN)") do |pattern|
          options[:regex] = true
          options[:search_term] = pattern
        end
        opts.banner = "Usage: histlog query [search] [options]"
        opts.on("--delete", "Delete matching commands after confirmation") { options[:delete] = true }
        opts.on("--force-delete", "Delete matching commands without confirmation") { options[:force_delete] = true }
        opts.on("--asc", "Sort results in ascending order (oldest first) - DEFAULT") { options[:asc] = true }
        opts.on("--desc", "Sort results in descending order (newest first)") { options[:desc] = true }

        # Search and basic filters
        opts.on("--session [ID]",
                "Commands from current session (requires __histlog_session_id) or specific session ID") do |id|
          options[:session] = true
          options[:session_id] = id.to_i if id
        end

        # Command text filtering
        opts.on("--fuzzy", "Enable fuzzy (fzf-like) matching for command text") { options[:fuzzy] = true }
        opts.on("--command [PATTERN]", "Filter by command text (with optional fuzzy matching). If given without PATTERN, lists unique commands with counts") do |pattern|
          # If pattern is nil, user asked for the interactive list of unique commands
          options[:command_list] = pattern.nil?
          options[:command_pattern] = pattern
        end

        opts.on("--dir [PATH]", "Commands executed in current or specific directory") do |path|
          options[:dir] = true
          options[:dir_path] = path
        end

        # Status filters
        opts.on("--failed", "Only failed commands (exit_code != 0)") { options[:failed] = true }
        opts.on("--success", "Only successful commands (exit_code = 0)") { options[:success] = true }
        opts.on("--exit CODE", Integer, "Commands with specific exit code") { |code| options[:exit_code] = code }

        # Time filters
        opts.on("--time TIME",
                "Filter by time range. Examples: 2022-12-20 08:00..09:10:40, 2022-12-20..2022-12-21, ..2022-12-20, 2022-12-20.., 3w (last 3 weeks), 09:00..10:00 (today)") do |time|
          options[:time] = time
        end
        opts.on("--since TIME", "Commands since specified time") do |time|
          options[:time] = "#{time}.."
        end
        opts.on("--before TIME", "Commands before specified time") do |time|
          options[:time] = "..#{time}"
        end
        opts.on("--today", "Commands from today") { options[:time] = Time.now.strftime('%Y-%m-%d') }
        opts.on("--yesterday", "Commands from yesterday") { options[:time] = (Time.now - 86400).strftime('%Y-%m-%d') }
        opts.on("--week", "Commands from this week") do
          now = Time.now
          monday = now - ((now.wday + 6) % 7) * 86400
          options[:time] = "#{monday.strftime('%Y-%m-%d')}..#{now.strftime('%Y-%m-%d')}"
        end
        # --after deprecated: use --since with absolute timestamps or relative spans

        # Path filters
        opts.on("--has-paths", "Commands that touched filesystem paths") { options[:has_paths] = true }
        opts.on("--path PATH", "Commands that accessed specific path") { |path| options[:path] = path }

        # Performance filters
        opts.on("--long", "Commands longer than 50 characters") { options[:long] = true }
        opts.on("--duration DURATION",
                "Filter by command duration, e.g. 2m, >10s, <0.5, 3 (default s). Supports <, > prefix. Units: s, m, h, d, w.") do |duration_str|
          options[:duration] = Histlog::Utils.parse_duration_flag(duration_str)
        end
        # Duration shortcuts
        opts.on("--quick", "Commands that ran quickly (< 1s)") {
          options[:duration] = { type: :lt, value: 1.0, unit: :s }
        }
        opts.on("--fast", "Commands that ran very quickly (< 100ms)") {
          options[:duration] = { type: :lt, value: 0.1, unit: :s }
        }
        opts.on("--instant", "Commands that ran instantly (< 10ms)") {
          options[:duration] = { type: :lt, value: 0.01, unit: :s }
        }
        opts.on("--slow", "Commands that ran slowly (> 10s)") {
          options[:duration] = { type: :gt, value: 10.0, unit: :s }
        }
        opts.on("--background", "Long-running commands (> 60s)") {
          options[:duration] = { type: :gt, value: 60.0, unit: :s }
        }
        # Parse --duration flag value into {op: :lt|:gt, value: float, unit: :s|:m|:h|:d|:w}
        def self.parse_duration_flag(str)
          m = str.strip.match(/^(?<op>[<>\-+])?\s*(?<num>\d*\.?\d+)(?<unit>[smhdw])?$/i)
          raise ArgumentError, "Invalid duration format: #{str}" unless m

          op = m[:op]
          op = '<' if op.nil? || op == '-'
          op = '>' if op == '+'
          op_sym = op == '<' ? :lt : :gt
          value = m[:num].to_f
          unit = (m[:unit] || 's').downcase.to_sym
          { op: op_sym, value: value, unit: unit }
        end

        # Convert duration hash to seconds
        def self.duration_to_seconds(dur)
          mult = case dur[:unit]
                 when :s then 1
                 when :m then 60
                 when :h then 3600
                 when :d then 86400
                 when :w then 604800
                 else 1
                 end
          dur[:value] * mult
        end

        # Frequency filters
        opts.on("--rare", "Commands used < 3 times") { options[:rare] = true }
        opts.on("--frequent", "Commands used > 10 times") { options[:frequent] = true }
        opts.on("--unique", "Remove duplicate commands (show only first occurrence)") { options[:unique] = true }

        # Context filters
        opts.on("--shell SHELL", "Commands from specific shell") { |shell| options[:shell] = shell }
        opts.on("--tty TTY", "Commands from specific TTY device") { |tty| options[:tty] = tty }

        # Argument filters
        opts.on("--with-args", "Commands that had arguments") { options[:with_args] = true }
        opts.on("--no-args", "Commands without arguments") { options[:no_args] = true }
        opts.on("--arg-count N", Integer, "Commands with exactly N arguments") { |n| options[:arg_count] = n }

        # Private command filters
        opts.on("--private", "Show only private commands (started with space)") { options[:private] = true }
        opts.on("--no-private", "Explicitly exclude private commands") { options[:no_private] = true }

        # Imported filters
        opts.on("--imported", "Show only imported commands (no session)") { options[:imported] = true }
        opts.on("--no-imported", "Exclude imported commands (require a session)") { options[:no_imported] = true }

        # Environment filters
        opts.on("--assisted", "Only show AI-assisted commands") { options[:assisted] = true }
        opts.on("--no-assisted", "Exclude AI-assisted commands") { options[:no_assisted] = true }

        # Output format
        opts.on("--json", "Output as JSON with full metadata") { options[:format] = 'json' }
        opts.on("--yaml", "Output as YAML with full metadata") { options[:format] = 'yaml' }
        opts.on("--plain", "Output only commands, one per line") { options[:format] = 'plain' }
        opts.on("--format FORMAT", "Output format (json, yaml, fish, zsh, nu, bash, powershell, plain)") { |f|
          options[:format] = f.downcase
        }
        opts.on("--limit N", Integer,
                "Limit number of results (default: no limit). Negative N returns the first (earliest) N results (e.g. --limit -4 returns the first 4 commands today).") { |n|
          options[:limit] = n
        }

        opts.on("--no-session", "Only commands with undefined/null session_id") { options[:no_session] = true }
        opts.on("--no-start-time", "Only commands with undefined/null start_time") { options[:no_start_time] = true }
        opts.on("--no-exit-code", "Only commands with undefined/null exit_code") { options[:no_exit_code] = true }
        opts.on("--no-duration", "Only commands with undefined/null duration") { options[:no_duration] = true }

        opts.on("-h", "--help", "Show this help") do
          puts opts
          exit 0
        end
      end.parse!(args)

      # Get search term from remaining arguments
      options[:search_term] = args.join(' ') unless args.empty?

      # Build SQL query based on options
      execute_interactive_query(options)
    end

    def execute_interactive_query(options)
      # Read-only queries should not create or mutate the database.
      db_path = Histlog::DB.path
      unless File.exist?(db_path)
        STDERR.puts "No histlog.db found in current directory"
        return
      end

      # Open the existing database for read-only queries
      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true
      begin
        # If user asked for unique command list, run that and return early
        if options[:command_list]
          cmd_where = []
          cmd_params = []
          if options[:fuzzy] && options[:command_pattern]
            cmd_where << "cmd.command LIKE ?"
            cmd_params << Histlog::Utils.fuzzy_like_pattern(options[:command_pattern])
          elsif options[:command_pattern]
            cmd_where << "cmd.command LIKE ?"
            cmd_params << "%#{options[:command_pattern]}%"
          end

          where_clause = cmd_where.any? ? "WHERE " + cmd_where.join(" AND ") : ""
          q = <<-SQL
            SELECT cmd.command AS command_text, COUNT(*) AS usage_count
            FROM commands c
            LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
            #{where_clause}
            GROUP BY cmd.command
            ORDER BY usage_count DESC, command_text ASC
            LIMIT 1000
          SQL

          begin
            rows = db.execute(q, cmd_params)
            if rows.empty?
              puts "No commands found."
            else
              rows.each do |r|
                puts "%6d  %s" % [r['usage_count'] || 0, r['command_text'] || '']
              end
            end
          rescue SQLite3::Exception => e
            STDERR.puts "Database error: #{e.message}"
          ensure
            db.close if db
          end
          return
        end

        # Build the base query
        params = []

        # Base SELECT with joins
        base_query = <<-SQL
        SELECT
          c.id AS command_id,
          COALESCE(cmd.command, '') AS cmd_text,
          c.created_at,
          c.start_time,
          c.duration,
          c.exit_code,
          c.is_private,
          c.is_assisted,
          p_old.path as cwd_old,
          p_new.path as cwd_new,
          s.id as session_id,
          s.pid,
          s.parent_pid as session_parent_pid,
          s.timezone as session_timezone,
          s.start_time as session_start_time,
          sh.path as shell_path,
          t.device as tty_device,
          p_s.path as session_cwd
      FROM commands c
      LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
          LEFT JOIN sessions s ON c.session_id = s.id
          LEFT JOIN shells sh ON s.shell_id = sh.id
          LEFT JOIN ttys t ON s.tty_id = t.id
          LEFT JOIN paths p_old ON c.path_old_id = p_old.id
          LEFT JOIN paths p_new ON c.path_new_id = p_new.id
          LEFT JOIN paths p_s ON s.path_id = p_s.id
        SQL

        # Add WHERE conditions based on options
        where_conditions = []

        # Null field filters
        if options[:no_session]
          where_conditions << "c.session_id IS NULL"
        end
        if options[:no_start_time]
          where_conditions << "c.start_time IS NULL"
        end
        if options[:no_exit_code]
          where_conditions << "c.exit_code IS NULL"
        end
        if options[:no_duration]
          where_conditions << "c.duration IS NULL"
        end

        # Search term filter (optional) or explicit --command filtering
        cmd_pattern = options[:command_pattern] || options[:search_term]
        if options[:command_list]
          # Special mode: list unique commands. We'll run a separate query below.
        else
          if options[:regex] && cmd_pattern && !cmd_pattern.empty?
            where_conditions << "cmd.command REGEXP ?"
            params << cmd_pattern
          elsif cmd_pattern && !cmd_pattern.empty?
            if options[:fuzzy]
              where_conditions << "cmd.command LIKE ?"
              params << Histlog::Utils.fuzzy_like_pattern(cmd_pattern)
            else
              where_conditions << "cmd.command LIKE ?"
              params << "%#{cmd_pattern}%"
            end
          end
        end

        # Session filter
        if options[:session]
          if options[:session_id]
            where_conditions << "s.id = ?"
            params << options[:session_id]
          else
            # If --session is used with no ID, try to use $__histlog_session_id from the environment.
            env_session_id = ENV['__histlog_session_id']&.to_i
            if env_session_id && env_session_id > 0
              where_conditions << "s.id = ?"
              params << env_session_id
            else
              STDERR.puts "Error: --session used without argument and __histlog_session_id environment variable is not set"
              STDERR.puts "Either provide a session ID: --session 123"
              STDERR.puts "Or set the environment variable: export __histlog_session_id=123"
              exit 1
            end
          end
        end

        # Directory filter
        if options[:dir]
          dir_path = options[:dir_path] || Dir.pwd
          abs_dir = File.expand_path(dir_path)
          where_conditions << "p_old.path = ?"
          params << abs_dir
        end

        # Status filters
        if options[:failed]
          where_conditions << "c.exit_code != 0"
        elsif options[:success]
          where_conditions << "c.exit_code = 0"
        elsif options[:exit_code]
          where_conditions << "c.exit_code = ?"
          params << options[:exit_code]
        end

        # Private command filters
        if options[:private]
          where_conditions << "c.is_private = 1"
        elsif options[:no_private]
          where_conditions << "c.is_private = 0"
          # Default: show private commands unless explicitly excluded
        end

        # AI-assisted command filters
        if options[:assisted]
          where_conditions << "c.is_assisted = 1"
        elsif options[:no_assisted]
          where_conditions << "c.is_assisted != 1"
          # Default: show all commands regardless of AI assistance unless explicitly filtered
        end

        # Imported / non-imported filtering
        if options[:imported]
          # Imported commands have no session ID
          where_conditions << "c.session_id IS NULL"
        elsif options[:no_imported]
          # Only show commands that belong to sessions
          where_conditions << "c.session_id IS NOT NULL"
        end

        # Unified time filter
        if options[:time]
          # Parse --time argument into start/end unix timestamps (support all formats)
          tstart, tend = Histlog::Utils.parse_time_flag(options[:time])
          if tstart && tend
            where_conditions << "c.start_time >= ? AND c.start_time <= ?"
            params << tstart << tend
          elsif tstart
            where_conditions << "c.start_time >= ?"
            params << tstart
          elsif tend
            where_conditions << "c.start_time <= ?"
            params << tend
          end
        end

        # Performance filters (duration-based)
        if options[:duration]
          dur = options[:duration]
          case dur[:type]
          when :lt
            where_conditions << "c.duration < #{Histlog::Utils.duration_to_seconds(dur)}"
          when :gt
            where_conditions << "c.duration > #{Histlog::Utils.duration_to_seconds(dur)}"
          when :lte
            where_conditions << "c.duration <= #{Histlog::Utils.duration_to_seconds(dur)}"
          when :gte
            where_conditions << "c.duration >= #{Histlog::Utils.duration_to_seconds(dur)}"
          when :range
            min = Histlog::Utils.duration_to_seconds(dur[:min])
            max = Histlog::Utils.duration_to_seconds(dur[:max])
            where_conditions << "c.duration >= #{min} AND c.duration <= #{max}"
          when :approx
            val = Histlog::Utils.duration_to_seconds(dur)
            tol = dur[:tol] || 0.1
            min = val * (1 - tol)
            max = val * (1 + tol)
            where_conditions << "c.duration >= #{min} AND c.duration <= #{max}"
          end
        end

        # Path-related filters
        if options[:has_paths]
          base_query += " JOIN path_args a ON c.id = a.command_id"
          where_conditions << "a.path_id IS NOT NULL"
        end

        if options[:path]
          base_query += " JOIN path_args a ON c.id = a.command_id JOIN paths p_arg ON a.path_id = p_arg.id"
          where_conditions << "p_arg.path LIKE ?"
          params << "%#{options[:path]}%"
        end

        # Argument count filters
        if options[:with_args]
          # Select commands with at least one argument (not just path_args)
          where_conditions << "(LENGTH(TRIM(cmd.command)) - LENGTH(REPLACE(TRIM(cmd.command), ' ', ''))) > 0"
        elsif options[:no_args]
          # Select commands with no arguments (not just no path_args)
          where_conditions << "(LENGTH(TRIM(cmd.command)) - LENGTH(REPLACE(TRIM(cmd.command), ' ', ''))) = 0"
        elsif options[:arg_count]
          # Select commands with exactly N arguments (argument count = number of spaces)
          where_conditions << "(LENGTH(TRIM(cmd.command)) - LENGTH(REPLACE(TRIM(cmd.command), ' ', ''))) = ?"
          params << options[:arg_count]
        end

        # Frequency filters require subqueries
        if options[:rare] || options[:frequent]
          frequency_subquery = <<-SQL
    (SELECT COUNT(*) FROM commands c2 WHERE c2.cmd_text_id = c.cmd_text_id)
          SQL

          if options[:rare]
            where_conditions << "#{frequency_subquery} < 3"
          elsif options[:frequent]
            where_conditions << "#{frequency_subquery} > 10"
          end
        end

        # Unique filter - show only first occurrence of each command (deduplication)
        if options[:unique]
          where_conditions << "c.id = (SELECT MIN(c2.id) FROM commands c2 WHERE c2.cmd_text_id = c.cmd_text_id)"
        end

        # Combine query parts
        full_query = base_query
        if where_conditions.any?
          full_query += " WHERE " + where_conditions.join(" AND ")
        end

        # Add GROUP BY to handle potential duplicates from JOINs, but preserve individual command executions
        full_query += " GROUP BY c.id"

        # Order by start_time (actual execution time), then created_at, then command_id for strict chronological order
        # For limited results, we need to get the most recent N commands first, then apply user's sort preference
        if options[:limit]
          # If limit is negative, user asked for the earliest N results (first N)
          if options[:limit] < 0
            full_query += " ORDER BY c.start_time ASC, c.created_at ASC, c.id ASC"
          else
            # Always get the most recent N commands first
            full_query += " ORDER BY c.start_time DESC, c.created_at DESC, c.id DESC"
          end
        else
          # For unlimited results, apply user's sort preference directly (default: oldest first - chronological)
          if options[:desc]
            order = "DESC"
          else
            order = "ASC" # Default behavior - chronological order
          end
          full_query += " ORDER BY c.start_time #{order}, c.created_at #{order}, c.id #{order}"
        end

        # We'll handle LIMIT at execution time to account for any rows filtered out in Ruby
        # (for example, excluding currently-running commands where duration IS NULL).
        # Do not append a SQL LIMIT here; instead we'll iteratively fetch enough rows below.

        # Execute query. If a limit was requested, do an iterative fetch that
        # over-requests rows (exponential backoff) until we have enough non-running
        # rows or there are no more rows to fetch. This avoids returning fewer
        # results than the requested limit when some rows are filtered out in Ruby.
        begin
          if options[:limit]
            raw_limit = options[:limit]
            # Negative limit now means: return the first (earliest) N results.
            # Use absolute value for requested count; start at offset 0.
            requested = raw_limit < 0 ? raw_limit.abs : raw_limit
            start_offset = 0
            current_limit = [requested * 2, 50].max
            max_limit = 5000
            results = []
            offset = start_offset

            loop do
              # Build limited query for this iteration
              limited_query = full_query + " LIMIT #{current_limit} OFFSET #{offset}"
              all_results = db.execute(limited_query, params)

              # Filter out running commands (duration nil)
              # Only exclude currently-running commands (they have a session and nil duration).
              # Keep imported commands (session_id IS NULL) even if duration is nil.
              filtered = all_results.reject { |row| row['duration'].nil? && !row['session_id'].nil? }

              # Append unique new results
              results.concat(filtered)

              # If we have enough results, stop
              break if results.size >= requested

              # If fewer rows were returned than requested in SQL, no more data available
              break if all_results.size < current_limit

              # Otherwise, advance offset and increase limit to fetch more rows
              offset += current_limit
              current_limit = [current_limit * 2, max_limit].min
              # If we've reached the max_limit, avoid infinite loop
              break if current_limit >= max_limit
            end

            # Truncate to requested size
            results = results.take(requested)
            # When we fetched limited results we used ORDER BY DESC to pick the most recent set.
            # Ensure display order is chronological (oldest -> newest) unless the user explicitly
            # requested descending output with --desc. Use explicit sort by start_time to be robust.
            unless options[:desc]
              results = results.sort_by { |r| r['start_time'] || 0 }
            end
          else
            all_results = db.execute(full_query, params)
            results = all_results.reject do |row|
              # Exclude only currently-running commands: duration nil AND belong to a session.
              row['duration'].nil? && !row['session_id'].nil?
            end
          end
        rescue SQLite3::SQLException => e
          # Fallback: if REGEXP is not supported, filter in Ruby
          if options[:regex] && options[:search_term] && e.message =~ /no such function: REGEXP/
            results = db.execute(full_query.sub(/cmd\.command REGEXP \?/, '1'), params[0..-2]) # get all
            begin
              re = Regexp.new(options[:search_term])
              results = results.select { |row| row['cmd_text'] =~ re }
            rescue RegexpError => re_err
              STDERR.puts "Invalid regex: #{re_err.message}"
              results = []
            end
          else
            raise e
          end
        end

        # Handle delete options
        if options[:delete] || options[:force_delete]
          if results.empty?
            puts "No matching commands to delete."
            db.close
            return
          end
          # List matching commands
          puts "Matching commands to delete:"
          results.each do |row|
            puts "  [ID: #{row['command_id']}] #{row['cmd_text']}"
          end
          if options[:delete]
            print "Are you sure you want to delete these commands? Type 'yes' to confirm: "
            confirm = STDIN.gets.strip
            unless confirm.downcase == 'yes'
              puts "Aborted. No commands deleted."
              db.close
              return
            end
          end
          # Delete matching commands
          ids = results.map { |row| row['command_id'] }
          ids.each do |id|
            db.execute("DELETE FROM commands WHERE id = ?", [id])
            db.execute("DELETE FROM path_args WHERE command_id = ?", [id])
          end
          puts "Deleted #{ids.size} commands."

          # Cleanup orphaned entries after deletion
          Histlog::DB.cleanup_orphaned_entries(db)
          db.close
          return
        end

        # Output results
        if options[:format]
          Histlog::Reporting.output_formatted_results(results, options)
        else
          Histlog::Reporting.output_interactive_results(results, options)
        end
      rescue SQLite3::Exception => e
        STDERR.puts "Database error: #{e.message}"
      ensure
        db.close if db
      end
    end
  end

  # Import module for handling shell history imports
  module Import
    module_function

    def import_shell_history(args)
      options = {
        file_path: nil,
        format: nil,
        verbose: false,
        dry_run: false,
        time_tolerance: 2.0,
        session_id: nil
      }

      parser = OptionParser.new do |opts|
        opts.banner = "Usage: histlog import [options]"
        opts.on("-f", "--file FILE", "History file path (defaults to shell's default)") do |f|
          options[:file_path] = f
        end
        opts.on("--format FORMAT",
                "Specify shell history format (json, yaml, fish, zsh, nu, bash, powershell, plain)") do |t|
          options[:format] = t.downcase
        end
        opts.on("--json", "Import from JSON file") do
          options[:format] = 'json'
        end
        opts.on("--yaml", "Import from YAML file") do
          options[:format] = 'yaml'
        end
        opts.on("-v", "--verbose", "Run verbosely") do
          options[:verbose] = true
        end
        opts.on("-n", "--dry-run", "Parse and show commands without importing") do
          options[:dry_run] = true
        end
        opts.on("--time-tolerance SECONDS", Float, "Deduplication time window in seconds (default: 2.0)") do |t|
          options[:time_tolerance] = t
        end
        # --session can be given with a numeric argument to specify session ID for import.
        # If the flag is not provided, session_id will be null (imported commands).
        # Note: __histlog_session_id environment variable is never used for imports.
        opts.on("--session [N]", Integer, "Specify session ID for import (optional)") do |n|
          options[:session_id] = n
        end
        opts.on_tail("-h", "--help", "Show this message") do
          puts opts
          return
        end
      end
      parser.parse!(args)

      # Session ID is optional for all import formats
      # It can be provided via --session flag or from session_id attribute in JSON/YAML files
      file_path = options[:file_path] || args.first

      if file_path.nil?
        # If user specified a format (shell) but no file, suggest the default history file for that shell
        if options[:format] && %w[zsh bash fish nu].include?(options[:format])
          candidate = Histlog::Config.default_history_for_shell(options[:format])
          if candidate && File.exist?(candidate)
            # Ask user whether to use the detected default file
            print "No file specified. Use default history file for #{options[:format]}: #{candidate}? [Y/n] "
            answer = STDIN.gets
            if answer.nil?
              STDERR.puts "No input received. Aborting."
              return
            end
            unless answer.strip.empty? || answer.strip.downcase.start_with?("y")
              STDERR.puts "Aborted. Please specify --file PATH to import from a specific file."
              return
            end
            file_path = candidate
            puts "Using #{file_path}"
          else
            STDERR.puts "No file specified and default history file not found for #{options[:format]} (#{candidate}). Please specify --file."
            return
          end
        else
          # If no file is provided, try to auto-detect based on current shell or common locations
          shell, history_file = detect_shell_and_history_file
          if history_file
            file_path = history_file
            options[:format] ||= shell
            puts "Auto-detected history file: #{file_path} (type: #{options[:format]})"
          else
            STDERR.puts "Error: No history file specified and could not auto-detect one."
            STDERR.puts parser
            return
          end
        end
      end

      unless File.exist?(file_path)
        STDERR.puts "Error: File not found: #{file_path}"
        return
      end

      # Determine file type if not specified
      options[:format] ||= detect_shell_from_history_file(file_path)

      if options[:format].nil?
        STDERR.puts "Error: Could not determine shell history format. Please specify with --format."
        return
      end

      commands = []
      case options[:format]
      when 'json'
        commands = parse_json_history_file(file_path, options[:verbose])
      when 'yaml'
        commands = parse_yaml_history_file(file_path, options[:verbose])
      else
        commands = parse_history_file(file_path, options[:format], options[:verbose])
      end

      if commands.empty?
        puts "No commands found to import."
        return
      end

      if options[:dry_run]
        puts "Dry run: #{commands.length} commands parsed. Not importing."
        if options[:verbose]
          commands.first(10).each do |c|
            puts "  - #{c[:command]}"
          end
        end
        return
      end

      puts "Importing #{commands.length} commands..."
      imported_count, skipped_count, updated_count = Histlog::DB.import_commands_to_db(commands, options)
      puts "Import summary: Imported #{imported_count} commands; Skipped #{skipped_count} already-present; Updated #{updated_count} cleared exit_codes."
    end

    # Parse JSON history file
    def parse_json_history_file(file_path, verbose = false)
      puts "Parsing JSON file: #{file_path}" if verbose

      begin
        json_data = JSON.parse(File.read(file_path))

        unless json_data.is_a?(Hash) && json_data.key?('commands') && json_data.key?('sessions')
          STDERR.puts "Error: JSON history must be an object with top-level 'sessions' and 'commands' arrays"
          return []
        end

        sessions_by_orig = {}
        if json_data['sessions'].is_a?(Array)
          json_data['sessions'].each do |s|
            orig_id = s['session_id'] || s['id']
            sessions_by_orig[orig_id] = s if orig_id
          end
        end

        commands = json_data['commands'].map.with_index do |entry, index|
          # Map incoming ids to internal original id fields
          original_command_id = entry['id'] || entry['command_id']
          original_session_id = entry['session_id'] || entry['session']

          # Normalize start_time: accept numeric epoch or ISO timestamp strings
          raw_start = entry['start_time']
          start_epoch = nil
          if raw_start
            if raw_start.is_a?(Numeric)
              start_epoch = raw_start.to_f
            elsif raw_start.is_a?(String)
              begin
                # If timestamp matches 'YYYY-MM-DD HH:MM:SS' with no timezone, parse as UTC
                if raw_start =~ /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/
                  start_epoch = Time.strptime(raw_start, '%Y-%m-%d %H:%M:%S').utc.to_f
                else
                  # Try to parse ISO-like timestamp (Time.parse may use system tz)
                  start_epoch = Time.parse(raw_start).to_f
                end
              rescue
                # Fallback: try to_f (may return 0 for non-numeric strings)
                start_epoch = raw_start.to_f
              end
            end
          end

          # Build session metadata: prefer top-level sessions mapping
          session_meta = nil
          if original_session_id && sessions_by_orig[original_session_id]
            s = sessions_by_orig[original_session_id]
            raw_start = s['start_time']
            start_epoch = nil
            if raw_start
              if raw_start.is_a?(Numeric)
                start_epoch = raw_start.to_f
              elsif raw_start.is_a?(String) && raw_start =~ /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/
                start_epoch = Time.strptime(raw_start, '%Y-%m-%d %H:%M:%S').utc.to_f
              else
                start_epoch = (begin; Time.parse(raw_start).to_f rescue raw_start.to_f end)
              end
            end
            session_meta = {
              shell: s['shell'],
              tty: s['tty'],
              pid: s['pid'],
              parent_pid: s['parent_pid'],
              cwd: s['cwd'],
              timezone: s['timezone'],
              start_time: start_epoch
            }.reject { |_, v| v.nil? }
          elsif entry['session'] && entry['session'].is_a?(Hash)
            # Fallback per-entry session object if present
            s = entry['session']
            raw_start = s['start_time']
            start_epoch = nil
            if raw_start
              start_epoch = raw_start.is_a?(Numeric) ? raw_start.to_f : (begin;
                Time.parse(raw_start).to_f rescue raw_start.to_f
              end)
            end
            session_meta = {
              shell: s['shell'],
              tty: s['tty'],
              pid: s['pid'],
              parent_pid: s['parent_pid'],
              cwd: s['cwd'],
              timezone: s['timezone'],
              start_time: start_epoch
            }.reject { |_, v| v.nil? }
          end

          # Extract path_args if present (keep type as 'f'/'d' to match DB conventions)
          path_args = nil
          if entry['path_args'].is_a?(Array)
            path_args = entry['path_args'].map do |pa|
              {
                position: pa['position'],
                path: pa['path'],
                type: (pa['type'] == 'file' ? 'f' : (pa['type'] == 'dir' ? 'd' : pa['type']))
              }
            end
          end

          {
            command: entry['cmd_text'] || entry['command'],
            start_time: start_epoch,
            exit_code: entry['exit_code'],
            duration: entry['duration'],
            is_private: entry['is_private'],
            session: session_meta, # richer session metadata for creating DB sessions
            pid: entry['pid'],
            shell: entry['shell'],
            tty: entry['tty'],
            cwd_old: entry['cwd_old'],
            cwd_new: entry['cwd_new'],
            path_args: path_args,
            is_assisted: entry['is_assisted'],
            # Keep original IDs for importer mapping
            _original_command_id: original_command_id,
            _original_session_id: original_session_id
          }
        end

        puts "Parsed #{commands.length} JSON entries (new sessions/commands format)" if verbose
        commands
      rescue JSON::ParserError => e
        STDERR.puts "Error parsing JSON file: #{e.message}"
        []
      rescue => e
        STDERR.puts "Error reading JSON file: #{e.message}"
        []
      end
    end

    # Parse YAML history file
    def parse_yaml_history_file(file_path, verbose = false)
      puts "Parsing YAML file: #{file_path}" if verbose

      begin
        require 'yaml'
        yaml_data = YAML.load_file(file_path)

        unless yaml_data.is_a?(Hash) && yaml_data.key?('commands') && yaml_data.key?('sessions')
          STDERR.puts "Error: YAML history must be an object with top-level 'sessions' and 'commands' arrays"
          return []
        end

        sessions_by_orig = {}
        if yaml_data['sessions'].is_a?(Array)
          yaml_data['sessions'].each do |s|
            orig_id = s['session_id'] || s['id']
            sessions_by_orig[orig_id] = s if orig_id
          end
        end

        commands = yaml_data['commands'].map.with_index do |entry, index|
          # Map incoming ids to internal original id fields
          original_command_id = entry['id'] || entry['command_id']
          original_session_id = entry['session_id'] || entry['session']

          # Normalize start_time
          raw_start = entry['start_time']
          start_epoch = nil
          if raw_start
            if raw_start.is_a?(Numeric)
              start_epoch = raw_start.to_f
            elsif raw_start.is_a?(String)
              begin
                start_epoch = Time.parse(raw_start).to_f
              rescue
                start_epoch = raw_start.to_f
              end
            end
          end

          # Build session metadata from top-level sessions mapping if present
          session_meta = nil
          if original_session_id && sessions_by_orig[original_session_id]
            s = sessions_by_orig[original_session_id]
            raw_start = s['start_time']
            start_epoch = nil
            if raw_start
              start_epoch = raw_start.is_a?(Numeric) ? raw_start.to_f : (begin;
                Time.parse(raw_start).to_f rescue raw_start.to_f
              end)
            end
            session_meta = {
              shell: s['shell'],
              tty: s['tty'],
              pid: s['pid'],
              parent_pid: s['parent_pid'],
              cwd: s['cwd'],
              timezone: s['timezone'],
              start_time: start_epoch
            }.reject { |_, v| v.nil? }
          elsif entry['session'] && entry['session'].is_a?(Hash)
            s = entry['session']
            raw_start = s['start_time']
            start_epoch = nil
            if raw_start
              start_epoch = raw_start.is_a?(Numeric) ? raw_start.to_f : (begin;
                Time.parse(raw_start).to_f rescue raw_start.to_f
              end)
            end
            session_meta = {
              shell: s['shell'],
              tty: s['tty'],
              pid: s['pid'],
              parent_pid: s['parent_pid'],
              cwd: s['cwd'],
              timezone: s['timezone'],
              start_time: start_epoch
            }.reject { |_, v| v.nil? }
          end

          path_args = nil
          if entry['path_args'].is_a?(Array)
            path_args = entry['path_args'].map do |pa|
              {
                position: pa['position'],
                path: pa['path'],
                type: (pa['type'] == 'file' ? 'f' : (pa['type'] == 'dir' ? 'd' : pa['type']))
              }
            end
          end

          # Only extract command data, include richer metadata
          {
            command: entry['cmd_text'] || entry['command'],
            start_time: start_epoch,
            exit_code: entry['exit_code'],
            duration: entry['duration'],
            is_private: entry['is_private'],
            session: session_meta,
            pid: entry['pid'],
            shell: entry['shell'],
            tty: entry['tty'],
            cwd_old: entry['cwd_old'],
            cwd_new: entry['cwd_new'],
            path_args: path_args,
            is_assisted: entry['is_assisted'],
            # Keep original IDs for importer mapping
            _original_command_id: original_command_id,
            _original_session_id: original_session_id
          }
        end

        puts "Parsed #{commands.length} YAML entries (new sessions/commands format)" if verbose
        commands
      rescue Psych::SyntaxError => e
        STDERR.puts "Error parsing YAML file: #{e.message}"
        []
      rescue => e
        STDERR.puts "Error reading YAML file: #{e.message}"
        []
      end
    end

    # Detect current shell and default history file location
    def detect_shell_and_history_file
      # Try to detect from environment
      shell_path = ENV['SHELL'] || ''
      shell_name = File.basename(shell_path)

      # Get home directory
      home = Dir.home

      case shell_name
      when 'fish'
        history_file = File.join(home, '.local/share/fish/fish_history')
        return ['fish', history_file] if File.exist?(history_file)
      when 'zsh'
        # Try common zsh history locations
        candidates = [
          File.join(home, '.zsh_history'),
          File.join(home, '.zhistory'),
          ENV['HISTFILE']
        ].compact
        candidates.each do |file|
          return ['zsh', file] if File.exist?(file)
        end
      when 'bash'
        bash_file = File.join(home, '.bash_history')
        return ['bash', bash_file] if File.exist?(bash_file)
      when 'nu', 'nushell'
        # Nushell history location (may vary by version/config)
        nu_config_dir = ENV['XDG_CONFIG_HOME'] || File.join(home, '.config')
        history_file = File.join(nu_config_dir, 'nushell/history.txt')
        return ['nu', history_file] if File.exist?(history_file)

        # Alternative location
        history_file = File.join(home, '.config/nushell/history.txt')
        return ['nu', history_file] if File.exist?(history_file)
      end

      # Fallback: try to detect by checking for common history files
      [
        ['fish', File.join(home, '.local/share/fish/fish_history')],
        ['zsh', File.join(home, '.zsh_history')],
        ['bash', File.join(home, '.bash_history')],
        ['nu', File.join(home, '.config/nushell/history.txt')]
      ].each do |shell, file|
        return [shell, file] if File.exist?(file)
      end

      [nil, nil]
    end

    # Detect shell format from a given history file path and content
    # Returns 'fish', 'zsh', 'nu' or nil if unknown
    def detect_shell_from_history_file(file_path)
      return nil unless file_path && File.exist?(file_path)

      begin
        basename = File.basename(file_path)
        fullpath = file_path
        lower = fullpath.downcase

        # Path-based hints first
        return 'fish' if basename == 'fish_history' || lower.include?('/fish/fish_history')
        return 'zsh' if basename == '.zsh_history' || basename == '.zhistory' || lower.include?('/zsh')
        return 'nu' if lower.include?('/nushell/history') || (basename == 'history.txt' && lower.include?('/nushell/'))
        return 'json' if lower.end_with?('.json')
        return 'yaml' if lower.end_with?('.yaml') || lower.end_with?('.yml')

        # Content-based heuristics
        sample_lines = []
        File.open(file_path, 'r') do |f|
          2000.times do
            line = f.gets
            break unless line

            line = line.chomp
            next if line.strip.empty?

            sample_lines << line
            break if sample_lines.size >= 200 # cap
          end
        end

        # Fish YAML-like entries start with "- cmd: " and have indented keys like "  when:"
        if sample_lines.any? { |l| l.start_with?('- cmd: ') } || sample_lines.any? { |l|
          l.strip.start_with?('when:') || l.start_with?('  when: ')
        }
          return 'fish'
        end

        # Zsh extended history lines typically start with ": <epoch>:" or ": <epoch>;"
        if sample_lines.any? { |l| l.start_with?(': ') && (l.match(/^: \d+:\d+;/) || l.match(/^: \d+;/)) }
          return 'zsh'
        end

        # Nushell is plain lines; if path hints didn't match, and lines don't match fish/zsh, guess 'nu'
        return 'nu'
      rescue
        # On any error, fall back to nil
        nil
      end
    end

    # Parse history file based on shell format
    # If shell_type is nil or 'auto', attempt to auto-detect based on file path and content
    def parse_history_file(file_path, shell_type, verbose = false)
      # Autodetect if not provided
      if shell_type.nil? || shell_type.to_s.strip.downcase == 'auto'
        detected = detect_shell_from_history_file(file_path)
        if detected
          shell_type = detected
        else
          STDERR.puts "Error: Could not auto-detect shell history format for: #{file_path}"
          STDERR.puts "Hint: specify --shell fish|zsh|nu"
          return []
        end
      end

      commands = []

      puts "Parsing #{shell_type} history..." if verbose

      case shell_type
      when 'fish'
        commands = parse_fish_history(file_path, verbose)
      when 'zsh'
        commands = parse_zsh_history(file_path, verbose)
      when 'nu', 'nushell', 'nu-shell'
        commands = parse_nu_history(file_path, verbose)
      when 'bash'
        commands = parse_bash_history(file_path, verbose)
      else
        STDERR.puts "Error: Unsupported shell type: #{shell_type}"
        return []
      end

      commands
    end

    # Parse Fish shell history format
    def parse_fish_history(file_path, verbose = false)
      commands = []
      current_command = nil

      File.readlines(file_path).each_with_index do |line, line_num|
        line = line.chomp

        if line.start_with?('- cmd: ')
          # Save previous command if exists
          commands << current_command if current_command && current_command[:command]

          # Start new command
          command_text = line[7..-1] # Remove '- cmd: ' prefix
          current_command = {
            command: command_text,
            start_time: nil
          }
        elsif line.start_with?('  when: ') && current_command
          # Parse timestamp
          timestamp_str = line[8..-1] # Remove '  when: ' prefix
          begin
            current_command[:start_time] = timestamp_str.to_i
          rescue
            # Ignore invalid timestamps
          end
        elsif line.start_with?('  paths:') && current_command
          # Fish stores paths used by the command, but we intentionally ignore them
          # Reason: Fish paths are raw/relative arguments, but path tracking requires absolute paths
          # Path tracking is only available for live commands, not imported history
          next
        elsif line.start_with?('    - ') && current_command
          # Skip individual path entries in fish paths section
          next
        end

        puts "Processed line #{line_num + 1}" if verbose && (line_num + 1) % 1000 == 0
      end

      # Add last command
      commands << current_command if current_command && current_command[:command]

      commands
    end

    # Parse Zsh history format
    def parse_zsh_history(file_path, verbose = false)
      commands = []

      File.readlines(file_path).each_with_index do |line, line_num|
        line = line.chomp

        if line.match(/^: (\d+):\d+;(.*)$/)
          # Extended history format: ": timestamp:duration;command"
          start_time = $1.to_i
          command = $2
          commands << { command: command, start_time: start_time }
        elsif line.match(/^: (\d+);\s*(.*)$/)
          # Simple extended format: ": timestamp;command"
          start_time = $1.to_i
          command = $2
          commands << { command: command, start_time: start_time }
        elsif !line.start_with?(':')
          # Simple format: just the command
          commands << { command: line, start_time: nil }
        end

        puts "Processed line #{line_num + 1}" if verbose && (line_num + 1) % 1000 == 0
      end

      commands
    end

    # Parse Nushell history format
    def parse_nu_history(file_path, verbose = false)
      commands = []

      # Nushell history is typically plain text, one command per line
      File.readlines(file_path).each_with_index do |line, line_num|
        line = line.chomp.strip
        next if line.empty?

        commands << { command: line, start_time: nil }
        puts "Processed line #{line_num + 1}" if verbose && (line_num + 1) % 1000 == 0
      end

      commands
    end

    # Parse Bash history file (one command per line)
    def parse_bash_history(file_path, verbose = false)
      commands = []
      File.readlines(file_path).each_with_index do |line, i|
        next if line.nil?

        txt = line.chomp
        next if txt.strip.empty?

        commands << { command: txt, start_time: nil }
        puts "Processed line #{i + 1}" if verbose && (i + 1) % 1000 == 0
      end
      commands
    end

    # Import parsed commands into the database
    def import_commands_to_db(commands, options)
      db = Histlog::DB.initialize_db
      db.results_as_hash = true
      imported_count = 0
      skipped_count = 0
      updated_count = 0
      # No input command ID support; only track session original ids if provided
      # session_id_lookup removed: we don't keep original session id mappings
      tolerance = options[:time_tolerance] || 2.0

      # Preload all existing commands from DB for deduplication
      # Only load imported commands (session_id IS NULL)
      db_commands = db.execute("SELECT id, cmd_text_id, start_time FROM commands WHERE session_id IS NULL")
      # Build lookup: { cmd_text_id => [ {id, start_time} ] }
      db_lookup = Hash.new { |h, k| h[k] = [] }
      db_commands.each do |row|
        db_lookup[row['cmd_text_id']] << { id: row['id'], start_time: row['start_time'] }
      end

      commands.each_with_index do |cmd_data, index|
        begin
          next if cmd_data[:command].nil? || cmd_data[:command].strip.empty?

          original_command = cmd_data[:command]
          is_private = original_command.start_with?(' ') ? 1 : 0
          clean_command = original_command.lstrip
          cmd_text_id = Histlog::DB.get_or_create_cmd_text_id(db, clean_command)

          # Deduplication logic
          is_duplicate = false
          if cmd_data[:start_time]
            # Compare to all DB entries with same cmd_text_id and start_time within ±tolerance
            db_lookup[cmd_text_id].each do |row|
              next unless row[:start_time]

              if (cmd_data[:start_time].to_f - row[:start_time].to_f).abs <= tolerance
                is_duplicate = row[:id]
                break
              end
            end
          else
            # No start_time: deduplicate only by command text
            db_lookup[cmd_text_id].each do |row|
              is_duplicate = row[:id] if row[:start_time].nil?
              break if is_duplicate
            end
          end

          if is_duplicate
            # If incoming data doesn't include exit_code, and DB has one, clear it
            if cmd_data[:exit_code].nil?
              begin
                existing_exit = db.get_first_value("SELECT exit_code FROM commands WHERE id = ?", [is_duplicate])
                if !existing_exit.nil?
                  db.execute("UPDATE commands SET exit_code = NULL WHERE id = ?", [is_duplicate])
                  updated_count += 1
                  puts "Updated existing command ##{is_duplicate}: cleared exit_code to NULL" if options[:verbose]
                end
              rescue SQLite3::Exception
              end
            end
            skipped_count += 1
            puts "Skipping duplicate command (already in DB, tolerance ±#{tolerance}s): #{clean_command}" if options[:verbose]
            next
          end

          # Determine final session id: CLI flag overrides, else create a session if full metadata provided,
          # else nil (we don't rely on original session_id from input)
          final_session_id = options[:session_id]
          if final_session_id.nil?
            if cmd_data[:session] && cmd_data[:session].is_a?(Hash) && !cmd_data[:session].empty?
              # Create a session row using DB helper and reuse the generated session id
              begin
                final_session_id = Histlog::DB.store_session(cmd_data[:session])
              rescue => e
                final_session_id = nil
              end
            else
              final_session_id = nil
            end
          end

          is_assisted = cmd_data[:is_assisted] ? 1 : 0
          exit_code_val = cmd_data.key?(:exit_code) ? cmd_data[:exit_code] : nil

          if cmd_data[:start_time]
            julian_day = (cmd_data[:start_time].to_f / 86400) + 2440587.5
            db.execute(
              "INSERT INTO commands (session_id, cmd_text_id, path_old_id, path_new_id, duration, exit_code, is_private, is_assisted, created_at, start_time) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
              [final_session_id, cmd_text_id, nil, nil, nil, exit_code_val, is_private, is_assisted, julian_day,
               cmd_data[:start_time].to_f]
            )
          else
            db.execute(
              "INSERT INTO commands (session_id, cmd_text_id, path_old_id, path_new_id, duration, exit_code, is_private, is_assisted, start_time) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
              [final_session_id, cmd_text_id, nil, nil, nil, exit_code_val, is_private, is_assisted, nil]
            )
          end
          new_command_id = db.last_insert_row_id
          # Add to db_lookup for future deduplication within this import batch
          db_lookup[cmd_text_id] << { id: new_command_id, start_time: cmd_data[:start_time] }
          imported_count += 1
          puts "Imported #{imported_count} commands..." if options[:verbose] && imported_count % 100 == 0
        rescue SQLite3::Exception => e
          STDERR.puts "Warning: Could not import command '#{cmd_data[:command]}': #{e.message}" if options[:verbose]
        end
      end
      # no original session id mappings to report
      db.close if db
      [imported_count, skipped_count, updated_count]
    end
  end
end

# Remove old function definitions - these are now in Histlog::Reporting and Histlog::Import

module Histlog
  # Output formatting and reporting module
  module Reporting
    module_function

    # Output results in various formats
    def output_formatted_results(results, options)
      format = options[:format]

      # Validate format
      valid_formats = ['json', 'yaml', 'fish', 'zsh', 'nu', 'bash', 'powershell', 'plain']
      unless valid_formats.include?(format)
        STDERR.puts "Error: Unsupported format '#{format}'"
        STDERR.puts "Supported formats: #{valid_formats.join(', ')}"
        exit 1
      end

      if results.empty?
        puts "No commands found matching the criteria."
        return
      end

      case format
      when 'json'
        output_json_results(results)
      when 'yaml'
        output_yaml_results(results)
      when 'plain'
        output_plain_results(results, options)
      else
        output_shell_history_results(results, format, options)
      end
    end

    # Output results in JSON format
    def output_json_results(results)
      db = build_reporting_db

      begin
        sessions = {}
        commands = []

        results.each do |row|
          # collect session metadata if present
          sid = row['session_id']
          if sid && !sessions.key?(sid)
            # Format session start_time as human-readable string
            s_start = row['session_start_time']
            formatted_start = nil
            if s_start
              begin
                formatted_start = Time.at(s_start.to_f).strftime('%Y-%m-%d %H:%M:%S')
              rescue
                formatted_start = s_start.to_s
              end
            end

            sessions[sid] = {
              id: sid,
              start_time: formatted_start,
              shell: row['shell_path'],
              tty: row['tty_device'],
              pid: row['pid'],
              parent_pid: row['session_parent_pid'],
              timezone: row['session_timezone'],
              cwd: row['session_cwd']
            }.reject { |_, v| v.nil? }
          end

          path_args = fetch_path_args(db, row['command_id'])
          cmd = structured_result(row, path_args)
          commands << cmd
        end

        out = {
          schema_version: 1,
          sessions: sessions.values,
          commands: commands
        }

        begin
          puts JSON.pretty_generate(out)
        rescue Errno::EPIPE
          exit 0
        end
      ensure
        db.close if db
      end
    end

    # Output results in YAML format
    def output_yaml_results(results)
      require 'yaml'

      db = build_reporting_db

      begin
        sessions = {}
        commands = []

        results.each do |row|
          sid = row['session_id']
          if sid && !sessions.key?(sid)
            s_start = row['session_start_time']
            formatted_start = nil
            if s_start
              begin
                formatted_start = Time.at(s_start.to_f).utc.strftime('%Y-%m-%d %H:%M:%S')
              rescue
                formatted_start = s_start.to_s
              end
            end

            sessions[sid] = {
              'id' => sid,
              'start_time' => formatted_start,
              'shell' => row['shell_path'],
              'tty' => row['tty_device'],
              'pid' => row['pid'],
              'parent_pid' => row['session_parent_pid'],
              'timezone' => row['session_timezone'],
              'cwd' => row['session_cwd']
            }.reject { |_, v| v.nil? }
          end

          path_args = fetch_path_args(db, row['command_id'])
          commands << structured_result_for_yaml(row, path_args)
        end

        out = {
          'schema_version' => 1,
          'sessions' => sessions.values,
          'commands' => commands
        }

        begin
          puts out.to_yaml
        rescue Errno::EPIPE
          exit 0
        end
      ensure
        db.close if db
      end
    end

    # Output results in plain format with timestamps
    def output_plain_results(results, options)
      begin
        results.each do |row|
          command = row['cmd_text']
          puts command
        end
      rescue Errno::EPIPE
        exit 0
      end
    end

    # Output results in shell history formats
    def output_shell_history_results(results, format, options)
      # Convert query results to the format expected by format_commands_for_shell
      formatted_results = results.map do |row|
        result = {
          'command' => row['cmd_text'],
          'start_time' => row['start_time']
        }

        # Add command_id for fish format to get paths
        if format == 'fish'
          result['command_id'] = row['command_id']
        end

        result
      end

      # Format results using the shared formatting function
      format_options = {
        format: format,
        include_timestamps: true
      }

      formatted_commands = format_commands_for_shell(formatted_results, format, format_options)
      begin
        formatted_commands.each { |line| puts line }
      rescue Errno::EPIPE
        # Broken pipe - output was closed (e.g., piped to head/less and user quit)
        exit 0
      end
    end

    # Output results for display
    def output_interactive_results(results, options)
      if results.empty?
        puts "No commands found matching the criteria."
        return
      end

      # Dracula color codes
      # Timestamp: #6272a4, Command: default, Result: ✓ #50fa7b, ✗ #ff5555, Duration: #bd93f9
      begin
        # Colors
        palette = Histlog::Config.colors(:history)
        ts_col = palette[:timestamp]
        dur_col = palette[:duration]
        success_col = palette[:status_success]
        fail_col = palette[:status_fail]
        null_col = palette[:status_null]
        reset_col = palette[:reset]

        # Session ID column (first column)
        session_col = palette[:status_header]
        # Header: Session Timestamp Duration Status Command
        # Session: 4 chars, Timestamp: 19, Duration: 9, Status: 6, Command: rest
        # Separator: 4+1+19+2+9+1+6+1+7 = 50 (with spaces)
        sep = '-' * 50
        printf("%s%4s%s %s%-19s%s  %s%9s%s %s%-4s%s %s\n",
               session_col, "Sess", reset_col,
               ts_col, "Timestamp", reset_col,
               dur_col, "Duration", reset_col,
               success_col, "Exit", reset_col,
               "Command")
        puts sep

        results.each do |row|
          # Format session_id as 4-digit, left-padded, or '????' if nil
          session_id = row['session_id']
          session_str = session_id ? session_id.to_s.rjust(4, '0') : '????'
          # Color session_id: use null_col if nil, else session_col
          session_color = session_id ? session_col : null_col

          timestamp = row['start_time'] ? Time.at(row['start_time']).strftime('%Y-%m-%d %H:%M:%S') : nil
          duration = row['duration'] ? sprintf('%8.3fs', row['duration']) : nil
          exit_raw = row['exit_code'] # nil for imported

          # Determine exit display: success checkmark, '/' for nil, or fail with code
          exit_text = if exit_raw == 0
                        "✓"
                      elsif exit_raw.nil?
                        "?"
                      else
                        "✗#{exit_raw}"
                      end

          # Pad exit display to 4 chars for alignment
          exit_padded = exit_text[0, 4].ljust(4)

          colored_exit = if exit_raw == 0
                           "#{success_col}#{exit_padded}#{reset_col}"
                         elsif exit_raw.nil?
                           # Grey slash for unknown/null exit codes
                           "#{null_col}#{exit_padded}#{reset_col}"
                         else
                           "#{fail_col}#{exit_padded}#{reset_col}"
                         end

          command = row['cmd_text'].gsub("\n", "\n                                   ")
          # Print timestamp and duration aligned, then colored status, then command
          # Use visible placeholder for missing timestamps
          ts_display = timestamp || "????-??-?? ??:??:??"
          dur_display = duration || " ?.????"

          # choose appropriate color for timestamp/duration (normal or null)
          ts_color = timestamp ? ts_col : null_col
          dur_color = duration ? dur_col : null_col

          # If duration is missing, use one extra pad on the left (width 9), otherwise width 8
          dur_field = duration ? sprintf('%8s', dur_display) : sprintf('%9s', dur_display)

          # Print each column once: color start, padded text, reset, etc.
          # Match header layout: session (4 chars), timestamp (19 chars, left), two spaces, duration (8 chars normally, 9 when null), space, status, then 4 spaces before command
          printf("%s%4s%s %s%-19s%s  %s%s%s %s    %s\n",
                 session_color, session_str, reset_col,
                 ts_color, ts_display, reset_col,
                 dur_color, dur_field, reset_col,
                 colored_exit, command)
        end
      rescue Errno::EPIPE
        exit 0
      end
    end

    # Format commands for specific shell format
    def format_commands_for_shell(rows, format, options)
      formatted = []

      case format
      when 'fish'
        rows.each do |row|
          formatted << "- cmd: #{row['command']}"
          if options[:include_timestamps] && row['start_time']
            formatted << "  when: #{row['start_time'].to_i}"
          end

          # Add paths for fish format if command_id is available
          if row['command_id']
            paths = Histlog::DB.get_command_paths(row['command_id'])
            if paths && !paths.empty?
              formatted << "  paths:"
              paths.each do |path|
                formatted << "    - #{path}"
              end
            end
          end
        end

      when 'zsh'
        rows.each do |row|
          if options[:include_timestamps] && row['start_time']
            # Zsh extended history format: ": timestamp:0;command"
            formatted << ": #{row['start_time'].to_i}:0;#{row['command']}"
          else
            # Simple format: just the command
            formatted << row['command']
          end
        end

      when 'nu'
        # Nushell history is plain text, one command per line
        rows.each do |row|
          formatted << row['command']
        end

      when 'bash'
        # Bash history format - simple commands, timestamps optional
        rows.each do |row|
          if options[:include_timestamps] && row['start_time']
            # Bash can use timestamps with HISTTIMEFORMAT, stored as comments
            formatted << "##{row['start_time'].to_i}"
            formatted << row['command']
          else
            formatted << row['command']
          end
        end

      when 'powershell'
        # PowerShell history is typically just commands, one per line
        rows.each do |row|
          formatted << row['command']
        end

      when 'plain'
        rows.each do |row|
          if options[:include_timestamps] && row['start_time']
            timestamp = Time.at(row['start_time'].to_f).strftime('%Y-%m-%d %H:%M:%S')
            formatted << "[#{timestamp}] #{row['command']}"
          else
            formatted << row['command']
          end
        end

      else
        # Fallback to plain format
        rows.each do |row|
          formatted << row['command']
        end
      end

      formatted
    end

    def build_reporting_db
      db_path = Histlog::Utils.get_db_path
      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true
      db
    end

    def fetch_path_args(db, command_id)
      db.execute(<<-SQL, [command_id])
        SELECT pa.arg_position, p.path, p.type
        FROM path_args pa
        JOIN paths p ON pa.path_id = p.id
        WHERE pa.command_id = ?
        ORDER BY pa.arg_position
      SQL
    end

    def format_start_time_with_ms(epoch)
      return nil unless epoch

      t = Time.at(epoch.to_f)
      ms = ((epoch.to_f % 1) * 1000).round(3)
      t.strftime("%Y-%m-%d %H:%M:%S") + ".%03d" % ms
    end

    def structured_result(row, path_args)
      # Format start_time as human-readable string
      cmd_start = row['start_time']
      formatted_cmd_start = nil
      if cmd_start
        begin
          formatted_cmd_start = Time.at(cmd_start.to_f).utc.strftime('%Y-%m-%d %H:%M:%S')
        rescue
          formatted_cmd_start = cmd_start.to_s
        end
      end

      result = {
        id: row['command_id'],
        cmd_text: row['cmd_text'],
        start_time: formatted_cmd_start,
        duration: row['duration'],
        exit_code: row['exit_code'],
        is_private: row['is_private'] == 1,
        is_assisted: row['is_assisted'] == 1,
        cwd_old: row['cwd_old'],
        cwd_new: row['cwd_new'],
        session_id: row['session_id'],
        pid: row['pid'],
        shell: row['shell_path'],
        tty: row['tty_device']
      }.reject { |_, v| v.nil? }

      if path_args.any?
        result[:path_args] = path_args.map do |arg|
          {
            position: arg['arg_position'],
            path: arg['path'],
            type: arg['type']
          }
        end
      end

      result
    end

    def structured_result_for_yaml(row, path_args)
      base = structured_result(row, path_args)
      base.transform_keys(&:to_s).tap do |hash|
        if hash['path_args']
          hash['path_args'] = hash['path_args'].map do |arg|
            arg.transform_keys { |key| key.to_s }
          end
        end
      end
    end
  end
end

require 'sqlite3'
require 'json'
require 'fileutils'
require 'optparse'
require 'ostruct'
require 'time'
require 'set'

module Histlog
  # Utility functions module
  module Utils
    module_function

    # Helper to format timestamps (from Julian Day)
    def format_time(timestamp)
      return 'unknown' unless timestamp

      # Convert from Julian Day to Unix timestamp
      unix_time = (timestamp - 2440587.5) * 86400
      Time.at(unix_time).strftime('%Y-%m-%d %H:%M:%S')
    end

    # Parse time span strings into seconds. Public utility used by query filters.
    # Accepts relative shorthand like '120s', '40m', '4h', '7d', '2w', combined tokens '1h30m',
    # verbose forms like '1 hour 30 minutes', and absolute timestamps such as
    # '2025-09-27 19:52' or '19:52'. Returns seconds (>=0), -1 for future timestamps, or nil if parse fails.
    def parse_time_span_to_seconds(str)
      return nil if str.nil?

      raw = str.strip
      s = raw.downcase
      now = Time.now

      # Try absolute timestamp parsing with various formats
      timestamp_formats = [
        '%Y-%m-%d %H:%M:%S',
        '%Y-%m-%d %H:%M',
        '%Y-%m-%d',
        '%m-%d %H:%M:%S',
        '%m-%d %H:%M',
        '%m-%d',
        '%H:%M:%S',
        '%H:%M'
      ]

      timestamp_formats.each do |fmt|
        begin
          parsed = nil
          if fmt.start_with?('%Y')
            parsed = Time.strptime(raw, fmt) rescue nil
          elsif fmt.start_with?('%m-%d')
            # attach current year
            try = Time.strptime("#{now.year}-#{raw}", "%Y-#{fmt}") rescue nil
            parsed = try
            # if parsed is in the future, try previous year
            if parsed && parsed > now
              parsed = Time.new(parsed.year - 1, parsed.month, parsed.day, parsed.hour, parsed.min, parsed.sec)
            end
          else
            # time-only formats: assume today
            try = Time.strptime(raw, fmt) rescue nil
            if try
              parsed = Time.new(now.year, now.month, now.day, try.hour, try.min, try.sec)
              # if the parsed time is in the future, assume yesterday
              if parsed > now
                parsed -= 86400
              end
            end
          end

          if parsed
            seconds = (now.to_f - parsed.to_f)
            return -1 if seconds < 0

            return seconds
          end
        rescue ArgumentError
          # try next format
        end
      end

      # Otherwise parse relative tokens (combined and decimals)
      total = 0.0
      matched = false

      # Shorthand tokens like '1.5h', repeated tokens '1h30m'
      s.scan(/(\d+(?:\.\d+)?)\s*([smhdw])/) do |num_s, unit|
        num = num_s.to_f
        matched = true
        case unit
        when 's' then total += num
        when 'm' then total += num * 60
        when 'h' then total += num * 3600
        when 'd' then total += num * 86400
        when 'w' then total += num * 7 * 86400
        end
      end

      # Verbose tokens like '1 hour', '30 minutes'
      s.scan(/(\d+(?:\.\d+)?)\s*(second|seconds|minute|minutes|hour|hours|day|days|week|weeks)/) do |num_s, word|
        num = num_s.to_f
        matched = true
        case word
        when 'second', 'seconds' then total += num
        when 'minute', 'minutes' then total += num * 60
        when 'hour', 'hours' then total += num * 3600
        when 'day', 'days' then total += num * 86400
        when 'week', 'weeks' then total += num * 7 * 86400
        end
      end

      return nil unless matched

      total % 1 == 0 ? total.to_i : total
    end

    # Helper to format duration
    def format_duration(duration)
      return 'N/A' unless duration

      if duration < 1
        "#{(duration * 1000).round(1)}ms"
      elsif duration < 60
        "#{duration.round(2)}s"
      elsif duration < 3600
        minutes = (duration / 60).to_i
        seconds = (duration % 60).round(1)
        "#{minutes}m #{seconds}s"
      else
        hours = (duration / 3600).to_i
        minutes = ((duration % 3600) / 60).to_i
        "#{hours}h #{minutes}m"
      end
    end

    # Helper to truncate command text
    def truncate_command(command, max_length = 60)
      return 'N/A' unless command

      command.length > max_length ? "#{command[0...max_length - 3]}..." : command
    end

    # Get current timezone
    def get_timezone
      # Try to get timezone from environment or system
      ENV['TZ'] || Time.now.zone || 'UTC'
    rescue
      'UTC'
    end

    # Cross-platform TTY detection
    def get_current_tty
      if RUBY_PLATFORM.include?('linux')
        # On Linux, read from /proc
        begin
          File.read('/proc/self/fd/0').match(/\/dev\/(.*)$/)[1]
        rescue
          'unknown'
        end
      else
        # On macOS and other systems, use tty command
        begin
          `tty`.chomp
        rescue
          # Fallback to TERM environment variable
          ENV['TERM'] || 'unknown'
        end
      end
    end

    # ...existing code...

    # Helper to get tty
    def get_tty
      begin
        # Try Linux-style first
        File.readlink('/proc/self/fd/0')
      rescue
        begin
          # Try macOS-style
          `tty`.chomp
        rescue
          # Fallback to TERM environment variable
          ENV['TERM'] || 'unknown'
        end
      end
    end

    # SQLite database setup
    def get_db_path
      # Prefer explicit environment variable if provided, else default to configured db path
      Histlog::Config.db_path
    end

    # parse_time_span_to_seconds is implemented as a module-level helper below
    # to avoid nested definitions. Use that implementation for parsing --since.
  end
end

# Minimal DB namespace wrapper so existing code can call Histlog::DB.* helpers
module Histlog
  module DB
    module_function

    # Expose path accessor
    def path
      Histlog::Config.db_path
    end

    # initialize_db implementation
    def initialize_db
      db_path = Histlog::Config.db_path
      db_dir = File.dirname(db_path)
      FileUtils.mkdir_p(db_dir) unless Dir.exist?(db_dir)
      db = SQLite3::Database.new(db_path)

      # Enable performance and compression optimizations
      db.execute "PRAGMA journal_mode = WAL"
      db.execute "PRAGMA synchronous = NORMAL"
      db.execute "PRAGMA cache_size = 10000"
      db.execute "PRAGMA temp_store = MEMORY"
      db.execute "PRAGMA mmap_size = 268435456"
      db.execute "PRAGMA page_size = 4096"

      # Create tables and indexes (same as original implementation)
      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS shells (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	path TEXT UNIQUE NOT NULL,
    	version TEXT,
    	created_at REAL DEFAULT (julianday('now'))
        )
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS ttys (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	device TEXT NOT NULL,
    	created_at REAL DEFAULT (julianday('now'))
        );
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS paths (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	path TEXT NOT NULL,
    	type TEXT NOT NULL CHECK (type IN ('f', 'd')),
    	created_at REAL DEFAULT (julianday('now'))
        );
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS sessions (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	shell_id INTEGER,
    	tty_id INTEGER,
    	path_id INTEGER,
    	pid INTEGER,
    	parent_pid INTEGER,
    	start_time REAL,
    	timezone TEXT,
    	created_at REAL DEFAULT (julianday('now')),
    	FOREIGN KEY (shell_id) REFERENCES shells (id),
    	FOREIGN KEY (tty_id) REFERENCES ttys (id),
    	FOREIGN KEY (path_id) REFERENCES paths (id)
        )
      SQL

      # Run migrations immediately after creating sessions so missing columns (like sessions.start_time) are added
      begin
        run_migrations(db)
      rescue => e
        STDERR.puts "Warning: migration failure: #{e.message}"
      end

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS cmd_texts (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	command TEXT UNIQUE NOT NULL,
    	created_at REAL DEFAULT (julianday('now'))
        )
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS commands (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	session_id INTEGER,
    	cmd_text_id INTEGER,
    	path_old_id INTEGER,
    	path_new_id INTEGER,
    	start_time REAL,
    	duration REAL,
    	exit_code INTEGER,
    	is_private INTEGER DEFAULT 0,
    	is_assisted INTEGER DEFAULT 0,
    	created_at REAL DEFAULT (julianday('now')),
    	FOREIGN KEY (session_id) REFERENCES sessions (id),
    	FOREIGN KEY (cmd_text_id) REFERENCES cmd_texts (id),
    	FOREIGN KEY (path_old_id) REFERENCES paths (id),
    	FOREIGN KEY (path_new_id) REFERENCES paths (id)
        )
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS path_args (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        command_id INTEGER,
        path_id INTEGER,
        arg_position INTEGER,
        created_at REAL DEFAULT (julianday('now')),
        FOREIGN KEY (command_id) REFERENCES commands (id),
        FOREIGN KEY (path_id) REFERENCES paths (id),
        UNIQUE (command_id, path_id, arg_position)
        )
      SQL

      # Indexes
      db.execute "CREATE INDEX IF NOT EXISTS idx_shells_path ON shells (path)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_ttys_device ON ttys (device)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_paths_path ON paths (path)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_paths_type ON paths (type)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_sessions_shell_id ON sessions (shell_id)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_sessions_created_at ON sessions (created_at)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_sessions_start_time ON sessions (start_time)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_sessions_path_id ON sessions (path_id)"
      db.execute "CREATE UNIQUE INDEX IF NOT EXISTS idx_cmd_texts_command ON cmd_texts (command)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_cmd_texts_created_at ON cmd_texts (created_at)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_session_id ON commands (session_id)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_cmd_text_id ON commands (cmd_text_id)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_created_at ON commands (created_at)"
      # Ensure start_time column exists (migration for older DBs)
      begin
        cols = db.execute("PRAGMA table_info(commands)")
        col_names = cols.map { |r| r[1] }
        unless col_names.include?('start_time')
          db.execute "ALTER TABLE commands ADD COLUMN start_time REAL"
        end
      rescue SQLite3::Exception
      end
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_start_time ON commands (start_time)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_exit_code ON commands (exit_code)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_command_id ON path_args (command_id)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_path_id ON path_args (path_id)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_path_id ON path_args (path_id)"

      # Compound indexes for common query patterns
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_session_id_created_at ON commands (session_id, created_at)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_exit_code_created_at ON commands (exit_code, created_at)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_command_id_arg_position ON path_args (command_id, arg_position)"

      # Partial indexes for performance on common filters
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_session_created_where_failed ON commands (session_id, created_at) WHERE exit_code != 0"
      db.execute "CREATE INDEX IF NOT EXISTS idx_paths_path_where_file ON paths (path) WHERE type = 'f'"
      db.execute "CREATE INDEX IF NOT EXISTS idx_paths_path_where_dir ON paths (path) WHERE type = 'd'"

      # Create sessions view for easier querying
      db.execute "DROP VIEW IF EXISTS sessions_view"
      db.execute <<-SQL
        CREATE VIEW sessions_view AS
        SELECT
    	s.id as session_id,
    	s.pid,
    	s.parent_pid,
    	s.timezone,
    	s.created_at,
    	datetime(s.created_at) as created_time,
    	sh.path as shell_path,
    	sh.version as shell_version,
    	t.device as tty_device,
    	p.path as working_directory
        FROM sessions s
        LEFT JOIN shells sh ON s.shell_id = sh.id
        LEFT JOIN ttys t ON s.tty_id = t.id
        LEFT JOIN paths p ON s.path_id = p.id
      SQL

      # Create history view for comprehensive command history
      db.execute <<-SQL
        CREATE VIEW IF NOT EXISTS history_view AS
        SELECT
    	cmd.id as cmd_text_id,
    	cmd.session_id as session_id,
    	s.pid as session_pid,
    	s.parent_pid as session_parent_pid,
    	datetime(s.created_at, 'unixepoch') as session_started,
    	sh.path as shell_path,
    	t.device as tty_device,
    	c.command,
    	datetime(cmd.start_time, 'unixepoch') as command_started,
    	cmd.start_time as start_time,
    	cmd.duration,
    	cmd.exit_code,
    	cmd.is_private,
    	p_old.path as cwd_old,
    	p_new.path as cwd_new,
    	CASE
    	WHEN p_old.path IS NOT NULL AND p_new.path IS NOT NULL AND p_old.path != p_new.path THEN 1
    	ELSE 0
    	END as directory_changed
    	FROM commands cmd
        LEFT JOIN sessions s ON cmd.session_id = s.id
    	JOIN cmd_texts c ON cmd.cmd_text_id = c.id
        LEFT JOIN shells sh ON s.shell_id = sh.id
        LEFT JOIN ttys t ON s.tty_id = t.id
        LEFT JOIN paths p_old ON cmd.path_old_id = p_old.id
        LEFT JOIN paths p_new ON cmd.path_new_id = p_new.id
      ORDER BY cmd.start_time DESC
      SQL

      db
    end

    # Helper: get or create a shell id
    def get_or_create_shell_id(db, shell_path)
      return nil unless shell_path

      result = db.execute("SELECT id FROM shells WHERE path = ?", [shell_path])
      return result[0][0] if result && result[0]

      version = begin
        `#{shell_path} --version 2>/dev/null`.strip
      rescue
        nil
      end
      begin
        res = db.execute("INSERT INTO shells (path, version) VALUES (?, ?) RETURNING id", [shell_path, version])
        res[0][0] if res && res[0]
      rescue SQLite3::Exception
        db.execute("INSERT INTO shells (path, version) VALUES (?, ?)", [shell_path, version])
        db.last_insert_row_id
      end
    end

    def get_or_create_tty_id(db, tty_device)
      return nil unless tty_device

      result = db.execute("SELECT id FROM ttys WHERE device = ?", [tty_device])
      return result[0][0] if result && result[0]

      begin
        res = db.execute("INSERT INTO ttys (device) VALUES (?) RETURNING id", [tty_device])
        res[0][0] if res && res[0]
      rescue SQLite3::Exception
        db.execute("INSERT INTO ttys (device) VALUES (?)", [tty_device])
        db.last_insert_row_id
      end
    end

    def get_or_create_path_id(db, path, type = nil)
      return nil unless path

      begin
        abs_path = File.expand_path(path)
      rescue => e
        STDERR.puts "Warning: Could not normalize path '#{path}': #{e.message}"
        abs_path = path
      end
      result = db.execute("SELECT id FROM paths WHERE path = ?", [abs_path])
      return result[0][0] if result && result[0]

      if type.nil?
        type = File.directory?(abs_path) ? 'd' : 'f'
      end
      begin
        res = db.execute("INSERT INTO paths (path, type) VALUES (?, ?) RETURNING id", [abs_path, type])
        res[0][0] if res && res[0]
      rescue SQLite3::Exception
        db.execute("INSERT INTO paths (path, type) VALUES (?, ?)", [abs_path, type])
        db.last_insert_row_id
      end
    end

    def get_or_create_cmd_text_id(db, command)
      result = db.execute("SELECT id FROM cmd_texts WHERE command = ?", [command])
      if result && result[0]
        id_val = result[0].is_a?(Hash) ? result[0]["id"] : result[0][0]
        return id_val && id_val.to_i > 0 ? id_val.to_i : nil
      end
      begin
        res = db.execute("INSERT INTO cmd_texts (command) VALUES (?) RETURNING id", [command])
        if res && res[0]
          id_val = res[0].is_a?(Hash) ? res[0]["id"] : res[0][0]
          return id_val && id_val.to_i > 0 ? id_val.to_i : nil
        end
      rescue SQLite3::Exception => e
        if e.message.include?("syntax error") || e.message.include?("RETURNING")
          db.execute("INSERT INTO cmd_texts (command) VALUES (?)", [command])
          last_id = db.last_insert_row_id
          return last_id && last_id.to_i > 0 ? last_id.to_i : nil
        else
          raise e
        end
      end
      nil
    end

    # Simple migration runner - idempotent and safe for older DBs
    def run_migrations(db)
      # Ensure sessions.start_time column exists
      cols = db.execute("PRAGMA table_info(sessions)")
      col_names = cols.map { |r| r[1] }
      unless col_names.include?('start_time')
        db.execute("ALTER TABLE sessions ADD COLUMN start_time REAL")
        # backfill start_time from created_at where possible
        begin
          db.execute("UPDATE sessions SET start_time = created_at WHERE start_time IS NULL AND created_at IS NOT NULL")
        rescue SQLite3::Exception
        end
      end
      # Ensure metadata table exists for tracking migrations/schema version
      begin
        db.execute <<-SQL
          CREATE TABLE IF NOT EXISTS metadata (
            key TEXT PRIMARY KEY,
            value TEXT
          )
        SQL
      rescue SQLite3::Exception
      end

      # Set schema_version if not present
      begin
        sv = db.get_first_value("SELECT value FROM metadata WHERE key = 'schema_version'")
        unless sv
          db.execute("INSERT INTO metadata (key, value) VALUES ('schema_version', '1')")
        end
      rescue SQLite3::Exception
      end
      # Ensure commands.start_time index exists (already created above)
      true
    end

    # Find an existing session by metadata (shell, tty, pid) and proximity to a provided start_time
    # Returns session id or nil
    def find_session_by_meta(db, meta)
      return nil unless meta && (meta[:shell] || meta[:tty] || meta[:pid] || meta[:start_time])

      # Build query with available fields
      conditions = []
      params = []
      if meta[:shell]
        conditions << 'sh.path = ?'
        params << meta[:shell]
      end
      if meta[:tty]
        conditions << 't.device = ?'
        params << meta[:tty]
      end
      if meta[:pid]
        conditions << 's.pid = ?'
        params << meta[:pid]
      end

      # Time proximity: allow a few seconds tolerance (default 5 minutes)
      time_tol = meta[:time_tolerance] || 300
      if meta[:start_time]
        conditions << '(s.start_time BETWEEN ? AND ? OR s.start_time IS NULL)'
        params << (meta[:start_time].to_f - time_tol)
        params << (meta[:start_time].to_f + time_tol)
      end

      query = <<-SQL
        SELECT s.id FROM sessions s
        LEFT JOIN shells sh ON s.shell_id = sh.id
        LEFT JOIN ttys t ON s.tty_id = t.id
        WHERE #{conditions.join(' AND ')}
        ORDER BY ABS(COALESCE(s.start_time, s.created_at) - ?) ASC
        LIMIT 1
      SQL

      # If start_time present, add it as last param for ORDER BY; else use 0
      order_ref = meta[:start_time] ? meta[:start_time].to_f : 0
      begin
        res = db.execute(query, params + [order_ref])
        return res[0][0] if res && res[0]
      rescue SQLite3::Exception
        return nil
      end
      nil
    end

    def store_session(session_data)
      db = initialize_db
      begin
        shell_id = get_or_create_shell_id(db, session_data[:shell])
        tty_id = get_or_create_tty_id(db, session_data[:tty])
        path_id = get_or_create_path_id(db, session_data[:cwd])
        # If a start_time is provided, try to find an existing session by metadata/time proximity
        final_session_id = nil
        if session_data[:start_time]
          found = find_session_by_meta(db, shell: session_data[:shell], tty: session_data[:tty],
                                           pid: session_data[:pid], start_time: session_data[:start_time])
          if found
            # update session fields if necessary
            begin
              db.execute(
                "UPDATE sessions SET shell_id = ?, tty_id = ?, path_id = ?, pid = ?, parent_pid = ?, timezone = ?, start_time = COALESCE(start_time, ?) WHERE id = ?", [
                  shell_id, tty_id, path_id, session_data[:pid], session_data[:parent_pid], session_data[:timezone], session_data[:start_time].to_f, found
                ]
              )
            rescue SQLite3::Exception
            end
            return found
          end
        end

        # Insert new session
        begin
          res = db.execute("INSERT INTO sessions (shell_id, tty_id, path_id, pid, parent_pid, timezone, start_time) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id",
                           [shell_id, tty_id, path_id, session_data[:pid], session_data[:parent_pid],
                            session_data[:timezone], session_data[:start_time] ? session_data[:start_time].to_f : nil])
          return res[0][0] if res && res[0]
        rescue SQLite3::Exception => e
          if e.message.include?("syntax error") || e.message.include?("RETURNING")
            STDERR.puts "Warning: RETURNING clause not supported, using fallback method"
            db.execute("INSERT INTO sessions (shell_id, tty_id, path_id, pid, parent_pid, timezone, start_time) VALUES (?, ?, ?, ?, ?, ?, ?)",
                       [shell_id, tty_id, path_id, session_data[:pid], session_data[:parent_pid],
                        session_data[:timezone], session_data[:start_time] ? session_data[:start_time].to_f : nil])
            return db.last_insert_row_id
          else
            STDERR.puts "Error storing session: #{e.message}"
            return nil
          end
        end
      ensure
        db.close if db
      end
    end

    def store_command(command_data)
      db = initialize_db
      begin
        original_command = command_data[:command]
        is_private = original_command.start_with?(' ') ? 1 : 0
        clean_command = original_command.lstrip
        is_assisted = ENV['VSCODE_INJECTION'] == '1' ? 1 : 0
        cmd_text_id = get_or_create_cmd_text_id(db, clean_command)
        path_old_id = get_or_create_path_id(db, command_data[:cwd])
        begin
          res = db.execute("INSERT INTO commands (session_id, cmd_text_id, path_old_id, is_private, is_assisted, start_time) VALUES (?, ?, ?, ?, ?, ?) RETURNING id",
                           [command_data[:session_id], cmd_text_id, path_old_id, is_private, is_assisted,
                            Time.now.to_f])
          command_id = res[0][0] if res && res[0]
          if command_id
            parse_command_arguments(db, command_id, clean_command)
          end
          return command_id
        rescue SQLite3::Exception => e
          if e.message.include?("syntax error") || e.message.include?("RETURNING")
            STDERR.puts "Warning: RETURNING clause not supported, using fallback method"
            db.execute("INSERT INTO commands (session_id, cmd_text_id, path_old_id, is_private, start_time) VALUES (?, ?, ?, ?, ?)",
                       [command_data[:session_id], cmd_text_id, path_old_id, is_private, Time.now.to_f])
            command_id = db.last_insert_row_id
            if command_id
              parse_command_arguments(db, command_id, clean_command)
            end
            return command_id
          else
            STDERR.puts "Error storing command: #{e.message}"
            return nil
          end
        end
      ensure
        db.close if db
      end
    end

    def parse_command_arguments(db, command_id, command_text)
      args = command_text.scan(/(?:[^\s"']+|"[^"]*"|'[^']*')+/).map { |arg| arg.gsub(/^["']|["']$/, '') }
      args.each_with_index do |arg, position|
        next if position == 0
        next if arg.include?("\x00") || arg.empty?

        begin
          if File.exist?(arg)
            abs_path = File.expand_path(arg)
            path_type = File.directory?(abs_path) ? 'd' : 'f'
            path_id = get_or_create_path_id(db, abs_path, path_type)
            existing = db.execute(
              "SELECT 1 FROM path_args WHERE command_id = ? AND path_id = ? AND arg_position = ? LIMIT 1", [command_id, path_id,
                                                                                                            position]
            )
            unless existing.any?
              db.execute("INSERT INTO path_args (command_id, path_id, arg_position) VALUES (?, ?, ?)",
                         [command_id, path_id, position])
            end
          end
        rescue
        end
      end
    end

    def update_command_completion(command_id, duration, exit_code)
      db = initialize_db
      begin
        cwd_new_id = get_or_create_path_id(db, Dir.pwd)
        db.execute("UPDATE commands SET duration = ?, exit_code = ?, path_new_id = ? WHERE id = ?",
                   [duration, exit_code, cwd_new_id, command_id])
        result = db.execute(
          "SELECT c.command FROM commands cmd JOIN cmd_texts c ON cmd.cmd_text_id = c.id WHERE cmd.id = ?", [command_id]
        )
        if result && result[0]
          command_text = result[0][0]
          parse_command_arguments(db, command_id, command_text)
        end
      rescue SQLite3::Exception => e
        STDERR.puts "Error updating command: #{e.message}"
      ensure
        db.close if db
      end
    end

    def cleanup_orphaned_entries(db, verbose = false)
      removed_counts = {}
      db.execute(<<-SQL)
        DELETE FROM paths
        WHERE id NOT IN (SELECT path_old_id FROM commands WHERE path_old_id IS NOT NULL)
          AND id NOT IN (SELECT path_new_id FROM commands WHERE path_new_id IS NOT NULL)
          AND id NOT IN (SELECT path_id FROM path_args WHERE path_id IS NOT NULL)
      SQL
      removed_counts[:paths] = db.changes
      db.execute(<<-SQL)
        DELETE FROM cmd_texts
        WHERE id NOT IN (SELECT cmd_text_id FROM commands WHERE cmd_text_id IS NOT NULL)
      SQL
      removed_counts[:cmd_texts] = db.changes
      db.execute(<<-SQL)
        DELETE FROM path_args
        WHERE path_id NOT IN (SELECT id FROM paths)
           OR command_id NOT IN (SELECT id FROM commands)
      SQL
      removed_counts[:path_args] = db.changes
      begin
        db.execute(<<-SQL)
          DELETE FROM ttys
          WHERE id NOT IN (SELECT tty_id FROM sessions WHERE tty_id IS NOT NULL)
        SQL
        removed_counts[:ttys] = db.changes
      rescue SQLite3::SQLException => e
        removed_counts[:ttys] = 0
        puts "Warning: Could not cleanup ttys: #{e.message}" if verbose
      end
      begin
        db.execute(<<-SQL)
          DELETE FROM shells
          WHERE id NOT IN (SELECT shell_id FROM sessions WHERE shell_id IS NOT NULL)
        SQL
        removed_counts[:shells] = db.changes
      rescue SQLite3::SQLException => e
        removed_counts[:shells] = 0
        puts "Warning: Could not cleanup shells: #{e.message}" if verbose
      end
      begin
        db.execute(<<-SQL)
          DELETE FROM sessions
          WHERE id NOT IN (SELECT session_id FROM commands WHERE session_id IS NOT NULL)
        SQL
        removed_counts[:sessions] = db.changes
      rescue SQLite3::SQLException => e
        removed_counts[:sessions] = 0
        puts "Warning: Could not cleanup sessions: #{e.message}" if verbose
      end
      if verbose
        puts "Cleanup summary:"
        removed_counts.each do |table, count|
          puts "  #{table}: #{count} orphaned entries removed"
        end
      end
      total_removed = removed_counts.values.sum
      puts "Orphaned entries cleaned up (#{total_removed} total)." unless verbose
      removed_counts
    end

    def get_command_paths(command_id)
      return [] unless command_id

      db_path = path
      return [] unless File.exist?(db_path)

      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true
      begin
        cmd_info = db.execute(
          "SELECT ct.command, p1.path as old_path, p2.path as new_path FROM commands c
           JOIN cmd_texts ct ON c.cmd_text_id = ct.id
           LEFT JOIN paths p1 ON c.path_old_id = p1.id
           LEFT JOIN paths p2 ON c.path_new_id = p2.id
           WHERE c.id = ?",
          [command_id]
        ).first
        return [] unless cmd_info

        command_text = cmd_info['command']
        old_path = cmd_info['old_path']
        new_path = cmd_info['new_path']
        path_args = db.execute(<<-SQL, [command_id])
          SELECT pa.arg_position, p.path, p.type
          FROM path_args pa
          JOIN paths p ON pa.path_id = p.id
          WHERE pa.command_id = ?
          ORDER BY pa.arg_position
        SQL
        paths = []
        if command_text.strip.match(/^cd\s/)
          cd_match = command_text.strip.match(/^cd(?:\s+([^\s;&|]+))?/)
          if cd_match && cd_match[1]
            cd_arg = cd_match[1].strip
            cd_arg = cd_arg.gsub(/^['"]|['"]$/, '')
            paths << cd_arg
          end
        else
          seen_paths = Set.new
          path_args.each do |row|
            path = row['path']
            unless seen_paths.include?(path)
              paths << path
              seen_paths.add(path)
            end
          end
        end
        paths
      rescue SQLite3::SQLException => e
        []
      ensure
        db&.close
      end
    end

    def import_commands_to_db(commands, options)
      db = initialize_db
      db.results_as_hash = true
      imported_count = 0
      skipped_count = 0
      updated_count = 0
      # no session_id lookup (we don't keep original session id mappings)
      begin
        commands.each_with_index do |cmd_data, index|
          begin
            next if cmd_data[:command].nil? || cmd_data[:command].strip.empty?

            # Normalize command text: support :cmd_text or :command
            original_command = cmd_data[:cmd_text] || cmd_data[:command]
            next if original_command.nil?

            is_private = original_command.start_with?(' ') ? 1 : 0
            clean_command = original_command.lstrip
            cmd_text_id = get_or_create_cmd_text_id(db, clean_command)

            # Duplicate detection: same cmd_text_id and same start_time (or both NULL)
            begin
              if cmd_data[:start_time]
                existing = db.get_first_value("SELECT id FROM commands WHERE cmd_text_id = ? AND start_time = ?",
                                              [cmd_text_id, cmd_data[:start_time].to_f])
              else
                existing = db.get_first_value("SELECT id FROM commands WHERE cmd_text_id = ? AND start_time IS NULL",
                                              [cmd_text_id])
              end
            rescue SQLite3::Exception
              existing = nil
            end

            if existing && existing.to_i > 0
              # If incoming entry doesn't include exit_code, and DB has one, clear it
              if cmd_data[:exit_code].nil?
                begin
                  existing_exit = db.get_first_value("SELECT exit_code FROM commands WHERE id = ?", [existing])
                  if !existing_exit.nil?
                    db.execute("UPDATE commands SET exit_code = NULL WHERE id = ?", [existing])
                    updated_count += 1
                    puts "Updated existing command ##{existing}: cleared exit_code to NULL" if options[:verbose]
                  end
                rescue SQLite3::Exception
                end
              end

              skipped_count += 1
              puts "Skipping duplicate command (already in DB) #{clean_command}" if options[:verbose]
              next
            end
            # Determine final session id: CLI flag overrides. Never reuse session_id from import directly.
            final_session_id = options[:session_id]
            if final_session_id.nil?
              if cmd_data[:session] && cmd_data[:session].is_a?(Hash) && !cmd_data[:session].empty?
                # Build session meta
                session_meta = {}
                session_meta[:shell] = cmd_data[:session][:shell] || cmd_data[:session]['shell']
                session_meta[:tty] = cmd_data[:session][:tty] || cmd_data[:session]['tty']
                session_meta[:pid] = cmd_data[:session][:pid] || cmd_data[:session]['pid']
                # support start_time in seconds or as string
                if cmd_data[:session][:start_time]
                  session_meta[:start_time] = cmd_data[:session][:start_time].to_f
                elsif cmd_data[:session]['start_time']
                  session_meta[:start_time] = cmd_data[:session]['start_time'].to_f
                end
                session_meta[:timezone] = cmd_data[:session][:timezone] || cmd_data[:session]['timezone']
                session_meta[:cwd] = cmd_data[:session][:cwd] || cmd_data[:session]['cwd']

                # Try to find existing session by metadata/time proximity
                begin
                  existing = find_session_by_meta(db, session_meta)
                  if existing
                    final_session_id = existing
                  else
                    # create session with start_time if available
                    store_meta = {
                      shell: session_meta[:shell],
                      tty: session_meta[:tty],
                      pid: session_meta[:pid],
                      parent_pid: cmd_data[:session][:parent_pid] || cmd_data[:session]['parent_pid'],
                      timezone: session_meta[:timezone],
                      cwd: session_meta[:cwd],
                      start_time: session_meta[:start_time]
                    }
                    final_session_id = store_session(store_meta)
                  end
                rescue => e
                  final_session_id = nil
                end
              else
                # No session metadata: treat as imported command (no session)
                final_session_id = nil
              end
            end

            is_assisted = cmd_data[:is_assisted] ? 1 : 0
            exit_code_val = cmd_data.key?(:exit_code) ? cmd_data[:exit_code] : nil

            # Insert command: preserve start_time if provided
            if cmd_data[:start_time]
              db.execute(
                "INSERT INTO commands (session_id, cmd_text_id, path_old_id, path_new_id, duration, exit_code, is_private, is_assisted, created_at, start_time) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", [
                  final_session_id, cmd_text_id, nil, nil, cmd_data[:duration], exit_code_val, is_private, is_assisted, (cmd_data[:start_time].to_f / 86400) + 2440587.5, cmd_data[:start_time].to_f
                ]
              )
            else
              db.execute(
                "INSERT INTO commands (session_id, cmd_text_id, path_old_id, path_new_id, duration, exit_code, is_private, is_assisted, start_time) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)", [
                  final_session_id, cmd_text_id, nil, nil, cmd_data[:duration], exit_code_val, is_private, is_assisted, nil
                ]
              )
            end
            new_command_id = db.last_insert_row_id
            # Import path_args if present
            if cmd_data[:path_args].is_a?(Array) && cmd_data[:path_args].any?
              cmd_data[:path_args].each do |pa|
                begin
                  path = pa[:path]
                  next unless path

                  type = pa[:type]
                  path_id = get_or_create_path_id(db, path, type)
                  db.execute("INSERT OR IGNORE INTO path_args (command_id, path_id, arg_position) VALUES (?, ?, ?)",
                             [new_command_id, path_id, pa[:position]])
                rescue => e
                  # ignore path arg import failures
                end
              end
            end
            imported_count += 1
          rescue SQLite3::Exception => e
            STDERR.puts "Warning: Could not import command '#{cmd_data[:command]}': #{e.message}" if options[:verbose]
          end
        end
        # no original session id mappings to report
      rescue SQLite3::Exception => e
        STDERR.puts "Database error during import: #{e.message}"
      ensure
        db.close if db
      end

      [imported_count, skipped_count, updated_count]
    end
  end
end

# Remove old function definitions - these are now in Histlog::Reporting and Histlog::Import

# Shell configuration functions
def fish_config
  histlog_path = File.expand_path(__FILE__)
  <<~FISH
    #!/usr/bin/env fish
    # histlog configuration for fish shell
    # Add this to your config.fish or source this file

    status --is-interactive; or exit

    if test -z "$__histlog_session_id"
      set -gx __histlog_path "#{histlog_path}"
      set -gx __histlog_session_id (
        $__histlog_path _on_session
      )
    end

    function __histlog_preexec --on-event fish_preexec
      set -gx __histlog_command_id (
        $__histlog_path _on_preexec $argv[1] $__histlog_session_id
      )
    end

    function __histlog_postcmd --on-event fish_postexec
      $__histlog_path _on_postcmd $__histlog_command_id $CMD_DURATION $status
      set --erase __histlog_command_id
    end
  FISH
end

def zsh_config
  histlog_path = File.expand_path(__FILE__)
  <<~ZSH
    #!/usr/bin/env zsh
    # histlog configuration for zsh shell
    # Add this to ~/.zshrc or source this file

    [[ $- != *i* ]] && return

    if [[ -z $__histlog_session_id ]]; then
      export __histlog_path="#{histlog_path}"
      export __histlog_session_id="$($__histlog_path _on_session)"
    fi

    function __histlog_preexec() {
      export __histlog_command_id="$($__histlog_path _on_preexec "$1" "$__histlog_session_id")"
    }

    function __histlog_postexec() {
      $__histlog_path _on_postcmd "$__histlog_command_id" "$CMD_DURATION" "$?"
      unset __histlog_command_id
    }

    autoload -Uz add-zsh-hook
    add-zsh-hook preexec __histlog_preexec
    add-zsh-hook precmd __histlog_postexec
  ZSH
end

def nu_config
  histlog_path = File.expand_path(__FILE__)
  <<~NUSHELL
    #!/usr/bin/env nu
    # histlog configuration for nushell
    # Add this to your config.nu

    if (not $env.INTERACTIVE) { return }

    if ($env.__histlog_session_id? | is-empty) {
      $env.__histlog_path = "#{histlog_path}"
      $env.__histlog_session_id = ^$env.__histlog_path _on_session
    }

    $env.config.hooks = {
      pre_execution: [
        { $env.__histlog_command_id = (^$env.__histlog_path _on_preexec (commandline) $env.__histlog_session_id) }
      ]
      pre_prompt: [
        { ^$env.__histlog_path _on_postcmd $env.__histlog_command_id $env.CMD_DURATION_MS $env.LAST_EXIT_CODE }
        { $env.__histlog_command_id = null }
      ]
    }
  NUSHELL
end

# Main application class
# MCP Server Implementation
# Provides Model Context Protocol server with histlog data access via stdio transport
def handle_mcp_server(args)
  require 'json'

  options = {
    trace_level: nil # basic, verbose, full, debug
  }

  OptionParser.new do |opts|
    opts.banner = "Usage: histlog mcp [--trace=LEVEL]"
    opts.on("--trace=LEVEL", ["basic", "verbose", "full", "debug"],
            "Enable tracing (basic: method calls + timing, verbose: + request/response summaries, full: + complete JSON payloads, debug: + internal state + SQL queries)") do |level|
      options[:trace_level] = level
    end
    opts.on("-h", "--help", "Show this help") do
      show_mcp_help
      exit 0
    end
  end.parse!(args)

  # Set global trace level for use in server functions
  @mcp_trace_level = options[:trace_level]

  run_mcp_stdio_server
end

# MCP Logging helpers - support multiple trace levels
def mcp_log(level, message)
  return unless @mcp_trace_level

  # Check if current trace level includes the requested level
  levels = ["basic", "verbose", "full", "debug"]
  current_index = levels.index(@mcp_trace_level)
  requested_index = levels.index(level.to_s)

  return if current_index.nil? || requested_index.nil? || requested_index > current_index

  timestamp = Time.now.strftime('%Y-%m-%d %H:%M:%S.%3N')
  STDERR.puts "[#{timestamp}] MCP #{level.upcase}: #{message}"
end

# Convenience methods for different trace levels
def mcp_log_basic(message)
  mcp_log(:basic, message)
end

def mcp_log_verbose(message)
  mcp_log(:verbose, message)
end

def mcp_log_full(message)
  mcp_log(:full, message)
end

def mcp_log_debug(message)
  mcp_log(:debug, message)
end

def run_mcp_stdio_server
  STDERR.puts "Starting MCP server using stdio transport..."
  mcp_log_basic("MCP stdio server initialized")

  loop do
    begin
      line = STDIN.gets
      break if line.nil?

      line = line.strip
      next if line.empty?

      request = JSON.parse(line)
      mcp_log_full("Request: #{JSON.generate(request)}")

      response = handle_mcp_request(request)

      mcp_log_full("Response: #{JSON.generate(response)}")
      puts JSON.generate(response)
      STDOUT.flush
    rescue JSON::ParserError => e
      mcp_log_basic("Parse error: #{e.message}")
      error_response = {
        jsonrpc: "2.0",
        error: {
          code: -32700,
          message: "Parse error: #{e.message}"
        }
      }
      puts JSON.generate(error_response)
      STDOUT.flush
    rescue => e
      STDERR.puts "MCP Server error: #{e.message}"
      STDERR.puts e.backtrace.join("\n")
    end
  end
end

def handle_mcp_request(request)
  method = request["method"]
  params = request["params"] || {}
  id = request["id"]

  mcp_log_basic("Processing method: #{method}")

  case method
  when "initialize"
    mcp_log_verbose("Initialize request")
    {
      jsonrpc: "2.0",
      id: id,
      result: {
        protocolVersion: "2024-11-05",
        capabilities: {
          tools: {}
        },
        serverInfo: {
          name: "histlog",
          version: "1.0.0"
        }
      }
    }

  when "tools/list"
    mcp_log_verbose("Tools list request")
    {
      jsonrpc: "2.0",
      id: id,
      result: {
        tools: [
          {
            name: "query_commands",
            description: "Search command history with optional filters",
            inputSchema: {
              type: "object",
              properties: {
                search_term: { type: "string", description: "Search term to filter commands" },
                limit: { type: "integer", description: "Maximum number of results (default: 50)" },
                session: { type: "integer", description: "Filter by session ID" },
                dir: { type: "string", description: "Filter by working directory path" },
                failed: { type: "boolean", description: "Only show failed commands (exit code != 0)" },
                success: { type: "boolean", description: "Only show successful commands (exit code = 0)" },
                exitcode: { type: "integer", description: "Filter by specific exit code" },
                unique: { type: "boolean", description: "Show only unique commands (deduplicated)" },
                shell: { type: "string", description: "Filter by shell name (fish, zsh, bash, etc.)" },
                private: { type: "boolean", description: "Filter by private status (commands starting with space)" },
                imported: { type: "boolean",
                            description: "Filter by import status (true for imported, false for live commands)" },
                assisted: { type: "boolean", description: "Filter by AI assistance status" },
                today: { type: "boolean", description: "Only show commands from today" },
                week: { type: "boolean", description: "Only show commands from this week" }
              }
            }
          },
          {
            name: "get_command_stats",
            description: "Get usage statistics and most frequent commands",
            inputSchema: {
              type: "object",
              properties: {
                limit: { type: "integer", description: "Number of top commands to show (default: 10)" }
              }
            }
          },
          {
            name: "get_database_info",
            description: "Get information about the histlog database",
            inputSchema: {
              type: "object",
              properties: {}
            }
          },
          {
            name: "analyze_patterns",
            description: "Analyze command usage patterns and provide insights",
            inputSchema: {
              type: "object",
              properties: {
                days: { type: "integer", description: "Number of days to analyze (default: 30)" }
              }
            }
          },
          {
            name: "query_paths",
            description: "Search and filter filesystem paths tracked by histlog",
            inputSchema: {
              type: "object",
              properties: {
                search_term: { type: "string", description: "Search term to filter paths" },
                type: { type: "string", enum: ["file", "dir", "both"],
                        description: "Filter by path type (default: both)" },
                limit: { type: "integer", description: "Maximum number of results (default: 50)" },
                sort_by: { type: "string", enum: ["path", "usage", "exec_count", "arg_count"],
                           description: "Sort results by (default: usage)" }
              }
            }
          },
          {
            name: "get_path_stats",
            description: "Get statistics about filesystem path usage",
            inputSchema: {
              type: "object",
              properties: {
                limit: { type: "integer", description: "Number of top paths to show (default: 10)" }
              }
            }
          },
          {
            name: "analyze_path_patterns",
            description: "Analyze filesystem path usage patterns and access frequency",
            inputSchema: {
              type: "object",
              properties: {
                days: { type: "integer", description: "Number of days to analyze (default: 30)" },
                depth: { type: "integer", description: "Directory depth to analyze (default: 3)" }
              }
            }
          }
        ]
      }
    }

  when "tools/call"
    tool_name = params["name"]
    tool_args = params["arguments"] || {}

    mcp_log_basic("Tool call: #{tool_name}")
    mcp_log_verbose("Tool args: #{JSON.generate(tool_args)}")

    start_time = Time.now
    case tool_name
    when "query_commands"
      result = mcp_query_commands(tool_args)
    when "get_command_stats"
      result = mcp_get_command_stats(tool_args)
    when "get_database_info"
      result = mcp_get_database_info(tool_args)
    when "analyze_patterns"
      result = mcp_analyze_patterns(tool_args)
    when "query_paths"
      result = mcp_query_paths(tool_args)
    when "get_path_stats"
      result = mcp_get_path_stats(tool_args)
    when "analyze_path_patterns"
      result = mcp_analyze_path_patterns(tool_args)
    else
      mcp_log_basic("Unknown tool requested: #{tool_name}")
      return {
        jsonrpc: "2.0",
        id: id,
        error: {
          code: -32601,
          message: "Unknown tool: #{tool_name}"
        }
      }
    end

    duration = ((Time.now - start_time) * 1000).round(2)
    mcp_log_basic("Tool #{tool_name} completed in #{duration}ms")

    {
      jsonrpc: "2.0",
      id: id,
      result: {
        content: [
          {
            type: "text",
            text: result
          }
        ]
      }
    }

  else
    mcp_log_basic("Unknown method requested: #{method}")
    {
      jsonrpc: "2.0",
      id: id,
      error: {
        code: -32601,
        message: "Unknown method: #{method}"
      }
    }
  end
rescue => e
  mcp_log_basic("Request error: #{e.message}")
  mcp_log_debug("Error backtrace: #{e.backtrace.join('\n')}")
  {
    jsonrpc: "2.0",
    id: id,
    error: {
      code: -32603,
      message: "Internal error: #{e.message}"
    }
  }
end

# MCP Tool Implementations

def mcp_query_commands(args)
  mcp_log_debug("query_commands called with args: #{args.inspect}")

  search_term = args["search_term"]
  limit = args["limit"] || 50
  session_id = args["session"]
  dir_filter = args["dir"]
  failed = args["failed"]
  success = args["success"]
  exitcode = args["exitcode"]
  unique = args["unique"]
  shell_filter = args["shell"]
  private_filter = args["private"]
  imported_filter = args["imported"]
  assisted_filter = args["assisted"]
  today = args["today"]
  week = args["week"]

  db = Histlog::DB.initialize_db
  db.results_as_hash = true

  # Base query with all joins needed for filters
  query = <<~SQL
    SELECT #{unique ? 'DISTINCT' : ''}
      c.id as command_id,
      COALESCE(cmd.command, '') AS cmd_text,
      c.start_time,
      c.exit_code,
      c.is_private,
      c.is_assisted,
      c.duration,
      c.session_id,
      s.pid as pid,
      s.parent_pid as session_parent_pid,
      s.timezone as session_timezone,
      s.start_time as session_start_time,
      sh.path as shell_path,
      t.device as tty_device,
      po.path as old_path,
      pn.path as new_path,
      p_s.path as session_cwd
    FROM commands c
    LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
    LEFT JOIN sessions s ON c.session_id = s.id
    LEFT JOIN shells sh ON s.shell_id = sh.id
    LEFT JOIN ttys t ON s.tty_id = t.id
    LEFT JOIN paths p_s ON s.path_id = p_s.id
    LEFT JOIN paths po ON c.path_old_id = po.id
    LEFT JOIN paths pn ON c.path_new_id = pn.id
    WHERE 1=1
  SQL

  params = []

  # Add all the filter conditions
  if search_term
    query << " AND cmd.command LIKE ?"
    params << "%#{search_term}%"
  end

  if session_id
    query << " AND c.session_id = ?"
    params << session_id
  end

  if dir_filter
    query << " AND (po.path LIKE ? OR pn.path LIKE ?)"
    params << "%#{dir_filter}%"
    params << "%#{dir_filter}%"
  end

  if exitcode
    query << " AND c.exit_code = ?"
    params << exitcode
  elsif failed
    query << " AND c.exit_code != 0"
  elsif success
    query << " AND c.exit_code = 0"
  end

  if shell_filter
    query << " AND sh.path LIKE ?"
    params << "%#{shell_filter}%"
  end

  if private_filter == true
    query << " AND c.is_private = 1"
  elsif private_filter == false
    query << " AND c.is_private = 0"
  end

  if imported_filter == true
    # Imported commands typically have no session_id
    query << " AND c.session_id IS NULL"
  elsif imported_filter == false
    # Live commands have session_id
    query << " AND c.session_id IS NOT NULL"
  end

  if assisted_filter == true
    query << " AND c.is_assisted = 1"
  elsif assisted_filter == false
    query << " AND c.is_assisted = 0"
  end

  if today
    query << " AND date(c.start_time, 'unixepoch') = date('now')"
  elsif week
    query << " AND c.start_time > (strftime('%s', 'now') - 7 * 24 * 3600)"
  end

  query << " ORDER BY c.start_time DESC LIMIT ?"
  params << limit

  mcp_log_debug("Executing SQL query: #{query}")
  mcp_log_debug("Query parameters: #{params.inspect}")

  begin
    results = db.execute(query, params)

    mcp_log_debug("Query returned #{results.length} results")

    if results.empty?
      return "No commands found matching the criteria."
    end

    # Dracula color codes
    # Timestamp: #6272a4, Command: default, Result: ✓ #50fa7b, ✗ #ff5555, Duration: #bd93f9
    output = ""
    results.each do |row|
      timestamp = row['start_time'] ? Time.at(row['start_time']).strftime('%Y-%m-%d %H:%M:%S') : 'Unknown'
      exit_code = row['exit_code'] || 0
      duration = row['duration'] ? sprintf('%.3fs', row['duration']) : 'Unknown'
      status = exit_code == 0 ? "\e[38;5;84m✓\e[0m" : "\e[38;5;203m✗#{exit_code}\e[0m"
      ts_col = "\e[38;5;61m"
      dur_col = "\e[38;5;141m"
      output << "[#{ts_col}#{timestamp}\e[0m] #{row['cmd_text']} #{status} #{dur_col}#{duration}\e[0m\n"
    end
    return output
  ensure
    db.close if db
  end

  def migrate_database
    begin
      # initialize_db will create DB and run migrations (idempotent)
      Histlog::DB.initialize_db
      puts "Database schema updated successfully!"
      puts "You can now use histlog normally."
    rescue => e
      STDERR.puts "Migration failed: #{e.message}"
      STDERR.puts "Try running: histlog maintain --migrate"
      exit 1
    end
  end
end

def mcp_get_command_stats(args)
  limit = args["limit"] || 10

  db = Histlog::DB.initialize_db
  db.results_as_hash = true

  begin
    # Get total commands
    total = db.get_first_value("SELECT COUNT(*) FROM commands")

    # Get most used commands
    most_used = db.execute(<<~SQL, [limit])
      SELECT
        cmd.command,
        COUNT(*) as usage_count,
        AVG(c.duration) as avg_duration
      FROM commands c
      LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
      WHERE cmd.command IS NOT NULL AND cmd.command != ''
      GROUP BY cmd.command
      ORDER BY usage_count DESC
      LIMIT ?
    SQL

    # Get success rate
    success_stats = db.execute(<<~SQL).first
      SELECT
        COUNT(*) as total,
        SUM(CASE WHEN exit_code = 0 THEN 1 ELSE 0 END) as successful,
        AVG(duration) as avg_duration
      FROM commands
      WHERE exit_code IS NOT NULL
    SQL

    output = "=== Command Statistics ===\n\n"
    output << "Total commands: #{total}\n"

    if success_stats && success_stats['total'] > 0
      success_rate = (success_stats['successful'].to_f / success_stats['total'] * 100).round(1)
      avg_duration = success_stats['avg_duration'] ? "#{success_stats['avg_duration'].round(2)}s" : 'Unknown'
      output << "Success rate: #{success_rate}% (#{success_stats['successful']}/#{success_stats['total']})\n"
      output << "Average duration: #{avg_duration}\n"
    end

    output << "\n=== Most Used Commands ===\n"
    most_used.each_with_index do |row, i|
      avg_dur = row['avg_duration'] ? "#{row['avg_duration'].round(2)}s" : 'N/A'
      output << "#{i + 1}. #{row['command']} (#{row['usage_count']} times, avg: #{avg_dur})\n"
    end

    return output
  ensure
    db.close if db
  end
end

def mcp_get_database_info(args)
  db_path = Histlog::DB.path

  unless File.exist?(db_path)
    return "No histlog database found at #{db_path}"
  end

  db = Histlog::DB.initialize_db
  db.results_as_hash = true

  begin
    file_size = File.size(db_path)
    file_size_mb = (file_size / 1024.0 / 1024.0).round(2)
    last_modified = File.mtime(db_path).strftime('%Y-%m-%d %H:%M:%S')

    commands_count = db.get_first_value("SELECT COUNT(*) FROM commands")
    cmd_texts_count = db.get_first_value("SELECT COUNT(*) FROM cmd_texts")
    paths_count = db.get_first_value("SELECT COUNT(*) FROM paths")
    sessions_count = db.get_first_value("SELECT COUNT(*) FROM sessions")

    # Get date range
    date_range = db.execute("SELECT MIN(start_time) as earliest, MAX(start_time) as latest FROM commands WHERE start_time IS NOT NULL").first

    output = "=== Histlog Database Information ===\n\n"
    output << "Database path: #{db_path}\n"
    output << "File size: #{file_size_mb} MB (#{file_size} bytes)\n"
    output << "Last modified: #{last_modified}\n\n"

    output << "=== Record Counts ===\n"
    output << "Commands: #{commands_count}\n"
    output << "Unique command texts: #{cmd_texts_count}\n"
    output << "Tracked paths: #{paths_count}\n"
    output << "Sessions: #{sessions_count}\n\n"

    if date_range && date_range['earliest'] && date_range['latest']
      earliest = Time.at(date_range['earliest']).strftime('%Y-%m-%d %H:%M:%S')
      latest = Time.at(date_range['latest']).strftime('%Y-%m-%d %H:%M:%S')
      output << "=== Date Range ===\n"
      output << "Earliest command: #{earliest}\n"
      output << "Latest command: #{latest}\n"
    end

    return output
  ensure
    db.close if db
  end
end

def mcp_analyze_patterns(args)
  days = args["days"] || 30

  db = Histlog::DB.initialize_db
  db.results_as_hash = true

  begin
    cutoff_time = Time.now.to_i - (days * 24 * 3600)

    # Commands by hour of day
    hourly_pattern = db.execute(<<~SQL, [cutoff_time])
      SELECT
        strftime('%H', start_time, 'unixepoch', 'localtime') as hour,
        COUNT(*) as count
      FROM commands
      WHERE start_time > ? AND start_time IS NOT NULL
      GROUP BY hour
      ORDER BY hour
    SQL

    # Commands by day of week
    daily_pattern = db.execute(<<~SQL, [cutoff_time])
      SELECT
        strftime('%w', start_time, 'unixepoch', 'localtime') as dow,
        COUNT(*) as count
      FROM commands
      WHERE start_time > ? AND start_time IS NOT NULL
      GROUP BY dow
      ORDER BY dow
    SQL

    # Most failed commands
    failed_commands = db.execute(<<~SQL, [cutoff_time, 5])
      SELECT
        cmd.command,
        COUNT(*) as failure_count,
        COUNT(*) * 100.0 / (
          SELECT COUNT(*) FROM commands c2
          LEFT JOIN cmd_texts cmd2 ON c2.cmd_text_id = cmd2.id
          WHERE cmd2.command = cmd.command AND c2.start_time > ?
        ) as failure_rate
      FROM commands c
      LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
      WHERE c.exit_code != 0 AND c.start_time > ?
        AND cmd.command IS NOT NULL AND cmd.command != ''
      GROUP BY cmd.command
      HAVING COUNT(*) > 1
      ORDER BY failure_count DESC
      LIMIT ?
    SQL

    output = "=== Command Usage Patterns (Last #{days} Days) ===\n\n"

    if hourly_pattern.any?
      output << "=== Usage by Hour of Day ===\n"
      hourly_pattern.each do |row|
        hour = row['hour'].to_i
        count = row['count']
        bar = '█' * [(count / 10.0).ceil, 1].max
        output << "#{hour.to_s.rjust(2)}:00 #{bar} #{count}\n"
      end
      output << "\n"
    end

    if daily_pattern.any?
      days_of_week = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
      output << "=== Usage by Day of Week ===\n"
      daily_pattern.each do |row|
        dow = row['dow'].to_i
        count = row['count']
        day_name = days_of_week[dow]
        bar = '█' * [(count / 50.0).ceil, 1].max
        output << "#{day_name.ljust(9)} #{bar} #{count}\n"
      end
      output << "\n"
    end

    if failed_commands.any?
      output << "=== Most Frequently Failed Commands ===\n"
      failed_commands.each do |row|
        output << "#{row['command']} (#{row['failure_count']} failures, #{row['failure_rate'].round(1)}% failure rate)\n"
      end
    end

    return output
  ensure
    db.close if db
  end
end

class HistlogApp
  def run
    # CHECK SCHEMA FIRST - before any command processing
    check_database_schema_compatibility(@argv)

    # Handle help flags first
    if @command == '--help-all'
      Histlog::CLI.show_help(true)
      return
    elsif @command == '-h' || @command == '--help' || @command.nil?
      Histlog::CLI.show_help(false)
      return
    end

    # Define known commands
    known_commands = ['query', 'history', 'sessions', 'import', 'help', 'init', 'paths',
                      'mcp', 'db', '_on_session', '_on_preexec', '_on_postcmd']

    if !known_commands.include?(@command) && !@command.start_with?('-')
      STDERR.puts "Error: Unknown command '#{@command}'"
      STDERR.puts "Use 'histlog help' to see available commands"
      exit 1
    end

    case @command
    when 'help'
      Histlog::CLI.show_help(false)
    when '--help-all'
      Histlog::CLI.show_help(true)
    when 'init'
      Histlog::CLI.handle_init(@argv)
    when 'query'
      Histlog::CLI.query_interactive(@argv)
    when 'stats'
      # stats moved under `histlog db stats` — show brief guidance
      STDERR.puts "The 'stats' command has moved to 'histlog db stats'."
      STDERR.puts "Run: histlog db stats --help"
      exit 1
    when 'history'
      Histlog::CLI.show_history_list(@argv)
    when 'sessions'
      Histlog::CLI.query_sessions(@argv)
    when 'import'
      Histlog::Import.import_shell_history(@argv)
    when 'paths'
      Histlog::CLI.show_paths_command(@argv)
    when 'cleanup'
      STDERR.puts "The 'cleanup' command has moved to 'histlog db cleanup'."
      STDERR.puts "Run: histlog db cleanup --help"
      exit 1
    when 'info'
      STDERR.puts "The 'info' command has moved to 'histlog db info'."
      STDERR.puts "Run: histlog db info --help"
      exit 1
    when 'mcp'
      Histlog::MCP.handle_mcp_server(@argv)
    when 'maintain'
      STDERR.puts "The 'maintain' command has moved to 'histlog db maintain'."
      STDERR.puts "Run: histlog db maintain --help"
      exit 1
    when 'db'
      handle_db_command(@argv)
    when '_on_session'
      handle_on_session
    when '_on_preexec'
      handle_on_preexec
    when '_on_postcmd'
      handle_on_postcmd
    else
      # This case may be triggered by unhandled options passed as commands
      # Re-insert the "command" and let query_interactive handle it
      @argv.unshift(@command)
      query_interactive(@argv)
    end
  end

  def initialize(argv)
    @argv = argv
    @command = @argv.shift
  end

  private

  # Startup schema compatibility check
  def check_database_schema_compatibility(argv)
    db_path = Histlog::DB.path
    return unless db_path && File.exist?(db_path)

    begin
      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true

      unless schema_is_current?(db)
        db.close

        # Check if this is a migration command - allow it to proceed
        if is_migration_command?(argv)
          return
        end

        show_migration_message
        exit 1
      end
    rescue SQLite3::Exception => e
      STDERR.puts "Database error: #{e.message}"
      STDERR.puts "Try running: histlog db migrate"
      exit 1
    ensure
      db&.close
    end
  end

  def schema_is_current?(db)
    cols = db.execute("PRAGMA table_info(sessions)")
    col_names = cols.map { |r| r[1] }
    col_names.include?('start_time')
  end

  def is_migration_command?(argv)
    # Check if this is a migration command that should be allowed to proceed
    # even with an outdated schema
    return true if @command == 'db' && argv.first == 'migrate'
    return true if @command == 'maintain' && argv.include?('--migrate')

    false
  end

  def show_migration_message
    STDERR.puts "=== Database Schema Update Required ==="
    STDERR.puts ""
    STDERR.puts "Your histlog database schema is outdated and needs to be updated."
    STDERR.puts ""
    STDERR.puts "To update your database schema, run:"
    STDERR.puts "  histlog maintain --migrate"
    STDERR.puts ""
    STDERR.puts "This will add any missing columns and update the schema to the latest version."
    STDERR.puts "Your existing data will be preserved."
  end

  # (maintain is provided under `histlog db maintain`)

  # Handle `histlog db <subcommand>` routing
  def handle_db_command(args)
    sub = args.shift
    case sub
    when 'cleanup'
      Histlog::CLI::DB.db_cleanup(args)
    when 'info'
      Histlog::CLI::DB.db_info(args)
    when 'stats'
      Histlog::CLI::DB.db_stats(args)
    when 'integrity'
      Histlog::CLI::DB.db_integrity(args)
    when 'migrate'
      Histlog::CLI::DB.db_migrate(args)
    when 'optimize'
      Histlog::CLI::DB.db_optimize(args)
    when 'full-maintenance'
      Histlog::CLI::DB.db_full_maintenance(args)
    when nil, '--help', '-h', 'help'
      Histlog::CLI::DB.show_db_help
    else
      STDERR.puts "Unknown db subcommand: #{sub}"
      Histlog::CLI::DB.show_db_help
      exit 1
    end
  end

  def handle_on_session
    session_data = {
      shell: ENV['SHELL'],
      tty: Histlog::Utils.get_tty,
      cwd: Dir.pwd,
      pid: Process.pid,
      parent_pid: Process.ppid,
      timezone: Histlog::Utils.get_timezone
    }

    # Store session in SQLite database and get the generated session_id
    session_id = Histlog::DB.store_session(session_data)

    if session_id
      puts session_id
    else
      STDERR.puts "Failed to create session"
      exit 1
    end
  end

  def handle_on_preexec
    cmd = @argv[0]
    session_id = @argv[1]&.to_i # Convert to integer
    dir = Dir.pwd

    # Store command in database
    command_data = {
      session_id: session_id,
      command: cmd,
      cwd: dir
    }

    history_id = Histlog::DB.store_command(command_data)

    if history_id
      puts history_id
    else
      STDERR.puts "Failed to store command"
      exit 1
    end
  end

  def handle_on_postcmd
    history_id = @argv[0]&.to_i # Convert to integer
    duration = @argv[1].to_f / 1000.0 # convert ms to s, keep float
    exit_code = @argv[2]&.to_i

    # Update command with completion data
    Histlog::DB.update_command_completion(history_id, duration.round(3), exit_code)
  end
end

# Main execution
if __FILE__ == $0
  app = HistlogApp.new(ARGV)
  app.run
end

__END__

Here are 10 alternative names for a “do everything” maintenance command, each rated for clarity and discoverability (★★★★★ = best):

histlog db full-maintenance
Very clear, explicit about scope.
★★★★★


go with full-maintenance delete `db all` command

---


update query duration formatting and Exit column width:

```
 bsh ❯ histlog query
Timestamp            Duration Exit Command
-------------------------------------------
2025-09-29 16:31:47    23.0ms ✓    ll
2025-09-29 16:19:35   130.0ms ✓    code ~/bin
2025-09-29 15:56:04     2.0ms ✗127 --:--
2025-09-29 15:28:48   800.0ms ✓    gencomp histlog --subcommands
2025-09-29 15:21:25   11m 12s ✓    bwz
2025-09-29 14:43:46   171.0ms ✓    code
2025-09-29 14:26:36  17m 9.0s ✗127 ssh km1
2025-09-29 10:51:05       N/A /    reload-shell
2025-09-29 10:50:52   811.0ms ✓    gencomp histlog --subcommands
2025-09-29 10:50:23      1.8s ✓    brew upgrade
2025-09-29 10:40:33  1m 22.2s ✗1   brew upgrade
2025-09-29 10:40:19     8.43s ✓    brew install zen-browser
2025-09-29 10:40:05     1.12s ✓    brew update
2025-09-29 10:39:52     4.56s ✓    brew update
2025-09-29 10:39:41     4.09s ✓    brew uninstall arc
2025-09-29 10:10:16   145.0ms ✓    code ~/.config/fish/config.fish
2025-09-29 09:31:26    1h 30m ✓    bash
2025-09-27 08:41:53    16.0ms ✓    bat --plain PropertiesLoader.kt
2025-09-27 08:41:44     1.12s ✗130 bat --plain
2025-09-27 08:41:40    17.0ms ✓    ll
```

keep duration formatting consistent and perfect aligned for humans, keep in mind the different postfixes! make 10 duration format suggestions and rate them.
Exit should always be 4 characters wide for alignment.

---

remove `histlog history` command and implementation - use `histlog query` instead

---

Add a --fuzzy option to query that enables fzf-like fuzzy matching for command text.
For histlog query --command:
It should filter by command text, e.g., --command "git" shows all commands containing "git".
If --command is given without an argument, show a list of unique commands (with usage counts), sorted by frequency, to help users pick or discover commands they’ve run before.
If an argument is given, filter as usual (with fuzzy if --fuzzy is also set).
please add --command, --fuzzy, to query
also add --fuzzy to paths
---
