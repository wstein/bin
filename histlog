#!/usr/bin/env ruby

module Histlog
  module Config
    module_function

    DEFAULT_DB_PATH = File.expand_path('~/.local/share/histlog/histlog.db')

    COMMAND_OPTION_DEFAULTS = {
      paths: {
        files: false,
        dirs: false,
        searchterm: nil,
        regex: false,
        count: false,
        asc: false,
        desc: false,
        sort_by: nil,
        format: nil
      },
      cleanup: {
        verbose: false,
        dry_run: false
      },
      info: {
        verbose: false
      }
    }.freeze

    COLOR_PALETTES = {
      general: {
        reset: "\e[0m"
      },
      paths: {
        exec: "\e[38;5;207m",
        args: "\e[38;5;80m",
        dir_path: "\e[38;5;12m"
      },
      history: {
        timestamp: "\e[38;5;14m",
        duration: "\e[33m",
        status_success: "\e[38;5;84m",
        status_fail: "\e[38;5;203m",
        status_header: "\e[38;5;141m"
      }
    }.freeze

    def command_options(command)
      COMMAND_OPTION_DEFAULTS.fetch(command, {}).dup
    end

    def colors(context = nil)
      palette = COLOR_PALETTES[:general].dup
      palette.merge!(COLOR_PALETTES[context]) if context && COLOR_PALETTES.key?(context)
      palette
    end

    def db_path
      env_path = ENV['HISTLOG_DB']&.strip
      if env_path && !env_path.empty?
        File.expand_path(env_path)
      else
        DEFAULT_DB_PATH
      end
    end
  end

  # CLI command handling module
  module CLI
    module_function

    def build_paths_option_parser(options)
      OptionParser.new do |opts|
        opts.banner = "Usage: histlog paths [--files] [--dirs] [SEARCHTERM] [--regex] [--count] [--asc|--desc] [--sort-by FIELD]"
        opts.on("--files", "Show all unique file paths") { options[:files] = true }
        opts.on("--dirs", "Show all unique directory paths") { options[:dirs] = true }
        opts.on("--regex", "Interpret searchterm as a Ruby regex") { options[:regex] = true }
        opts.on("--count", "Show usage frequency for each path") { options[:count] = true }
        opts.on("--asc", "Order results ascending") { options[:asc] = true }
        opts.on("--desc", "Order results descending") { options[:desc] = true }
        opts.on("--sort-by FIELD", "Sort by exec, args, path, or type") { |field| options[:sort_by] = field }
        opts.on("--plain", "Output only paths, one per line") { options[:format] = 'plain' }
      end
    end

    def show_paths_command(args)
      options = Histlog::Config.command_options(:paths)
      build_paths_option_parser(options).parse!(args)
      # Accept positional searchterm
      if args.length > 0 && !args[0].start_with?('-')
        options[:searchterm] = args.shift
      end

      db_path = Histlog::Utils.get_db_path
      unless File.exist?(db_path)
        puts "No histlog.db found in current directory"
        return
      end
      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true

      types = []
      types << 'file' if options[:files]
      types << 'dir' if options[:dirs]
      if types.empty?
        types = ['file', 'dir']
      end

      order = options[:desc] ? 'DESC' : 'ASC'
      select_count = options[:count] ? ', COUNT(*) as usage_count' : ''
      group_by = options[:count] ? ' GROUP BY path' : ''
      type_cond = types.length == 2 ? "type IN ('f','d')" : "type = '#{types[0] == 'file' ? 'f' : 'd'}'"
      query = "SELECT path, type#{select_count} FROM paths WHERE #{type_cond}"
      params = []
      if options[:searchterm]
        if options[:regex]
          query << " AND path REGEXP ?"
          params << options[:searchterm]
        else
          query << " AND path LIKE ?"
          params << "%#{options[:searchterm]}%"
        end
      end
      query << group_by
      query << " ORDER BY "
      if options[:count]
        query << "usage_count #{order}, path #{order}"
      else
        query << "path #{order}"
      end

      begin
        rows = db.execute(query, params)
      rescue SQLite3::SQLException => e
        if options[:regex] && options[:searchterm] && e.message =~ /no such function: REGEXP/
          # fallback: get all, filter in Ruby
          fallback_query = query.sub(/path REGEXP \?/, '1')
          rows = db.execute(fallback_query, params[0..-2])
          begin
            re = Regexp.new(options[:searchterm])
            rows = rows.select { |row| row['path'] =~ re }
          rescue RegexpError => re_err
            STDERR.puts "Invalid regex: #{re_err.message}"
            rows = []
          end
        else
          raise e
        end
      end

      # Plain output: one path per line (directories end with slash) â€” behave like query --plain
      if options[:format] == 'plain'
        rows.each do |row|
          p = row['path']
          if row['type'] == 'd'
            puts p.end_with?('/') ? p : (p + '/')
          else
            puts p
          end
        end
        return
      end

      # Print header with colored columns (similar style to query interactive output)
      # "Exec" = number of commands executed in this directory (cwd), "Args" = number of times this path was used as a command argument
      # Choose distinct colors for Exec and Args columns
      palette = Histlog::Config.colors(:paths)
      exec_col = palette[:exec] # pink-ish for exec count
      args_col = palette[:args] # green-ish for args count
      # Directory path color (blue 12) â€” trailing slash will be printed in default color
      dir_path_col = palette[:dir_path]
      reset_col = palette[:reset]

      header_fmt = "%6s %6s %s"
      sep = "-------------------------"
      begin
        # Print colored header: Exec and Args colored; Path is default color
        printf("%s%6s%s %s%6s%s %s\n", exec_col, "Exec", reset_col, args_col, "Args", reset_col, "Path")
        puts sep
      rescue Errno::EPIPE
        return
      end

      if rows.empty?
        puts "No results found."
        return
      end

      # For each path, count how many times it was referenced as an arg (args_count)
      # and how many commands were executed in that folder (exec_count)
      rows.each do |row|
        path = row['path']
        is_dir = row['type'] == 'd'
        # Count how many times this path was referenced as an arg
        args_count = db.get_first_value(
          "SELECT COUNT(*) FROM path_args WHERE path_id = (SELECT id FROM paths WHERE path = ?)", path
        )
        # Count how many commands were executed in that folder (cwd_old or cwd_new)
        path_id = db.get_first_value("SELECT id FROM paths WHERE path = ?", path)
        exec_count = db.get_first_value("SELECT COUNT(*) FROM commands WHERE path_old_id = ? OR path_new_id = ?", path_id,
                                        path_id)
        # Colorize counts and type, align columns nicely
        begin
          exec_str = exec_count.to_s.rjust(6)
          args_str = args_count.to_s.rjust(6)
          # Choose coloring for directories vs files
          # Ensure directory paths end with a slash for clarity
          if is_dir
            # Remove any trailing slash before coloring, then append a default-color slash
            base = path.end_with?('/') ? path.chomp('/') : path
            display_path = "#{dir_path_col}#{base}#{reset_col}/"
          else
            display_path = path
          end

          # Print Exec and Args with distinct colors; Path displayed with colored base and default slash
          puts "#{exec_col}#{exec_str}#{reset_col} #{args_col}#{args_str}#{reset_col} #{display_path}"
        rescue Errno::EPIPE
          return
        end
      end
    end

    def build_cleanup_option_parser(options)
      OptionParser.new do |opts|
        opts.banner = "Usage: histlog cleanup [options]"
        opts.on("-v", "--verbose", "Show detailed cleanup progress") { options[:verbose] = true }
        opts.on("-n", "--dry-run", "Show what would be cleaned without making changes") { options[:dry_run] = true }
        opts.on("-h", "--help", "Show this help") do
          puts opts
          exit 0
        end
      end
    end

    # Handle cleanup command
    def handle_cleanup(args)
      options = Histlog::Config.command_options(:cleanup)
      build_cleanup_option_parser(options).parse!(args)

      db_path = Histlog::Utils.get_db_path
      unless File.exist?(db_path)
        puts "No histlog.db found in current directory"
        return
      end

      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true

      if options[:dry_run]
        puts "=== Dry Run: Orphaned Entries Found ==="

        # Count orphaned paths
        orphan_paths = db.get_first_value(<<-SQL)
          SELECT COUNT(*) FROM paths p
          LEFT JOIN commands c1 ON p.id = c1.path_old_id
          LEFT JOIN commands c2 ON p.id = c2.path_new_id
          LEFT JOIN path_args pa ON p.id = pa.path_id
          WHERE c1.id IS NULL AND c2.id IS NULL AND pa.command_id IS NULL
        SQL
        puts "Would remove #{orphan_paths} orphaned paths"

        # Count orphaned cmd_texts
        orphan_cmd_texts = db.get_first_value(<<-SQL)
          SELECT COUNT(*) FROM cmd_texts ct
          LEFT JOIN commands c ON ct.id = c.cmd_text_id
          WHERE c.id IS NULL
        SQL
        puts "Would remove #{orphan_cmd_texts} orphaned cmd_texts"

        # Count orphaned path_args
        orphan_path_args = db.get_first_value(<<-SQL)
          SELECT COUNT(*) FROM path_args pa
          LEFT JOIN paths p ON pa.path_id = p.id
          LEFT JOIN commands c ON pa.command_id = c.id
          WHERE p.id IS NULL OR c.id IS NULL
        SQL
        puts "Would remove #{orphan_path_args} orphaned path_args"

        # Count orphaned ttys, shells, sessions (with error handling)
        begin
          orphan_ttys = db.get_first_value(<<-SQL)
            SELECT COUNT(*) FROM ttys t
            LEFT JOIN sessions s ON t.id = s.tty_id
            WHERE s.id IS NULL
          SQL
          puts "Would remove #{orphan_ttys} orphaned ttys"
        rescue SQLite3::SQLException => e
          puts "Cannot check ttys: #{e.message}"
        end

        begin
          orphan_shells = db.get_first_value(<<-SQL)
            SELECT COUNT(*) FROM shells s
            LEFT JOIN sessions sess ON s.id = sess.shell_id
            WHERE sess.id IS NULL
          SQL
          puts "Would remove #{orphan_shells} orphaned shells"
        rescue SQLite3::SQLException => e
          puts "Cannot check shells: #{e.message}"
        end

        begin
          orphan_sessions = db.get_first_value(<<-SQL)
            SELECT COUNT(*) FROM sessions s
            LEFT JOIN commands c ON s.id = c.session_id
            WHERE c.id IS NULL
          SQL
          puts "Would remove #{orphan_sessions} orphaned sessions"
        rescue SQLite3::SQLException => e
          puts "Cannot check sessions: #{e.message}"
        end

        puts "\nRun 'histlog cleanup' without --dry-run to perform cleanup."
      else
        Histlog::DB.cleanup_orphaned_entries(db, options[:verbose])
      end

      db.close
    end

    def build_info_option_parser(options)
      OptionParser.new do |opts|
        opts.banner = "Usage: histlog info [options]"
        opts.on("-v", "--verbose", "Show detailed system information") { options[:verbose] = true }
        opts.on("-h", "--help", "Show this help") do
          puts opts
          exit 0
        end
      end
    end

    # Handle info command - show database and system information
    def handle_info(args)
      options = Histlog::Config.command_options(:info)
      build_info_option_parser(options).parse!(args)

      db_path = Histlog::Utils.get_db_path

      puts "=== Histlog Database Information ==="
      puts "Database path: #{db_path}"

      if File.exist?(db_path)
        puts "Database exists: Yes"
        puts "Database size: #{Histlog::Utils.format_bytes(File.size(db_path))}"
        puts "Last modified: #{File.mtime(db_path).strftime('%Y-%m-%d %H:%M:%S')}"

        # Connect to get database info
        db = SQLite3::Database.new(db_path)
        db.results_as_hash = true

        # Get table counts
        puts "\n=== Table Statistics ==="
        tables = %w[commands cmd_texts paths path_args sessions shells ttys]
        tables.each do |table|
          begin
            count = db.get_first_value("SELECT COUNT(*) FROM #{table}")
            puts "#{table.ljust(12)}: #{count} records"
          rescue SQLite3::SQLException => e
            puts "#{table.ljust(12)}: (error: #{e.message})"
          end
        end

        # Database settings
        puts "\n=== Database Configuration ==="
        begin
          journal_mode = db.get_first_value("PRAGMA journal_mode")
          synchronous = db.get_first_value("PRAGMA synchronous")
          cache_size = db.get_first_value("PRAGMA cache_size")
          page_size = db.get_first_value("PRAGMA page_size")

          puts "Journal mode: #{journal_mode}"
          puts "Synchronous: #{synchronous}"
          puts "Cache size: #{cache_size} pages"
          puts "Page size: #{page_size} bytes"
        rescue SQLite3::SQLException => e
          puts "Could not retrieve database settings: #{e.message}"
        end

        # Integrity check
        puts "\n=== Database Health ==="
        begin
          integrity = db.get_first_value("PRAGMA integrity_check")
          puts "Integrity check: #{integrity}"
        rescue SQLite3::SQLException => e
          puts "Integrity check failed: #{e.message}"
        end

        if options[:verbose]
          # Show recent activity
          puts "\n=== Recent Activity ==="
          begin
            recent = db.execute(<<-SQL, [Time.now.to_f - 86400])
              SELECT COUNT(*) as count, DATE(start_time, 'unixepoch') as date
              FROM commands
              WHERE start_time > ?
              GROUP BY DATE(start_time, 'unixepoch')
              ORDER BY date DESC
              LIMIT 7
            SQL

            if recent.any?
              puts "Commands executed in last 7 days:"
              recent.each do |row|
                puts "  #{row['date']}: #{row['count']} commands"
              end
            else
              puts "No recent command activity found"
            end
          rescue SQLite3::SQLException => e
            puts "Could not retrieve recent activity: #{e.message}"
          end

          # Show table sizes
          puts "\n=== Detailed Table Information ==="
          tables.each do |table|
            begin
              result = db.execute("SELECT COUNT(*) as count, MIN(created_at) as first, MAX(created_at) as last FROM #{table}").first
              if result && result['count'] > 0
                first_date = result['first'] ? Time.at((result['first'] - 2440587.5) * 86400).strftime('%Y-%m-%d') : 'unknown'
                last_date = result['last'] ? Time.at((result['last'] - 2440587.5) * 86400).strftime('%Y-%m-%d') : 'unknown'
                puts "#{table}:"
                puts "  Records: #{result['count']}"
                puts "  First entry: #{first_date}"
                puts "  Last entry: #{last_date}"
              end
            rescue SQLite3::SQLException => e
              puts "#{table}: (error: #{e.message})"
            end
          end
        end

        db.close
      else
        puts "Database exists: No"
        puts "Run 'histlog help' to get started"
      end

      # System information
      puts "\n=== System Information ==="
      puts "Histlog script: #{File.expand_path(__FILE__)}"
      puts "Ruby version: #{RUBY_VERSION}"
      puts "SQLite3 gem: #{SQLite3::VERSION}" rescue puts "SQLite3 gem: (not available)"
      puts "Operating system: #{RUBY_PLATFORM}"

      # Environment variables
      puts "\n=== Environment ==="
      puts "HISTLOG_DB: #{ENV['HISTLOG_DB'] || '(not set)'}"
      puts "Session ID: #{ENV['__histlog_session_id'] || '(not set)'}"
      puts "Current shell: #{ENV['SHELL'] || '(unknown)'}"
      puts "Current TTY: #{Histlog::Utils.get_tty rescue '(unknown)'}"

      if options[:verbose]
        puts "\n=== Shell Integration Status ==="
        shells = {
          'fish' => '~/.config/fish/config.fish',
          'zsh' => '~/.zshrc',
          'bash' => '~/.bashrc'
        }

        shells.each do |shell, config_file|
          expanded_path = File.expand_path(config_file)
          if File.exist?(expanded_path)
            content = File.read(expanded_path)
            if content.include?('histlog')
              puts "#{shell.capitalize}: âœ“ Integrated (found in #{config_file})"
            else
              puts "#{shell.capitalize}: âœ— Not integrated (#{config_file} exists but no histlog found)"
            end
          else
            puts "#{shell.capitalize}: ? Config file not found (#{config_file})"
          end
        end
      end
    end

    def show_advanced_stats(args)
      OptionParser.new do |opts|
        opts.banner = "Usage: histlog stats [options]"
        opts.on("-h", "--help", "Show this help message") do
          puts opts
          puts
          puts "Shows a summary of command history, most frequent commands, most accessed paths, and common failures."
          puts "Example output:"
          puts "\n=== Command History Summary ==="
          puts "Total commands executed: 56"
          puts "Unique commands: 42"
          puts "Failed commands: 7 (12.5%)"
          puts "Arguments tracked as paths: 12"
          puts "\n=== Most Frequent Commands ==="
          puts "Count  Avg Time Command"
          exit 0
        end
      end.parse!(args)
      # Connect to database
      db_path = Histlog::Utils.get_db_path
      unless File.exist?(db_path)
        puts "No histlog.db found in current directory"
        return
      end

      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true

      puts "=== Command History Summary ==="
      puts

      # Basic stats
      total_commands = db.execute("SELECT COUNT(*) as count FROM commands")[0]['count']
      unique_commands = db.execute("SELECT COUNT(*) as count FROM cmd_texts")[0]['count']
      failed_commands = db.execute("SELECT COUNT(*) as count FROM commands WHERE exit_code != 0")[0]['count']
      tracked_paths = db.execute("SELECT COUNT(*) as count FROM path_args")[0]['count']

      puts "Total commands executed: #{total_commands}"
      puts "Unique commands: #{unique_commands}"
      puts "Failed commands: #{failed_commands} (#{(failed_commands.to_f / total_commands * 100).round(2)}%)" if total_commands > 0
      puts "Arguments tracked as paths: #{tracked_paths}"

      if total_commands > 0
        # Most used commands
        puts "\n=== Most Frequent Commands ==="
        frequent_commands = db.execute(<<-SQL)
          SELECT
            cmd_texts.command AS cmd_text,
            COUNT(*) as count,
            AVG(c.duration) as avg_duration,
            MAX(c.created_at) as last_seen
          FROM commands c
          JOIN cmd_texts ON c.cmd_text_id = cmd_texts.id
          WHERE c.duration IS NOT NULL
          GROUP BY cmd_texts.id
          ORDER BY count DESC
          LIMIT 10
        SQL

        if frequent_commands.any?
          puts "%-6s %-8s %-50s %-s" % ["Count", "Avg Time", "Command", "Last Used"]
          puts "-" * 85
          frequent_commands.each do |cmd|
            avg_time = Histlog::Utils.format_duration(cmd['avg_duration'])
            last_used = Histlog::Utils.format_time(cmd['last_seen'])
            command_text = Histlog::Utils.truncate_command(cmd['cmd_text'], 45)
            puts "% -6s %-8s %-50s %-s" % [cmd['count'], avg_time, command_text, last_used]
          end
        end

        # Most accessed paths
        puts "\n=== Most Accessed Paths ==="
        frequent_paths = db.execute(<<-SQL)
          SELECT
            p.path,
            p.type,
            COUNT(*) as usage_count
          FROM path_args ca
          JOIN paths p ON ca.path_id = p.id
          GROUP BY p.path
          ORDER BY usage_count DESC
          LIMIT 10
        SQL

        if frequent_paths.any?
          puts "%-6s %-4s %-s" % ["Count", "Type", "Path"]
          puts "-" * 60
          frequent_paths.each do |path_data|
            type_name = path_data['type'] == 'd' ? 'dir' : 'file'
            puts "%-6s %-4s %-s" % [path_data['usage_count'], type_name, path_data['path']]
          end
        else
          puts "No path arguments tracked yet"
        end

        # Most common failures
        if failed_commands > 0
          puts "\n=== Most Common Failures ==="
          common_failures = db.execute(<<-SQL)
            SELECT
              cmd_texts.command AS cmd_text,
              c.exit_code,
              COUNT(*) as count,
              MAX(c.created_at) as last_failure
            FROM commands c
            JOIN cmd_texts ON c.cmd_text_id = cmd_texts.id
            WHERE c.exit_code != 0
            GROUP BY cmd_texts.id, c.exit_code
            ORDER BY count DESC
            LIMIT 10
          SQL

          puts "%-6s %-4s %-50s %-s" % ["Count", "Exit", "Command", "Last Failure"]
          puts "-" * 85
          common_failures.each do |failure|
            command_text = Histlog::Utils.truncate_command(failure['cmd_text'], 45)
            last_fail = Histlog::Utils.format_time(failure['last_failure'])
            puts "%-6s %-4s %-50s %-s" % [failure['count'], failure['exit_code'], command_text, last_fail]
          end
        end
      end
      db.close
    end

    def show_history_list(args)
      options = {
        limit: 20,
        show_all: false,
        show_paths: false,
        filter_command: nil,
        filter_path: nil
      }

      OptionParser.new do |opts|
        opts.banner = "Usage: histlog history [options]"
        opts.on("-l", "--limit N", Integer,
                "Number of recent commands to show (default: 20). Negative N returns the first (earliest) N results.") { |n|
          options[:limit] = n
        }
        opts.on("-a", "--all", "Show all commands (ignore limit)") { options[:show_all] = true }
        opts.on("-p", "--paths", "Show path arguments for commands") { options[:show_paths] = true }
        opts.on("-c", "--command PATTERN", "Filter commands containing pattern") { |p| options[:filter_command] = p }
        opts.on("-d", "--dir PATH", "Filter commands that used specific directory") { |p|
          options[:filter_path] = File.expand_path(p)
        }
      end.parse!(args)

      db_path = Histlog::Utils.get_db_path
      unless File.exist?(db_path)
        puts "No histlog.db found in current directory"
        return
      end

      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true

      where_conditions = []
      params = []

      if options[:filter_command]
        where_conditions << "cmd.command LIKE ?"
        params << "%#{options[:filter_command]}%"
      end

      if options[:filter_path]
        where_conditions << "(p_old.path = ? OR p_new.path = ?)"
        params << options[:filter_path] << options[:filter_path]
      end

      where_clause = where_conditions.empty? ? "" : "WHERE #{where_conditions.join(' AND ')}"
      limit_clause = options[:show_all] ? "" : "LIMIT #{options[:limit]}"

      recent_commands_query = <<-SQL
        SELECT
          c.id as command_id,
          cmd.command AS cmd_text,
          c.start_time,
          c.duration,
          c.exit_code,
          p_old.path as cwd_old,
          p_new.path as cwd_new
        FROM commands c
        JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
        LEFT JOIN paths p_old ON c.path_old_id = p_old.id
        LEFT JOIN paths p_new ON c.path_new_id = p_new.id
        #{where_clause}
        ORDER BY c.start_time DESC
        #{limit_clause}
      SQL

      recent_commands = db.execute(recent_commands_query, params)

      if recent_commands.empty?
        puts "No commands found."
        return
      end

      puts "%-6s %-8s %-4s %-50s %-s" % ["ID", "Duration", "Exit", "Command", "Time"]
      puts "-" * 90

      recent_commands.each do |cmd|
        duration = Histlog::Utils.format_duration(cmd['duration'])
        exit_code = cmd['exit_code'] || 'N/A'
        command_text = Histlog::Utils.truncate_command(cmd['cmd_text'], 45)
        time = cmd['start_time'] ? Time.at(cmd['start_time']).strftime('%Y-%m-%d %H:%M:%S') : 'N/A'

        exit_display = case exit_code
                       when 0 then "  âœ“ "
                       when 'N/A' then " ? "
                       else " âœ—#{exit_code}"
                       end

        puts "%-6s %-8s %-4s %-50s %-s" % [cmd['command_id'], duration, exit_display, command_text, time]

        if options[:show_paths]
          path_args = db.execute(<<-SQL, [cmd['command_id']])
            SELECT p.path, p.type, ca.arg_position
            FROM path_args ca
            JOIN paths p ON ca.path_id = p.id
            WHERE ca.command_id = ?
            ORDER BY ca.arg_position
          SQL

          if path_args.any?
            path_args.each do |path_arg|
              type_indicator = path_arg['type'] == 'd' ? 'ðŸ“' : 'ðŸ“„'
              puts "       #{' ' * 8}     #{type_indicator} [#{path_arg['arg_position']}] #{path_arg['path']}"
            end
          end
        end
      end
      db.close
    end

    def query_sessions(args)
      # Connect to database
      db_path = Histlog::Utils.get_db_path
      unless File.exist?(db_path)
        puts "No histlog.db found in current directory"
        return
      end

      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true

      puts "=== Sessions Summary ==="
      puts

      # Count sessions
      session_count = db.execute("SELECT COUNT(*) as count FROM sessions")[0]['count']
      puts "Total sessions: #{session_count}"

      if session_count > 0
        # Latest sessions
        puts "\n=== Recent Sessions ==="
        puts "%-10s %-15s %-15s %-10s %-30s %-s" % ["Session", "Shell", "TTY", "Timezone", "Created", "Working Directory"]
        puts "-" * 160

        latest_sessions = db.execute(<<-SQL)
          SELECT
            s.id as session_id,
            sh.path as shell_path,
            t.device as tty_device,
            s.timezone,
            s.created_at,
            p.path as working_directory
    FROM sessions s
    LEFT JOIN shells sh ON s.shell_id = sh.id
    LEFT JOIN ttys t ON s.tty_id = t.id
    LEFT JOIN paths p ON s.path_id = p.id
          ORDER BY s.created_at DESC
          LIMIT 10
        SQL

        latest_sessions.each do |session|
          shell_name = session['shell_path'] ? File.basename(session['shell_path']) : 'unknown'
          tty_short = session['tty_device']&.gsub('/dev/', '') || 'unknown'
          timezone = session['timezone'] || 'unknown'
          created_time = Histlog::Utils.format_time(session['created_at'])

          puts "%-10s %-15s %-15s %-10s %-30s %-s" % [
            session['session_id'],
            shell_name,
            tty_short,
            timezone,
            created_time,
            session['working_directory']
          ]
        end

        # Session analysis
        puts "\n=== Session Analysis ==="
        shells = db.execute(<<-SQL)
          SELECT sh.path, COUNT(*) as count
    FROM sessions s
    LEFT JOIN shells sh ON s.shell_id = sh.id
          GROUP BY sh.id, sh.path
          ORDER BY count DESC
        SQL

        puts "Shells used:"
        shells.each do |shell_data|
          shell_name = shell_data['path'] ? File.basename(shell_data['path']) : 'unknown'
          puts "  #{shell_name}: #{shell_data['count']} sessions"
        end

        # TTY analysis
        puts "\nTTYs used:"
        ttys = db.execute(<<-SQL)
          SELECT t.device, COUNT(*) as count
    FROM sessions s
    LEFT JOIN ttys t ON s.tty_id = t.id
          GROUP BY t.id, t.device
          ORDER BY count DESC
        SQL

        ttys.each do |tty_data|
          tty_name = tty_data['device']&.gsub('/dev/', '') || 'unknown'
          puts "  #{tty_name}: #{tty_data['count']} sessions"
        end
      end

      db.close
    end

    def query_interactive(args)
      # Remove stray opts.on lines; these should be inside OptionParser.new do |opts| ... end
      # Parse command line options
      options = {
        search_term: nil,
        session: false,
        session_id: nil,
        current: false,
        dir: false,
        dir_path: nil,
        failed: false,
        success: false,
        exit_code: nil,
        today: false,
        yesterday: false,
        week: false,
        since: nil,
        after: nil,
        has_paths: false,
        path: nil,
        long: false,
        quick: false,
        slow: false,
        private: false,
        no_private: false,
        assisted: false,
        no_assisted: false,
        fast: false,
        instant: false,
        background: false,
        rare: false,
        frequent: false,
        unique: false,
        shell: nil,
        tty: nil,
        with_args: false,
        no_args: false,
        arg_count: nil,
        limit: nil,
        format: nil
      }

      OptionParser.new do |opts|
        opts.on("--regex PATTERN", "Filter commands using Ruby or SQLite regex (PATTERN)") do |pattern|
          options[:regex] = true
          options[:search_term] = pattern
        end
        opts.banner = "Usage: histlog query [search] [options]"
        opts.on("--delete", "Delete matching commands after confirmation") { options[:delete] = true }
        opts.on("--force-delete", "Delete matching commands without confirmation") { options[:force_delete] = true }
        opts.on("--asc", "Sort results in ascending order (oldest first) - DEFAULT") { options[:asc] = true }
        opts.on("--desc", "Sort results in descending order (newest first)") { options[:desc] = true }

        # Search and basic filters
        opts.on("--session [ID]",
                "Commands from current session (requires __histlog_session_id) or specific session ID") do |id|
          options[:session] = true
          options[:session_id] = id.to_i if id
        end

        opts.on("--dir [PATH]", "Commands executed in current or specific directory") do |path|
          options[:dir] = true
          options[:dir_path] = path
        end

        # Status filters
        opts.on("--failed", "Only failed commands (exit_code != 0)") { options[:failed] = true }
        opts.on("--success", "Only successful commands (exit_code = 0)") { options[:success] = true }
        opts.on("--exit CODE", Integer, "Commands with specific exit code") { |code| options[:exit_code] = code }

        # Time filters
        opts.on("--today", "Commands from today") { options[:today] = true }
        opts.on("--yesterday", "Commands from yesterday") { options[:yesterday] = true }
        opts.on("--week", "Commands from this week") { options[:week] = true }
        opts.on("--since TIME",
                "Commands since X time ago. Shorthand: 120s, 40m, 4h, 7d, 2w. Combined: 1h30m, 2h 15m. Decimal: 1.5h. Also accepts absolute timestamps: '2025-09-27 19:52' or '19:52'.") { |time|
          options[:since] = time
        }
        opts.on("--after DATE", "Commands after date (YYYY-MM-DD)") { |date| options[:after] = date }

        # Path filters
        opts.on("--has-paths", "Commands that touched filesystem paths") { options[:has_paths] = true }
        opts.on("--path PATH", "Commands that accessed specific path") { |path| options[:path] = path }

        # Performance filters
        opts.on("--long", "Commands longer than 50 characters") { options[:long] = true }
        opts.on("--quick", "Commands that ran quickly (< 1s)") { options[:quick] = true }
        opts.on("--slow", "Commands that ran slowly (> 10s)") { options[:slow] = true }
        opts.on("--fast", "Commands that ran very quickly (< 100ms)") { options[:fast] = true }
        opts.on("--instant", "Commands that ran instantly (< 10ms)") { options[:instant] = true }
        opts.on("--background", "Long-running commands (> 60s)") { options[:background] = true }

        # Frequency filters
        opts.on("--rare", "Commands used < 3 times") { options[:rare] = true }
        opts.on("--frequent", "Commands used > 10 times") { options[:frequent] = true }
        opts.on("--unique", "Remove duplicate commands (show only first occurrence)") { options[:unique] = true }

        # Context filters
        opts.on("--shell SHELL", "Commands from specific shell") { |shell| options[:shell] = shell }
        opts.on("--tty TTY", "Commands from specific TTY device") { |tty| options[:tty] = tty }

        # Argument filters
        opts.on("--with-args", "Commands that had arguments") { options[:with_args] = true }
        opts.on("--no-args", "Commands without arguments") { options[:no_args] = true }
        opts.on("--arg-count N", Integer, "Commands with exactly N arguments") { |n| options[:arg_count] = n }

        # Private command filters
        opts.on("--private", "Show only private commands (started with space)") { options[:private] = true }
        opts.on("--no-private", "Explicitly exclude private commands") { options[:no_private] = true }

        # Imported filters
        opts.on("--imported", "Show only imported commands (no session)") { options[:imported] = true }
        opts.on("--no-imported", "Exclude imported commands (require a session)") { options[:no_imported] = true }

        # Environment filters
        opts.on("--assisted", "Only show AI-assisted commands") { options[:assisted] = true }
        opts.on("--no-assisted", "Exclude AI-assisted commands") { options[:no_assisted] = true }

        # Output format
        opts.on("--json", "Output as JSON with full metadata") { options[:format] = 'json' }
        opts.on("--yaml", "Output as YAML with full metadata") { options[:format] = 'yaml' }
        opts.on("--plain", "Output only commands, one per line") { options[:format] = 'plain' }
        opts.on("--format FORMAT", "Output format (json, yaml, fish, zsh, nu, bash, powershell, plain)") { |f|
          options[:format] = f.downcase
        }
        opts.on("--limit N", Integer,
                "Limit number of results (default: no limit). Negative N returns the first (earliest) N results (e.g. --limit -4 returns the first 4 commands today).") { |n|
          options[:limit] = n
        }

        opts.on("-h", "--help", "Show this help") do
          puts opts
          exit 0
        end
      end.parse!(args)

      # Get search term from remaining arguments
      options[:search_term] = args.join(' ') unless args.empty?

      # Build SQL query based on options
      execute_interactive_query(options)
    end

    def execute_interactive_query(options)
      # Read-only queries should not create or mutate the database.
      db_path = Histlog::Utils.get_db_path
      unless File.exist?(db_path)
        STDERR.puts "No histlog.db found in current directory"
        return
      end

      # Open the existing database for read-only queries
      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true
      begin
        # Helper: parse time span strings into seconds.
        # Accepts relative shorthand: 120s, 40m, 4h, 7d, 2w and combined tokens like '1h30m'
        # Accepts verbose forms: '1 hour', '30 minutes', possibly combined ('1 hour 30 minutes')
        # Also accepts absolute timestamps in these example patterns:
        #  - '2025-09-27 19:52:17'
        #  - '2025-09-27 19:52'
        #  - '09-27 19:52' (assumes current year, if in future uses previous year)
        #  - '19:52' (assumes today; if in future uses yesterday)
        # Returns:
        #  - Numeric seconds (>= 0) representing the duration from parsed time to now
        #  - -1 if parsed absolute timestamp is in the future
        #  - nil if parsing fails
        def parse_time_span_to_seconds(str)
          return nil if str.nil?

          raw = str.strip
          s = raw.downcase
          now = Time.now

          # Try absolute timestamp parsing with various formats
          timestamp_formats = [
            '%Y-%m-%d %H:%M:%S',
            '%Y-%m-%d %H:%M',
            '%Y-%m-%d',
            '%m-%d %H:%M:%S',
            '%m-%d %H:%M',
            '%m-%d',
            '%H:%M:%S',
            '%H:%M'
          ]

          timestamp_formats.each do |fmt|
            begin
              parsed = nil
              if fmt.start_with?('%Y')
                parsed = Time.strptime(raw, fmt) rescue nil
              elsif fmt.start_with?('%m-%d')
                # attach current year
                try = Time.strptime("#{now.year}-#{raw}", "%Y-#{fmt}") rescue nil
                parsed = try
                # if parsed is in the future, try previous year
                if parsed && parsed > now
                  parsed = Time.new(parsed.year - 1, parsed.month, parsed.day, parsed.hour, parsed.min, parsed.sec)
                end
              else
                # time-only formats: assume today
                try = Time.strptime(raw, fmt) rescue nil
                if try
                  parsed = Time.new(now.year, now.month, now.day, try.hour, try.min, try.sec)
                  # if the parsed time is in the future, assume yesterday
                  if parsed > now
                    parsed -= 86400
                  end
                end
              end

              if parsed
                seconds = (now.to_f - parsed.to_f)
                return -1 if seconds < 0

                return seconds
              end
            rescue ArgumentError
              # try next format
            end
          end

          # Otherwise parse relative tokens (combined and decimals)
          total = 0.0
          matched = false

          # Shorthand tokens like '1.5h', repeated tokens '1h30m'
          s.scan(/(\d+(?:\.\d+)?)\s*([smhdw])/) do |num_s, unit|
            num = num_s.to_f
            matched = true
            case unit
            when 's' then total += num
            when 'm' then total += num * 60
            when 'h' then total += num * 3600
            when 'd' then total += num * 86400
            when 'w' then total += num * 7 * 86400
            end
          end

          # Verbose tokens like '1 hour', '30 minutes'
          s.scan(/(\d+(?:\.\d+)?)\s*(second|seconds|minute|minutes|hour|hours|day|days|week|weeks)/) do |num_s, word|
            num = num_s.to_f
            matched = true
            case word
            when 'second', 'seconds' then total += num
            when 'minute', 'minutes' then total += num * 60
            when 'hour', 'hours' then total += num * 3600
            when 'day', 'days' then total += num * 86400
            when 'week', 'weeks' then total += num * 7 * 86400
            end
          end

          return nil unless matched

          total % 1 == 0 ? total.to_i : total
        end
        # Build the base query
        query_parts = []
        params = []

        # Base SELECT with joins
        base_query = <<-SQL
        SELECT
          c.id AS command_id,
          COALESCE(cmd.command, '') AS cmd_text,
          c.created_at,
          c.start_time,
          c.duration,
          c.exit_code,
          c.is_private,
          c.is_assisted,
          p_old.path as cwd_old,
          p_new.path as cwd_new,
          s.id as session_id,
          s.pid,
          sh.path as shell_path,
          t.device as tty_device
      FROM commands c
      LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
          LEFT JOIN sessions s ON c.session_id = s.id
          LEFT JOIN shells sh ON s.shell_id = sh.id
          LEFT JOIN ttys t ON s.tty_id = t.id
          LEFT JOIN paths p_old ON c.path_old_id = p_old.id
          LEFT JOIN paths p_new ON c.path_new_id = p_new.id
        SQL

        # Add WHERE conditions based on options
        where_conditions = []

        # Search term filter (optional)
        if options[:regex] && options[:search_term] && !options[:search_term].empty?
          where_conditions << "cmd.command REGEXP ?"
          params << options[:search_term]
        elsif options[:search_term] && !options[:search_term].empty?
          where_conditions << "cmd.command LIKE ?"
          params << "%#{options[:search_term]}%"
        end

        # Session filter
        if options[:session]
          if options[:session_id]
            where_conditions << "s.id = ?"
            params << options[:session_id]
          else
            # Find current session from environment variable set by shell integration
            # Read current session id from environment (new name matching table `sessions`)
            current_session_id = ENV['__histlog_session_id']
            if current_session_id
              where_conditions << "s.id = ?"
              params << current_session_id.to_i
            else
              # If no current session ID, return no results
              where_conditions << "s.id IS NULL"
            end
          end
        end

        # Directory filter
        if options[:dir]
          dir_path = options[:dir_path] || Dir.pwd
          abs_dir = File.expand_path(dir_path)
          where_conditions << "p_old.path = ?"
          params << abs_dir
        end

        # Status filters
        if options[:failed]
          where_conditions << "c.exit_code != 0"
        elsif options[:success]
          where_conditions << "c.exit_code = 0"
        elsif options[:exit_code]
          where_conditions << "c.exit_code = ?"
          params << options[:exit_code]
        end

        # Private command filters
        if options[:private]
          where_conditions << "c.is_private = 1"
        elsif options[:no_private]
          where_conditions << "c.is_private = 0"
          # Default: show private commands unless explicitly excluded
        end

        # AI-assisted command filters
        if options[:assisted]
          where_conditions << "c.is_assisted = 1"
        elsif options[:no_assisted]
          where_conditions << "c.is_assisted != 1"
          # Default: show all commands regardless of AI assistance unless explicitly filtered
        end

        # Imported / non-imported filtering
        if options[:imported]
          # Imported commands have no session ID
          where_conditions << "c.session_id IS NULL"
        elsif options[:no_imported]
          # Only show commands that belong to sessions
          where_conditions << "c.session_id IS NOT NULL"
        end

        # Time filters
        if options[:today]
          # Convert start of today to Julian day
          today_start_unix = Time.new(Time.now.year, Time.now.month, Time.now.day).to_f
          today_start_julian = (today_start_unix / 86400.0) + 2440587.5
          where_conditions << "c.created_at >= ?"
          params << today_start_julian
        elsif options[:yesterday]
          # Start of yesterday (00:00) and start of today (exclusive upper bound)
          today_start_unix = Time.new(Time.now.year, Time.now.month, Time.now.day).to_f
          yesterday_start_unix = (Time.new(Time.now.year, Time.now.month, Time.now.day) - 86400).to_f
          yesterday_start_julian = (yesterday_start_unix / 86400.0) + 2440587.5
          today_start_julian = (today_start_unix / 86400.0) + 2440587.5
          where_conditions << "c.created_at >= ?"
          params << yesterday_start_julian
          where_conditions << "c.created_at < ?"
          params << today_start_julian
        elsif options[:week]
          # Get start of week (Monday)
          now = Time.now
          days_since_monday = (now.wday + 6) % 7 # Convert Sunday=0 to Monday=0
          week_start_unix = (Time.new(now.year, now.month, now.day) - (days_since_monday * 86400)).to_f
          week_start_julian = (week_start_unix / 86400.0) + 2440587.5
          where_conditions << "c.created_at >= ?"
          params << week_start_julian
        elsif options[:since]
          # Parse relative time from flexible formats like '120s', '40m', '4h', '7d', '2w' or verbose '1 hour'
          seconds = Histlog::Utils.parse_time_span_to_seconds(options[:since])
          if seconds.nil?
            STDERR.puts "Invalid time span for --since: '#{options[:since]}'. Use formats like 120s, 40m, 4h, 7d, 2w or '1 hour', or absolute timestamps like '2025-09-27 19:52'."
            db.close if db
            exit 2
          end
          if seconds < 0
            STDERR.puts "The absolute timestamp provided for --since is in the future: '#{options[:since]}'"
            db.close if db
            exit 2
          end
          since_unix = Time.now.to_f - seconds
          since_julian = (since_unix / 86400.0) + 2440587.5
          where_conditions << "c.created_at >= ?"
          params << since_julian
        elsif options[:after]
          # Parse date
          begin
            after_unix = Time.parse(options[:after]).to_f
            after_julian = (after_unix / 86400.0) + 2440587.5
            where_conditions << "c.created_at >= ?"
            params << after_julian
          rescue ArgumentError
            STDERR.puts "Invalid date format: #{options[:after]}"
            return
          end
        end

        # Performance filters (duration-based)
        if options[:quick]
          where_conditions << "c.duration < 1.0"
        elsif options[:slow]
          where_conditions << "c.duration > 10.0"
        elsif options[:fast]
          where_conditions << "c.duration < 0.1"
        elsif options[:instant]
          where_conditions << "c.duration < 0.01"
        elsif options[:background]
          where_conditions << "c.duration > 60.0"
        end

        # Command length filters
        if options[:long]
          where_conditions << "LENGTH(cmd.command) > 50"
        end

        # Shell and TTY filters
        if options[:shell]
          where_conditions << "sh.path LIKE ?"
          params << "%#{options[:shell]}%"
        end

        if options[:tty]
          where_conditions << "t.device LIKE ?"
          params << "%#{options[:tty]}%"
        end

        # Path-related filters
        if options[:has_paths]
          base_query += " JOIN path_args a ON c.id = a.command_id"
          where_conditions << "a.path_id IS NOT NULL"
        end

        if options[:path]
          base_query += " JOIN path_args a ON c.id = a.command_id JOIN paths p_arg ON a.path_id = p_arg.id"
          where_conditions << "p_arg.path LIKE ?"
          params << "%#{options[:path]}%"
        end

        # Argument count filters
        if options[:with_args]
          # Select commands with at least one argument (not just path_args)
          where_conditions << "(LENGTH(TRIM(cmd.command)) - LENGTH(REPLACE(TRIM(cmd.command), ' ', ''))) > 0"
        elsif options[:no_args]
          # Select commands with no arguments (not just no path_args)
          where_conditions << "(LENGTH(TRIM(cmd.command)) - LENGTH(REPLACE(TRIM(cmd.command), ' ', ''))) = 0"
        elsif options[:arg_count]
          # Select commands with exactly N arguments (argument count = number of spaces)
          where_conditions << "(LENGTH(TRIM(cmd.command)) - LENGTH(REPLACE(TRIM(cmd.command), ' ', ''))) = ?"
          params << options[:arg_count]
        end

        # Frequency filters require subqueries
        if options[:rare] || options[:frequent]
          frequency_subquery = <<-SQL
      (SELECT COUNT(*) FROM commands c2 WHERE c2.cmd_text_id = c.cmd_text_id)
          SQL

          if options[:rare]
            where_conditions << "#{frequency_subquery} < 3"
          elsif options[:frequent]
            where_conditions << "#{frequency_subquery} > 10"
          end
        end

        # Unique filter - show only first occurrence of each command (deduplication)
        if options[:unique]
          where_conditions << "c.id = (SELECT MIN(c2.id) FROM commands c2 WHERE c2.cmd_text_id = c.cmd_text_id)"
        end

        # Combine query parts
        full_query = base_query
        if where_conditions.any?
          full_query += " WHERE " + where_conditions.join(" AND ")
        end

        # Add GROUP BY to handle potential duplicates from JOINs, but preserve individual command executions
        full_query += " GROUP BY c.id"

        # Order by start_time (actual execution time), then created_at, then command_id for strict chronological order
        # For limited results, we need to get the most recent N commands first, then apply user's sort preference
        if options[:limit]
          # If limit is negative, user asked for the earliest N results (first N)
          if options[:limit] < 0
            full_query += " ORDER BY c.start_time ASC, c.created_at ASC, c.id ASC"
          else
            # Always get the most recent N commands first
            full_query += " ORDER BY c.start_time DESC, c.created_at DESC, c.id DESC"
          end
        else
          # For unlimited results, apply user's sort preference directly (default: oldest first - chronological)
          if options[:desc]
            order = "DESC"
          else
            order = "ASC" # Default behavior - chronological order
          end
          full_query += " ORDER BY c.start_time #{order}, c.created_at #{order}, c.id #{order}"
        end

        # We'll handle LIMIT at execution time to account for any rows filtered out in Ruby
        # (for example, excluding currently-running commands where duration IS NULL).
        # Do not append a SQL LIMIT here; instead we'll iteratively fetch enough rows below.

        # Execute query. If a limit was requested, do an iterative fetch that
        # over-requests rows (exponential backoff) until we have enough non-running
        # rows or there are no more rows to fetch. This avoids returning fewer
        # results than the requested limit when some rows are filtered out in Ruby.
        begin
          if options[:limit]
            raw_limit = options[:limit]
            # Negative limit now means: return the first (earliest) N results.
            # Use absolute value for requested count; start at offset 0.
            requested = raw_limit < 0 ? raw_limit.abs : raw_limit
            start_offset = 0
            current_limit = [requested * 2, 50].max
            max_limit = 5000
            results = []
            offset = start_offset

            loop do
              # Build limited query for this iteration
              limited_query = full_query + " LIMIT #{current_limit} OFFSET #{offset}"
              all_results = db.execute(limited_query, params)

              # Filter out running commands (duration nil)
              filtered = all_results.reject { |row| row['duration'].nil? }

              # Append unique new results
              results.concat(filtered)

              # If we have enough results, stop
              break if results.size >= requested

              # If fewer rows were returned than requested in SQL, no more data available
              break if all_results.size < current_limit

              # Otherwise, advance offset and increase limit to fetch more rows
              offset += current_limit
              current_limit = [current_limit * 2, max_limit].min
              # If we've reached the max_limit, avoid infinite loop
              break if current_limit >= max_limit
            end

            # Truncate to requested size
            results = results.take(requested)
            # When we fetched limited results we used ORDER BY DESC to pick the most recent set.
            # Ensure display order is chronological (oldest -> newest) unless the user explicitly
            # requested descending output with --desc. Use explicit sort by start_time to be robust.
            unless options[:desc]
              results = results.sort_by { |r| r['start_time'] || 0 }
            end
          else
            all_results = db.execute(full_query, params)
            results = all_results.reject do |row|
              # Exclude if duration is null (still running)
              row['duration'].nil?
            end
          end
        rescue SQLite3::SQLException => e
          # Fallback: if REGEXP is not supported, filter in Ruby
          if options[:regex] && options[:search_term] && e.message =~ /no such function: REGEXP/
            results = db.execute(full_query.sub(/cmd\.command REGEXP \?/, '1'), params[0..-2]) # get all
            begin
              re = Regexp.new(options[:search_term])
              results = results.select { |row| row['cmd_text'] =~ re }
            rescue RegexpError => re_err
              STDERR.puts "Invalid regex: #{re_err.message}"
              results = []
            end
          else
            raise e
          end
        end

        # Handle delete options
        if options[:delete] || options[:force_delete]
          if results.empty?
            puts "No matching commands to delete."
            db.close
            return
          end
          # List matching commands
          puts "Matching commands to delete:"
          results.each do |row|
            puts "  [ID: #{row['command_id']}] #{row['cmd_text']}"
          end
          if options[:delete]
            print "Are you sure you want to delete these commands? Type 'yes' to confirm: "
            confirm = STDIN.gets.strip
            unless confirm.downcase == 'yes'
              puts "Aborted. No commands deleted."
              db.close
              return
            end
          end
          # Delete matching commands
          ids = results.map { |row| row['command_id'] }
          ids.each do |id|
            db.execute("DELETE FROM commands WHERE id = ?", [id])
            db.execute("DELETE FROM path_args WHERE command_id = ?", [id])
          end
          puts "Deleted #{ids.size} commands."

          # Cleanup orphaned entries after deletion
          Histlog::DB.cleanup_orphaned_entries(db)
          db.close
          return
        end

        # Output results
        if options[:format]
          Histlog::Reporting.output_formatted_results(results, options)
        else
          Histlog::Reporting.output_interactive_results(results, options)
        end
      rescue SQLite3::Exception => e
        STDERR.puts "Database error: #{e.message}"
      ensure
        db.close if db
      end
    end
  end
end

# Remove old function definitions - these are now in Histlog::CLI

module Histlog
  # Output formatting and reporting module
  module Reporting
    module_function

    # Output results in various formats
    def output_formatted_results(results, options)
      format = options[:format]

      # Validate format
      valid_formats = ['json', 'yaml', 'fish', 'zsh', 'nu', 'bash', 'powershell', 'plain']
      unless valid_formats.include?(format)
        STDERR.puts "Error: Unsupported format '#{format}'"
        STDERR.puts "Supported formats: #{valid_formats.join(', ')}"
        exit 1
      end

      if results.empty?
        puts "No commands found matching the criteria."
        return
      end

      case format
      when 'json'
        output_json_results(results)
      when 'yaml'
        output_yaml_results(results)
      when 'plain'
        output_plain_results(results, options)
      else
        output_shell_history_results(results, format, options)
      end
    end

    # Output results in JSON format
    def output_json_results(results)
      # Get database connection to fetch path arguments
      db_path = Histlog::Utils.get_db_path
      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true

      begin
        json_results = results.map do |row|
          # Fetch path arguments for this command
          path_args = db.execute(<<-SQL, [row['command_id']])
            SELECT pa.arg_position, p.path, p.type
            FROM path_args pa
            JOIN paths p ON pa.path_id = p.id
            WHERE pa.command_id = ?
            ORDER BY pa.arg_position
          SQL

          # Build the base result
          result = {
            command_id: row['command_id'],
            cmd_text: row['cmd_text'],
            start_time: row['start_time'],
            duration: row['duration'],
            exit_code: row['exit_code'],
            is_private: row['is_private'] == 1,
            is_assisted: row['is_assisted'] == 1,
            cwd_old: row['cwd_old'],
            cwd_new: row['cwd_new'],
            session_id: row['session_id'],
            pid: row['pid'],
            shell: row['shell_path'],
            tty: row['tty_device'],
          }.reject { |_, v| v.nil? }

          # Add path arguments if any exist
          if path_args.any?
            result[:path_args] = path_args.map do |arg|
              {
                position: arg['arg_position'],
                path: arg['path'],
                type: arg['type']
              }
            end
          end

          result
        end

        begin
          puts JSON.pretty_generate(json_results)
        rescue Errno::EPIPE
          # Broken pipe - output was closed (e.g., piped to head/less and user quit)
          exit 0
        end
      ensure
        db.close if db
      end
    end

    # Output results in YAML format
    def output_yaml_results(results)
      require 'yaml'

      # Get database connection to fetch path arguments
      db_path = Histlog::Utils.get_db_path
      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true

      begin
        yaml_results = results.map do |row|
          # Fetch path arguments for this command
          path_args = db.execute(<<-SQL, [row['command_id']])
            SELECT pa.arg_position, p.path, p.type
            FROM path_args pa
            JOIN paths p ON pa.path_id = p.id
            WHERE pa.command_id = ?
            ORDER BY pa.arg_position
          SQL

          # Build the base result
          result = {
            'command_id' => row['command_id'],
            'cmd_text' => row['cmd_text'],
            'start_time' => row['start_time'],
            'duration' => row['duration'],
            'exit_code' => row['exit_code'],
            'is_private' => row['is_private'] == 1,
            'is_assisted' => row['is_assisted'] == 1,
            'cwd_old' => row['cwd_old'],
            'cwd_new' => row['cwd_new'],
            'session_id' => row['session_id'],
            'pid' => row['pid'],
            'shell' => row['shell_path'],
            'tty' => row['tty_device'],
          }.reject { |_, v| v.nil? }

          # Add path arguments if any exist
          if path_args.any?
            result['path_args'] = path_args.map do |arg|
              {
                'position' => arg['arg_position'],
                'path' => arg['path'],
                'type' => arg['type']
              }
            end
          end

          result
        end

        begin
          puts yaml_results.to_yaml
        rescue Errno::EPIPE
          # Broken pipe - output was closed (e.g., piped to head/less and user quit)
          exit 0
        end
      ensure
        db.close if db
      end
    end

    # Output results in plain format with timestamps
    def output_plain_results(results, options)
      begin
        results.each do |row|
          command = row['cmd_text']
          puts command
        end
      rescue Errno::EPIPE
        exit 0
      end
    end

    # Output results in shell history formats
    def output_shell_history_results(results, format, options)
      # Convert query results to the format expected by format_commands_for_shell
      formatted_results = results.map do |row|
        result = {
          'command' => row['cmd_text'],
          'start_time' => row['start_time']
        }

        # Add command_id for fish format to get paths
        if format == 'fish'
          result['command_id'] = row['command_id']
        end

        result
      end

      # Format results using the shared formatting function
      format_options = {
        format: format,
        include_timestamps: true
      }

      formatted_commands = format_commands_for_shell(formatted_results, format, format_options)
      begin
        formatted_commands.each { |line| puts line }
      rescue Errno::EPIPE
        # Broken pipe - output was closed (e.g., piped to head/less and user quit)
        exit 0
      end
    end

    # Output results for display
    def output_interactive_results(results, options)
      if results.empty?
        puts "No commands found matching the criteria."
        return
      end

      # Dracula color codes
      # Timestamp: #6272a4, Command: default, Result: âœ“ #50fa7b, âœ— #ff5555, Duration: #bd93f9
      begin
        # Colors
        palette = Histlog::Config.colors(:history)
        ts_col = palette[:timestamp]
        dur_col = palette[:duration]
        success_col = palette[:status_success]
        fail_col = palette[:status_fail]
        reset_col = palette[:reset]

        # Header (PascalCase titles) with Status column
        status_col = palette[:status_header]
        header = "%-19s %8s %-6s %s" % ["Timestamp", "Duration", "Status", "Command"]
        # Separator length matches columns: 19 +1 +8 +1 +6 +1 +7 = 43
        sep = '-' * 43
        # Colored header using same column widths
        printf("%s%-19s%s  %s%8s%s %s%-4s%s %s\n", ts_col, "Timestamp", reset_col, dur_col, "Duration", reset_col,
               status_col, "Stat", reset_col, "Command")
        puts sep

        results.each do |row|
          timestamp = row['start_time'] ? Time.at(row['start_time']).strftime('%Y-%m-%d %H:%M:%S') : 'Unknown'
          duration = row['duration'] ? sprintf('%8.3fs', row['duration']) : '-,---s'
          exit_code = row['exit_code'] || 0
          status_text = exit_code == 0 ? "âœ“" : "âœ—#{exit_code}"
          # Pad status to 6 chars so columns align visually (padding applied before adding ANSI colors)
          status_padded = status_text.ljust(4)
          colored_status = if exit_code == 0
                             "#{success_col}#{status_padded}#{reset_col}"
                           else
                             "#{fail_col}#{status_padded}#{reset_col}"
                           end
          command = row['cmd_text'].gsub("\n", "\n                                   ")
          # Print timestamp and duration aligned, then colored status, then command
          printf("%s%-19s%s %s%8s%s %s %s\n", ts_col, timestamp, reset_col, dur_col, duration, reset_col, colored_status,
                 command)
        end
      rescue Errno::EPIPE
        exit 0
      end
    end

    # Format commands for specific shell format
    def format_commands_for_shell(rows, format, options)
      formatted = []

      case format
      when 'fish'
        rows.each do |row|
          formatted << "- cmd: #{row['command']}"
          if options[:include_timestamps] && row['start_time']
            formatted << "  when: #{row['start_time'].to_i}"
          end

          # Add paths for fish format if command_id is available
          if row['command_id']
            paths = Histlog::DB.get_command_paths(row['command_id'])
            if paths && !paths.empty?
              formatted << "  paths:"
              paths.each do |path|
                formatted << "    - #{path}"
              end
            end
          end
        end

      when 'zsh'
        rows.each do |row|
          if options[:include_timestamps] && row['start_time']
            # Zsh extended history format: ": timestamp:0;command"
            formatted << ": #{row['start_time'].to_i}:0;#{row['command']}"
          else
            # Simple format: just the command
            formatted << row['command']
          end
        end

      when 'nu'
        # Nushell history is plain text, one command per line
        rows.each do |row|
          formatted << row['command']
        end

      when 'bash'
        # Bash history format - simple commands, timestamps optional
        rows.each do |row|
          if options[:include_timestamps] && row['start_time']
            # Bash can use timestamps with HISTTIMEFORMAT, stored as comments
            formatted << "##{row['start_time'].to_i}"
            formatted << row['command']
          else
            formatted << row['command']
          end
        end

      when 'powershell'
        # PowerShell history is typically just commands, one per line
        rows.each do |row|
          formatted << row['command']
        end

      when 'plain'
        rows.each do |row|
          if options[:include_timestamps] && row['start_time']
            timestamp = Time.at(row['start_time'].to_f).strftime('%Y-%m-%d %H:%M:%S')
            formatted << "[#{timestamp}] #{row['command']}"
          else
            formatted << row['command']
          end
        end

      else
        # Fallback to plain format
        rows.each do |row|
          formatted << row['command']
        end
      end

      formatted
    end
  end
end

require 'sqlite3'
require 'json'
require 'fileutils'
require 'optparse'
require 'ostruct'
require 'time'
require 'set'

module Histlog
  # Utility functions module
  module Utils
    module_function

    # Helper to format timestamps (from Julian Day)
    def format_time(timestamp)
      return 'unknown' unless timestamp

      # Convert from Julian Day to Unix timestamp
      unix_time = (timestamp - 2440587.5) * 86400
      Time.at(unix_time).strftime('%Y-%m-%d %H:%M:%S')
    end

    # Helper to format duration
    def format_duration(duration)
      return 'N/A' unless duration

      if duration < 1
        "#{(duration * 1000).round(1)}ms"
      elsif duration < 60
        "#{duration.round(2)}s"
      elsif duration < 3600
        minutes = (duration / 60).to_i
        seconds = (duration % 60).round(1)
        "#{minutes}m #{seconds}s"
      else
        hours = (duration / 3600).to_i
        minutes = ((duration % 3600) / 60).to_i
        "#{hours}h #{minutes}m"
      end
    end

    # Helper to truncate command text
    def truncate_command(command, max_length = 60)
      return 'N/A' unless command

      command.length > max_length ? "#{command[0...max_length - 3]}..." : command
    end

    # Get current timezone
    def get_timezone
      # Try to get timezone from environment or system
      ENV['TZ'] || Time.now.zone || 'UTC'
    rescue
      'UTC'
    end

    # Cross-platform TTY detection
    def get_current_tty
      if RUBY_PLATFORM.include?('linux')
        # On Linux, read from /proc
        begin
          File.read('/proc/self/fd/0').match(/\/dev\/(.*)$/)[1]
        rescue
          'unknown'
        end
      else
        # On macOS and other systems, use tty command
        begin
          `tty`.chomp
        rescue
          # Fallback to TERM environment variable
          ENV['TERM'] || 'unknown'
        end
      end
    end

    # Format bytes in human readable format
    def format_bytes(bytes)
      units = ['B', 'KB', 'MB', 'GB', 'TB']
      size = bytes.to_f
      unit_index = 0

      while size >= 1024 && unit_index < units.length - 1
        size /= 1024
        unit_index += 1
      end

      "#{size.round(2)} #{units[unit_index]}"
    end

    # Helper to get tty
    def get_tty
      begin
        # Try Linux-style first
        File.readlink('/proc/self/fd/0')
      rescue
        begin
          # Try macOS-style
          `tty`.chomp
        rescue
          # Fallback to TERM environment variable
          ENV['TERM'] || 'unknown'
        end
      end
    end

    # SQLite database setup
    def get_db_path
      # Prefer explicit environment variable if provided, else default to configured db path
      Histlog::Config.db_path
    end

    # Helper: parse time span strings into seconds.
    # Accepts relative shorthand: 120s, 40m, 4h, 7d, 2w and combined tokens like '1h30m'
    # Accepts verbose forms: '1 hour', '30 minutes', possibly combined ('1 hour 30 minutes')
    # Also accepts absolute timestamps in these example patterns:
    #  - '2025-09-27 19:52:17'
    #  - '2025-09-27 19:52'
    #  - '09-27 19:52' (assumes current year, if in future uses previous year)
    #  - '19:52' (assumes today; if in future uses yesterday)
    # Returns:
    #  - Numeric seconds (>= 0) representing the duration from parsed time to now
    #  - -1 if parsed absolute timestamp is in the future
    #  - nil if parsing fails
    def parse_time_span_to_seconds(str)
      return nil if str.nil?

      raw = str.strip
      s = raw.downcase
      now = Time.now

      # Try absolute timestamp parsing with various formats
      timestamp_formats = [
        '%Y-%m-%d %H:%M:%S',
        '%Y-%m-%d %H:%M',
        '%Y-%m-%d',
        '%m-%d %H:%M:%S',
        '%m-%d %H:%M',
        '%m-%d',
        '%H:%M:%S',
        '%H:%M'
      ]

      timestamp_formats.each do |fmt|
        begin
          parsed = nil
          if fmt.start_with?('%Y')
            parsed = Time.strptime(raw, fmt) rescue nil
          elsif fmt.start_with?('%m-%d')
            # attach current year
            try = Time.strptime("#{now.year}-#{raw}", "%Y-#{fmt}") rescue nil
            parsed = try
            # if parsed is in the future, try previous year
            if parsed && parsed > now
              parsed = Time.new(parsed.year - 1, parsed.month, parsed.day, parsed.hour, parsed.min, parsed.sec)
            end
          else
            # time-only formats: assume today
            try = Time.strptime(raw, fmt) rescue nil
            if try
              parsed = Time.new(now.year, now.month, now.day, try.hour, try.min, try.sec)
              # if the parsed time is in the future, assume yesterday
              if parsed > now
                parsed -= 86400
              end
            end
          end

          if parsed
            seconds = (now.to_f - parsed.to_f)
            return -1 if seconds < 0

            return seconds
          end
        rescue ArgumentError
          # try next format
        end
      end

      # Otherwise parse relative tokens (combined and decimals)
      total = 0.0
      matched = false

      # Shorthand tokens like '1.5h', repeated tokens '1h30m'
      s.scan(/(\d+(?:\.\d+)?)\s*([smhdw])/) do |num_s, unit|
        num = num_s.to_f
        matched = true
        case unit
        when 's' then total += num
        when 'm' then total += num * 60
        when 'h' then total += num * 3600
        when 'd' then total += num * 86400
        when 'w' then total += num * 7 * 86400
        end
      end

      # Verbose tokens like '1 hour', '30 minutes'
      s.scan(/(\d+(?:\.\d+)?)\s*(second|seconds|minute|minutes|hour|hours|day|days|week|weeks)/) do |num_s, word|
        num = num_s.to_f
        matched = true
        case word
        when 'second', 'seconds' then total += num
        when 'minute', 'minutes' then total += num * 60
        when 'hour', 'hours' then total += num * 3600
        when 'day', 'days' then total += num * 86400
        when 'week', 'weeks' then total += num * 7 * 86400
        end
      end

      return nil unless matched

      total % 1 == 0 ? total.to_i : total
    end
  end
end

# Minimal DB namespace wrapper so existing code can call Histlog::DB.* helpers
module Histlog
  module DB
    module_function

    # Expose path accessor
    def path
      Histlog::Config.db_path
    end

    # initialize_db implementation
    def initialize_db
      db_path = Histlog::Config.db_path
      db_dir = File.dirname(db_path)
      FileUtils.mkdir_p(db_dir) unless Dir.exist?(db_dir)
      db = SQLite3::Database.new(db_path)

      # Enable performance and compression optimizations
      db.execute "PRAGMA journal_mode = WAL"
      db.execute "PRAGMA synchronous = NORMAL"
      db.execute "PRAGMA cache_size = 10000"
      db.execute "PRAGMA temp_store = MEMORY"
      db.execute "PRAGMA mmap_size = 268435456"
      db.execute "PRAGMA page_size = 4096"

      # Create tables and indexes (same as original implementation)
      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS shells (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	path TEXT UNIQUE NOT NULL,
    	version TEXT,
    	created_at REAL DEFAULT (julianday('now'))
        )
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS ttys (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	device TEXT NOT NULL,
    	created_at REAL DEFAULT (julianday('now'))
        );
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS paths (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	path TEXT NOT NULL,
    	type TEXT NOT NULL CHECK (type IN ('f', 'd')),
    	created_at REAL DEFAULT (julianday('now'))
        );
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS sessions (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	shell_id INTEGER,
    	tty_id INTEGER,
    	path_id INTEGER,
    	pid INTEGER,
    	parent_pid INTEGER,
    	timezone TEXT,
    	created_at REAL DEFAULT (julianday('now')),
    	FOREIGN KEY (shell_id) REFERENCES shells (id),
    	FOREIGN KEY (tty_id) REFERENCES ttys (id),
    	FOREIGN KEY (path_id) REFERENCES paths (id)
        )
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS cmd_texts (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	command TEXT UNIQUE NOT NULL,
    	created_at REAL DEFAULT (julianday('now'))
        )
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS commands (
    	id INTEGER PRIMARY KEY AUTOINCREMENT,
    	session_id INTEGER,
    	cmd_text_id INTEGER,
    	path_old_id INTEGER,
    	path_new_id INTEGER,
    	start_time REAL,
    	duration REAL,
    	exit_code INTEGER,
    	is_private INTEGER DEFAULT 0,
    	is_assisted INTEGER DEFAULT 0,
    	created_at REAL DEFAULT (julianday('now')),
    	FOREIGN KEY (session_id) REFERENCES sessions (id),
    	FOREIGN KEY (cmd_text_id) REFERENCES cmd_texts (id),
    	FOREIGN KEY (path_old_id) REFERENCES paths (id),
    	FOREIGN KEY (path_new_id) REFERENCES paths (id)
        )
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS path_args (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        command_id INTEGER,
        path_id INTEGER,
        arg_position INTEGER,
        created_at REAL DEFAULT (julianday('now')),
        FOREIGN KEY (command_id) REFERENCES commands (id),
        FOREIGN KEY (path_id) REFERENCES paths (id),
        UNIQUE (command_id, path_id, arg_position)
        )
      SQL

      # Indexes
      db.execute "CREATE INDEX IF NOT EXISTS idx_shells_path ON shells (path)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_ttys_device ON ttys (device)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_paths_path ON paths (path)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_paths_type ON paths (type)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_sessions_shell_id ON sessions (shell_id)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_sessions_created_at ON sessions (created_at)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_sessions_path_id ON sessions (path_id)"
      db.execute "CREATE UNIQUE INDEX IF NOT EXISTS idx_cmd_texts_command ON cmd_texts (command)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_cmd_texts_created_at ON cmd_texts (created_at)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_session_id ON commands (session_id)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_cmd_text_id ON commands (cmd_text_id)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_created_at ON commands (created_at)"

      begin
        cols = db.execute("PRAGMA table_info(commands)")
        col_names = cols.map { |r| r[1] }
        unless col_names.include?('start_time')
          db.execute "ALTER TABLE commands ADD COLUMN start_time REAL"
        end
      rescue SQLite3::Exception
      end

      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_start_time ON commands (start_time)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_exit_code ON commands (exit_code)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_command_id ON path_args (command_id)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_path_id ON path_args (path_id)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_path_id ON path_args (path_id)"

      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_session_id_created_at ON commands (session_id, created_at)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_exit_code_created_at ON commands (exit_code, created_at)"
      db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_command_id_arg_position ON path_args (command_id, arg_position)"

      db.execute "CREATE INDEX IF NOT EXISTS idx_commands_session_created_where_failed ON commands (session_id, created_at) WHERE exit_code != 0"
      db.execute "CREATE INDEX IF NOT EXISTS idx_paths_path_where_file ON paths (path) WHERE type = 'f'"
      db.execute "CREATE INDEX IF NOT EXISTS idx_paths_path_where_dir ON paths (path) WHERE type = 'd'"

      db.execute "DROP VIEW IF EXISTS sessions_view"
      db.execute <<-SQL
        CREATE VIEW sessions_view AS
        SELECT
    	s.id as session_id,
    	s.pid,
    	s.parent_pid,
    	s.timezone,
    	s.created_at,
    	datetime(s.created_at) as created_time,
    	sh.path as shell_path,
    	sh.version as shell_version,
    	t.device as tty_device,
    	p.path as working_directory
        FROM sessions s
        LEFT JOIN shells sh ON s.shell_id = sh.id
        LEFT JOIN ttys t ON s.tty_id = t.id
        LEFT JOIN paths p ON s.path_id = p.id
      SQL

      db.execute <<-SQL
        CREATE VIEW IF NOT EXISTS history_view AS
        SELECT
    	cmd.id as cmd_text_id,
    	cmd.session_id as session_id,
    	s.pid as session_pid,
    	s.parent_pid as session_parent_pid,
    	datetime(s.created_at, 'unixepoch') as session_started,
    	sh.path as shell_path,
    	t.device as tty_device,
    	c.command,
    	datetime(cmd.start_time, 'unixepoch') as command_started,
    	cmd.start_time as start_time,
    	cmd.duration,
    	cmd.exit_code,
    	cmd.is_private,
    	p_old.path as cwd_old,
    	p_new.path as cwd_new,
    	CASE
    	WHEN p_old.path IS NOT NULL AND p_new.path IS NOT NULL AND p_old.path != p_new.path THEN 1
    	ELSE 0
    	END as directory_changed
    	FROM commands cmd
        LEFT JOIN sessions s ON cmd.session_id = s.id
    	JOIN cmd_texts c ON cmd.cmd_text_id = c.id
        LEFT JOIN shells sh ON s.shell_id = sh.id
        LEFT JOIN ttys t ON s.tty_id = t.id
        LEFT JOIN paths p_old ON cmd.path_old_id = p_old.id
        LEFT JOIN paths p_new ON cmd.path_new_id = p_new.id
      ORDER BY cmd.start_time DESC
      SQL

      db
    end

    # Helper: get or create a shell id
    def get_or_create_shell_id(db, shell_path)
      return nil unless shell_path

      result = db.execute("SELECT id FROM shells WHERE path = ?", [shell_path])
      return result[0][0] if result && result[0]

      version = begin
        `#{shell_path} --version 2>/dev/null`.strip
      rescue
        nil
      end
      begin
        res = db.execute("INSERT INTO shells (path, version) VALUES (?, ?) RETURNING id", [shell_path, version])
        res[0][0] if res && res[0]
      rescue SQLite3::Exception
        db.execute("INSERT INTO shells (path, version) VALUES (?, ?)", [shell_path, version])
        db.last_insert_row_id
      end
    end

    def get_or_create_tty_id(db, tty_device)
      return nil unless tty_device

      result = db.execute("SELECT id FROM ttys WHERE device = ?", [tty_device])
      return result[0][0] if result && result[0]

      begin
        res = db.execute("INSERT INTO ttys (device) VALUES (?) RETURNING id", [tty_device])
        res[0][0] if res && res[0]
      rescue SQLite3::Exception
        db.execute("INSERT INTO ttys (device) VALUES (?)", [tty_device])
        db.last_insert_row_id
      end
    end

    def get_or_create_path_id(db, path, type = nil)
      return nil unless path

      begin
        abs_path = File.expand_path(path)
      rescue => e
        STDERR.puts "Warning: Could not normalize path '#{path}': #{e.message}"
        abs_path = path
      end
      result = db.execute("SELECT id FROM paths WHERE path = ?", [abs_path])
      return result[0][0] if result && result[0]

      if type.nil?
        type = File.directory?(abs_path) ? 'd' : 'f'
      end
      begin
        res = db.execute("INSERT INTO paths (path, type) VALUES (?, ?) RETURNING id", [abs_path, type])
        res[0][0] if res && res[0]
      rescue SQLite3::Exception
        db.execute("INSERT INTO paths (path, type) VALUES (?, ?)", [abs_path, type])
        db.last_insert_row_id
      end
    end

    def get_or_create_cmd_text_id(db, command)
      result = db.execute("SELECT id FROM cmd_texts WHERE command = ?", [command])
      if result && result[0]
        id_val = result[0].is_a?(Hash) ? result[0]["id"] : result[0][0]
        return id_val && id_val.to_i > 0 ? id_val.to_i : nil
      end
      begin
        res = db.execute("INSERT INTO cmd_texts (command) VALUES (?) RETURNING id", [command])
        if res && res[0]
          id_val = res[0].is_a?(Hash) ? res[0]["id"] : res[0][0]
          return id_val && id_val.to_i > 0 ? id_val.to_i : nil
        end
      rescue SQLite3::Exception => e
        if e.message.include?("syntax error") || e.message.include?("RETURNING")
          db.execute("INSERT INTO cmd_texts (command) VALUES (?)", [command])
          last_id = db.last_insert_row_id
          return last_id && last_id.to_i > 0 ? last_id.to_i : nil
        else
          raise e
        end
      end
      nil
    end

    def store_session(session_data)
      db = initialize_db
      begin
        shell_id = get_or_create_shell_id(db, session_data[:shell])
        tty_id = get_or_create_tty_id(db, session_data[:tty])
        path_id = get_or_create_path_id(db, session_data[:cwd])
        begin
          res = db.execute("INSERT INTO sessions (shell_id, tty_id, path_id, pid, parent_pid, timezone) VALUES (?, ?, ?, ?, ?, ?) RETURNING id",
                           [shell_id, tty_id, path_id, session_data[:pid], session_data[:parent_pid], session_data[:timezone]])
          return res[0][0] if res && res[0]
        rescue SQLite3::Exception => e
          if e.message.include?("syntax error") || e.message.include?("RETURNING")
            STDERR.puts "Warning: RETURNING clause not supported, using fallback method"
            db.execute("INSERT INTO sessions (shell_id, tty_id, path_id, pid, parent_pid, timezone) VALUES (?, ?, ?, ?, ?, ?)",
                       [shell_id, tty_id, path_id, session_data[:pid], session_data[:parent_pid], session_data[:timezone]])
            return db.last_insert_row_id
          else
            STDERR.puts "Error storing session: #{e.message}"
            return nil
          end
        end
      ensure
        db.close if db
      end
    end

    def store_command(command_data)
      db = initialize_db
      begin
        original_command = command_data[:command]
        is_private = original_command.start_with?(' ') ? 1 : 0
        clean_command = original_command.lstrip
        is_assisted = ENV['VSCODE_INJECTION'] == '1' ? 1 : 0
        cmd_text_id = get_or_create_cmd_text_id(db, clean_command)
        path_old_id = get_or_create_path_id(db, command_data[:cwd])
        begin
          res = db.execute("INSERT INTO commands (session_id, cmd_text_id, path_old_id, is_private, is_assisted, start_time) VALUES (?, ?, ?, ?, ?, ?) RETURNING id",
                           [command_data[:session_id], cmd_text_id, path_old_id, is_private, is_assisted, Time.now.to_f])
          command_id = res[0][0] if res && res[0]
          if command_id
            parse_command_arguments(db, command_id, clean_command)
          end
          return command_id
        rescue SQLite3::Exception => e
          if e.message.include?("syntax error") || e.message.include?("RETURNING")
            STDERR.puts "Warning: RETURNING clause not supported, using fallback method"
            db.execute("INSERT INTO commands (session_id, cmd_text_id, path_old_id, is_private, start_time) VALUES (?, ?, ?, ?, ?)",
                       [command_data[:session_id], cmd_text_id, path_old_id, is_private, Time.now.to_f])
            command_id = db.last_insert_row_id
            if command_id
              parse_command_arguments(db, command_id, clean_command)
            end
            return command_id
          else
            STDERR.puts "Error storing command: #{e.message}"
            return nil
          end
        end
      ensure
        db.close if db
      end
    end

    def parse_command_arguments(db, command_id, command_text)
      args = command_text.scan(/(?:[^\s"']+|"[^"]*"|'[^']*')+/).map { |arg| arg.gsub(/^["']|["']$/, '') }
      args.each_with_index do |arg, position|
        next if position == 0
        next if arg.include?("\x00") || arg.empty?

        begin
          if File.exist?(arg)
            abs_path = File.expand_path(arg)
            path_type = File.directory?(abs_path) ? 'd' : 'f'
            path_id = get_or_create_path_id(db, abs_path, path_type)
            existing = db.execute("SELECT 1 FROM path_args WHERE command_id = ? AND path_id = ? AND arg_position = ? LIMIT 1", [command_id, path_id, position])
            unless existing.any?
              db.execute("INSERT INTO path_args (command_id, path_id, arg_position) VALUES (?, ?, ?)", [command_id, path_id, position])
            end
          end
        rescue
        end
      end
    end

    def update_command_completion(command_id, duration, exit_code)
      db = initialize_db
      begin
        cwd_new_id = get_or_create_path_id(db, Dir.pwd)
        db.execute("UPDATE commands SET duration = ?, exit_code = ?, path_new_id = ? WHERE id = ?", [duration, exit_code, cwd_new_id, command_id])
        result = db.execute("SELECT c.command FROM commands cmd JOIN cmd_texts c ON cmd.cmd_text_id = c.id WHERE cmd.id = ?", [command_id])
        if result && result[0]
          command_text = result[0][0]
          parse_command_arguments(db, command_id, command_text)
        end
      rescue SQLite3::Exception => e
        STDERR.puts "Error updating command: #{e.message}"
      ensure
        db.close if db
      end
    end

    def cleanup_orphaned_entries(db, verbose = false)
      removed_counts = {}
      db.execute(<<-SQL)
        DELETE FROM paths
        WHERE id NOT IN (SELECT path_old_id FROM commands WHERE path_old_id IS NOT NULL)
          AND id NOT IN (SELECT path_new_id FROM commands WHERE path_new_id IS NOT NULL)
          AND id NOT IN (SELECT path_id FROM path_args WHERE path_id IS NOT NULL)
      SQL
      removed_counts[:paths] = db.changes
      db.execute(<<-SQL)
        DELETE FROM cmd_texts
        WHERE id NOT IN (SELECT cmd_text_id FROM commands WHERE cmd_text_id IS NOT NULL)
      SQL
      removed_counts[:cmd_texts] = db.changes
      db.execute(<<-SQL)
        DELETE FROM path_args
        WHERE path_id NOT IN (SELECT id FROM paths)
           OR command_id NOT IN (SELECT id FROM commands)
      SQL
      removed_counts[:path_args] = db.changes
      begin
        db.execute(<<-SQL)
          DELETE FROM ttys
          WHERE id NOT IN (SELECT tty_id FROM sessions WHERE tty_id IS NOT NULL)
        SQL
        removed_counts[:ttys] = db.changes
      rescue SQLite3::SQLException => e
        removed_counts[:ttys] = 0
        puts "Warning: Could not cleanup ttys: #{e.message}" if verbose
      end
      begin
        db.execute(<<-SQL)
          DELETE FROM shells
          WHERE id NOT IN (SELECT shell_id FROM sessions WHERE shell_id IS NOT NULL)
        SQL
        removed_counts[:shells] = db.changes
      rescue SQLite3::SQLException => e
        removed_counts[:shells] = 0
        puts "Warning: Could not cleanup shells: #{e.message}" if verbose
      end
      begin
        db.execute(<<-SQL)
          DELETE FROM sessions
          WHERE id NOT IN (SELECT session_id FROM commands WHERE session_id IS NOT NULL)
        SQL
        removed_counts[:sessions] = db.changes
      rescue SQLite3::SQLException => e
        removed_counts[:sessions] = 0
        puts "Warning: Could not cleanup sessions: #{e.message}" if verbose
      end
      if verbose
        puts "Cleanup summary:"
        removed_counts.each do |table, count|
          puts "  #{table}: #{count} orphaned entries removed"
        end
      end
      total_removed = removed_counts.values.sum
      puts "Orphaned entries cleaned up (#{total_removed} total)." unless verbose
      removed_counts
    end

    def get_command_paths(command_id)
      return [] unless command_id

      db_path = path
      return [] unless File.exist?(db_path)

      db = SQLite3::Database.new(db_path)
      db.results_as_hash = true
      begin
        cmd_info = db.execute(
          "SELECT ct.command, p1.path as old_path, p2.path as new_path FROM commands c
           JOIN cmd_texts ct ON c.cmd_text_id = ct.id
           LEFT JOIN paths p1 ON c.path_old_id = p1.id
           LEFT JOIN paths p2 ON c.path_new_id = p2.id
           WHERE c.id = ?",
          [command_id]
        ).first
        return [] unless cmd_info

        command_text = cmd_info['command']
        old_path = cmd_info['old_path']
        new_path = cmd_info['new_path']
        path_args = db.execute(<<-SQL, [command_id])
          SELECT pa.arg_position, p.path, p.type
          FROM path_args pa
          JOIN paths p ON pa.path_id = p.id
          WHERE pa.command_id = ?
          ORDER BY pa.arg_position
        SQL
        paths = []
        if command_text.strip.match(/^cd\s/)
          cd_match = command_text.strip.match(/^cd(?:\s+([^\s;&|]+))?/)
          if cd_match && cd_match[1]
            cd_arg = cd_match[1].strip
            cd_arg = cd_arg.gsub(/^['"]|['"]$/, '')
            paths << cd_arg
          end
        else
          seen_paths = Set.new
          path_args.each do |row|
            path = row['path']
            unless seen_paths.include?(path)
              paths << path
              seen_paths.add(path)
            end
          end
        end
        paths
      rescue SQLite3::SQLException => e
        []
      ensure
        db&.close
      end
    end

    def import_commands_to_db(commands, options)
      db = initialize_db
      db.results_as_hash = true
      imported_count = 0
      command_id_lookup = {}
      session_id_lookup = {}
      begin
        commands.each_with_index do |cmd_data, index|
          begin
            next if cmd_data[:command].nil? || cmd_data[:command].strip.empty?

            original_command = cmd_data[:command]
            is_private = original_command.start_with?(' ') ? 1 : 0
            clean_command = original_command.lstrip
            cmd_text_id = get_or_create_cmd_text_id(db, clean_command)
            original_command_id = cmd_data[:_original_command_id]
            original_session_id = cmd_data[:_original_session_id]
            if cmd_data[:start_time]
              julian_day = (cmd_data[:start_time].to_f / 86400) + 2440587.5
              db.execute("INSERT INTO commands (session_id, cmd_text_id, path_old_id, path_new_id, duration, exit_code, is_private, is_assisted, created_at, start_time) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", [nil, cmd_text_id, nil, nil, nil, nil, is_private, 0, julian_day, cmd_data[:start_time].to_f])
            else
              db.execute("INSERT INTO commands (session_id, cmd_text_id, path_old_id, path_new_id, duration, exit_code, is_private, is_assisted, start_time) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)", [nil, cmd_text_id, nil, nil, nil, nil, is_private, 0, nil])
            end
            new_command_id = db.last_insert_row_id
            if original_command_id
              command_id_lookup[original_command_id] = new_command_id
            end
            imported_count += 1
          rescue SQLite3::Exception => e
            STDERR.puts "Warning: Could not import command '#{cmd_data[:command]}': #{e.message}" if options[:verbose]
          end
        end
        if options[:verbose] && command_id_lookup.any?
          puts "Created ID mappings for #{command_id_lookup.size} commands with original IDs"
        end
      rescue SQLite3::Exception => e
        STDERR.puts "Database error during import: #{e.message}"
      ensure
        db.close if db
      end
      imported_count
    end
  end
end

def initialize_db
  db_path = get_db_path
  db_dir = File.dirname(db_path)
  FileUtils.mkdir_p(db_dir) unless Dir.exist?(db_dir)
  db = SQLite3::Database.new(db_path)

  # Enable performance and compression optimizations
  db.execute "PRAGMA journal_mode = WAL"          # Write-Ahead Logging for better concurrency
  db.execute "PRAGMA synchronous = NORMAL"        # Balance safety and performance
  db.execute "PRAGMA cache_size = 10000"          # Larger cache (10MB)
  db.execute "PRAGMA temp_store = MEMORY"         # Store temp data in memory
  db.execute "PRAGMA mmap_size = 268435456"       # 256MB memory mapping
  db.execute "PRAGMA page_size = 4096"            # Optimal page size for command data

  # Create shells table
  db.execute <<-SQL
    CREATE TABLE IF NOT EXISTS shells (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		path TEXT UNIQUE NOT NULL,
		version TEXT,
		created_at REAL DEFAULT (julianday('now'))
    )
  SQL

  # Create ttys table
  db.execute <<-SQL
    CREATE TABLE IF NOT EXISTS ttys (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		device TEXT NOT NULL,
		created_at REAL DEFAULT (julianday('now'))
    );
  SQL

  # Create paths table
  db.execute <<-SQL
    CREATE TABLE IF NOT EXISTS paths (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		path TEXT NOT NULL,
		type TEXT NOT NULL CHECK (type IN ('f', 'd')),
		created_at REAL DEFAULT (julianday('now'))
    );
  SQL

  # Create sessions table
  db.execute <<-SQL
    CREATE TABLE IF NOT EXISTS sessions (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		shell_id INTEGER,
		tty_id INTEGER,
		path_id INTEGER,
		pid INTEGER,
		parent_pid INTEGER,
		timezone TEXT,
		created_at REAL DEFAULT (julianday('now')),
		FOREIGN KEY (shell_id) REFERENCES shells (id),
		FOREIGN KEY (tty_id) REFERENCES ttys (id),
		FOREIGN KEY (path_id) REFERENCES paths (id)
    )
  SQL

  # Create cmd_texts table for command text
  db.execute <<-SQL
    CREATE TABLE IF NOT EXISTS cmd_texts (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		command TEXT UNIQUE NOT NULL,
		created_at REAL DEFAULT (julianday('now'))
    )
  SQL

  # Create commands table (formerly: entries/history) for command executions
  db.execute <<-SQL
    CREATE TABLE IF NOT EXISTS commands (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		session_id INTEGER,
		cmd_text_id INTEGER,
		path_old_id INTEGER,                         -- Working directory at preexec
		path_new_id INTEGER,                         -- Working directory at postcmd
		start_time REAL,                              -- Unix epoch seconds when command started
		duration REAL,
		exit_code INTEGER,
		is_private INTEGER DEFAULT 0,              -- 1 if command started with space
		is_assisted INTEGER DEFAULT 0,             -- 1 if command was AI-assisted/injected
		created_at REAL DEFAULT (julianday('now')),
		FOREIGN KEY (session_id) REFERENCES sessions (id),
		FOREIGN KEY (cmd_text_id) REFERENCES cmd_texts (id),
		FOREIGN KEY (path_old_id) REFERENCES paths (id),
		FOREIGN KEY (path_new_id) REFERENCES paths (id)
    )
  SQL

  # Create path_args table for storing argument paths
  db.execute <<-SQL
    CREATE TABLE IF NOT EXISTS path_args (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    command_id INTEGER,
    path_id INTEGER,
    arg_position INTEGER,                       -- Position of argument in command
    created_at REAL DEFAULT (julianday('now')),
    FOREIGN KEY (command_id) REFERENCES commands (id),
    FOREIGN KEY (path_id) REFERENCES paths (id),
    UNIQUE (command_id, path_id, arg_position)
    )
  SQL

  # Create optimized indexes for query performance
  db.execute "CREATE INDEX IF NOT EXISTS idx_shells_path ON shells (path)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_ttys_device ON ttys (device)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_paths_path ON paths (path)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_paths_type ON paths (type)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_sessions_shell_id ON sessions (shell_id)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_sessions_created_at ON sessions (created_at)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_sessions_path_id ON sessions (path_id)"
  db.execute "CREATE UNIQUE INDEX IF NOT EXISTS idx_cmd_texts_command ON cmd_texts (command)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_cmd_texts_created_at ON cmd_texts (created_at)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_commands_session_id ON commands (session_id)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_commands_cmd_text_id ON commands (cmd_text_id)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_commands_created_at ON commands (created_at)"
  # Ensure start_time column exists (migration for older DBs)
  begin
    cols = db.execute("PRAGMA table_info(commands)")
    col_names = cols.map { |r| r[1] }
    unless col_names.include?('start_time')
      db.execute "ALTER TABLE commands ADD COLUMN start_time REAL"
    end
  rescue SQLite3::Exception
    # ignore migration errors
  end
  db.execute "CREATE INDEX IF NOT EXISTS idx_commands_start_time ON commands (start_time)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_commands_exit_code ON commands (exit_code)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_command_id ON path_args (command_id)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_path_id ON path_args (path_id)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_path_id ON path_args (path_id)"

  # Compound indexes for common query patterns
  db.execute "CREATE INDEX IF NOT EXISTS idx_commands_session_id_created_at ON commands (session_id, created_at)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_commands_exit_code_created_at ON commands (exit_code, created_at)"
  db.execute "CREATE INDEX IF NOT EXISTS idx_path_args_command_id_arg_position ON path_args (command_id, arg_position)"

  # Partial indexes for performance on common filters
  db.execute "CREATE INDEX IF NOT EXISTS idx_commands_session_created_where_failed ON commands (session_id, created_at) WHERE exit_code != 0"
  db.execute "CREATE INDEX IF NOT EXISTS idx_paths_path_where_file ON paths (path) WHERE type = 'f'"
  db.execute "CREATE INDEX IF NOT EXISTS idx_paths_path_where_dir ON paths (path) WHERE type = 'd'"

  # Create sessions view for easier querying
  db.execute "DROP VIEW IF EXISTS sessions_view"
  db.execute <<-SQL
    CREATE VIEW sessions_view AS
    SELECT
		s.id as session_id,
		s.pid,
		s.parent_pid,
		s.timezone,
		s.created_at,
		datetime(s.created_at) as created_time,
		sh.path as shell_path,
		sh.version as shell_version,
		t.device as tty_device,
		p.path as working_directory
    FROM sessions s
    LEFT JOIN shells sh ON s.shell_id = sh.id
    LEFT JOIN ttys t ON s.tty_id = t.id
    LEFT JOIN paths p ON s.path_id = p.id
  SQL

  # Create history view for comprehensive command history
  db.execute <<-SQL
    CREATE VIEW IF NOT EXISTS history_view AS
    SELECT
		cmd.id as cmd_text_id,
		cmd.session_id as session_id,
		s.pid as session_pid,
		s.parent_pid as session_parent_pid,
		datetime(s.created_at, 'unixepoch') as session_started,
		sh.path as shell_path,
		t.device as tty_device,
		c.command,
		datetime(cmd.start_time, 'unixepoch') as command_started,
		cmd.start_time as start_time,
		cmd.duration,
		cmd.exit_code,
		cmd.is_private,
		p_old.path as cwd_old,
		p_new.path as cwd_new,
		CASE
		WHEN p_old.path IS NOT NULL AND p_new.path IS NOT NULL AND p_old.path != p_new.path THEN 1
		ELSE 0
		END as directory_changed
	FROM commands cmd
    LEFT JOIN sessions s ON cmd.session_id = s.id
  	JOIN cmd_texts c ON cmd.cmd_text_id = c.id
    LEFT JOIN shells sh ON s.shell_id = sh.id
    LEFT JOIN ttys t ON s.tty_id = t.id
    LEFT JOIN paths p_old ON cmd.path_old_id = p_old.id
    LEFT JOIN paths p_new ON cmd.path_new_id = p_new.id
  ORDER BY cmd.start_time DESC
  SQL

  db
end

# Helper function to get shell version
def get_shell_version(shell_path)
  return nil unless shell_path

  begin
    # Try common version flags
    version_output = `#{shell_path} --version 2>/dev/null`.strip
    return version_output.lines.first&.strip if !version_output.empty?

    # Fallback for shells that don't support --version
    version_output = `#{shell_path} -c 'echo $0 $version' 2>/dev/null`.strip
    return version_output if !version_output.empty?
  rescue
    # If we can't get version, return nil
  end
  nil
end

# Get or create shell_id
def get_or_create_shell_id(db, shell_path)
  return nil unless shell_path

  # Try to find existing shell
  result = db.execute("SELECT id FROM shells WHERE path = ?", [shell_path])
  return result[0][0] if result && result[0]

  # Create new shell entry
  version = get_shell_version(shell_path)
  result = db.execute(
    "INSERT INTO shells (path, version) VALUES (?, ?) RETURNING id",
    [shell_path, version]
  )
  result[0][0] if result && result[0]
rescue SQLite3::Exception
  # Fallback for older SQLite without RETURNING
  db.execute("INSERT INTO shells (path, version) VALUES (?, ?)", [shell_path, version])
  db.last_insert_row_id
end

# Get or create tty_id
def get_or_create_tty_id(db, tty_device)
  return nil unless tty_device

  # Try to find existing tty
  result = db.execute("SELECT id FROM ttys WHERE device = ?", [tty_device])
  return result[0][0] if result && result[0]

  # Create new tty entry
  result = db.execute(
    "INSERT INTO ttys (device) VALUES (?) RETURNING id",
    [tty_device]
  )
  result[0][0] if result && result[0]
rescue SQLite3::Exception
  # Fallback for older SQLite without RETURNING
  db.execute("INSERT INTO ttys (device) VALUES (?)", [tty_device])
  db.last_insert_row_id
end

# Get or create path_id
def get_or_create_path_id(db, path, type = nil)
  return nil unless path

  # Normalize to absolute path
  begin
    abs_path = File.expand_path(path)
  rescue => e
    STDERR.puts "Warning: Could not normalize path '#{path}': #{e.message}"
    abs_path = path
  end

  # Try to find existing path (using absolute path)
  result = db.execute("SELECT id FROM paths WHERE path = ?", [abs_path])
  return result[0][0] if result && result[0]

  # Determine type if not provided
  if type.nil?
    type = File.directory?(abs_path) ? 'd' : 'f'
  end

  # Create new path entry with absolute path
  result = db.execute(
    "INSERT INTO paths (path, type) VALUES (?, ?) RETURNING id",
    [abs_path, type]
  )
  result[0][0] if result && result[0]
rescue SQLite3::Exception
  # Fallback for older SQLite without RETURNING
  db.execute("INSERT INTO paths (path, type) VALUES (?, ?)", [abs_path, type])
  db.last_insert_row_id
end

def store_session(session_data)
  db = initialize_db
  begin
    # Get or create IDs for foreign key references
    shell_id = get_or_create_shell_id(db, session_data[:shell])
    tty_id = get_or_create_tty_id(db, session_data[:tty])
    path_id = get_or_create_path_id(db, session_data[:cwd])

    # Use RETURNING clause for thread-safe ID retrieval (SQLite 3.35+)
    result = db.execute(
      "INSERT INTO sessions (shell_id, tty_id, path_id, pid, parent_pid, timezone) VALUES (?, ?, ?, ?, ?, ?) RETURNING id",
      [
        shell_id,
        tty_id,
        path_id,
        session_data[:pid],
        session_data[:parent_pid],
        session_data[:timezone]
      ]
    )
    # Return the session_id from the RETURNING clause
    return result[0][0] if result && result[0]
  rescue SQLite3::Exception => e
    # Fallback to last_insert_row_id if RETURNING is not supported
    if e.message.include?("syntax error") || e.message.include?("RETURNING")
      STDERR.puts "Warning: RETURNING clause not supported, using fallback method"
      begin
        shell_id = get_or_create_shell_id(db, session_data[:shell])
        tty_id = get_or_create_tty_id(db, session_data[:tty])
        path_id = get_or_create_path_id(db, session_data[:cwd])

        db.execute(
          "INSERT INTO sessions (shell_id, tty_id, path_id, pid, parent_pid, timezone) VALUES (?, ?, ?, ?, ?, ?)",
          [
            shell_id,
            tty_id,
            path_id,
            session_data[:pid],
            session_data[:parent_pid],
            session_data[:timezone]
          ]
        )
        return db.last_insert_row_id
      rescue SQLite3::Exception => fallback_e
        STDERR.puts "Error storing session: #{fallback_e.message}"
        return nil
      end
    else
      STDERR.puts "Error storing session: #{e.message}"
      return nil
    end
  ensure
    db.close if db
  end
end

def get_or_create_cmd_text_id(db, command)
  # Try to find existing command by text
  result = db.execute("SELECT id FROM cmd_texts WHERE command = ?", [command])
  if result && result[0]
    # Handle both hash and array results (db.results_as_hash setting affects this)
    id_val = result[0].is_a?(Hash) ? result[0]["id"] : result[0][0]
    return id_val && id_val.to_i > 0 ? id_val.to_i : nil
  end

  # Insert new command text
  begin
    result = db.execute(
      "INSERT INTO cmd_texts (command) VALUES (?) RETURNING id",
      [command]
    )
    if result && result[0]
      # Handle both hash and array results
      id_val = result[0].is_a?(Hash) ? result[0]["id"] : result[0][0]
      return id_val && id_val.to_i > 0 ? id_val.to_i : nil
    end
  rescue SQLite3::Exception => e
    if e.message.include?("syntax error") || e.message.include?("RETURNING")
      db.execute("INSERT INTO cmd_texts (command) VALUES (?)", [command])
      last_id = db.last_insert_row_id
      return last_id && last_id.to_i > 0 ? last_id.to_i : nil
    else
      raise e
    end
  end

  return nil
end

def store_command(command_data)
  db = Histlog::DB.initialize_db
  begin
    # Detect if command is private (starts with space) and strip the space
    original_command = command_data[:command]
    is_private = original_command.start_with?(' ') ? 1 : 0
    clean_command = original_command.lstrip # Remove leading whitespace

    # Detect if command is AI-assisted (check VSCODE_INJECTION environment variable)
    is_assisted = ENV['VSCODE_INJECTION'] == '1' ? 1 : 0

    # Get or create cmd_text_id for the cleaned command
    cmd_text_id = get_or_create_cmd_text_id(db, clean_command)

    # Get or create path_id for the command's working directory (cwd_old)
    path_old_id = get_or_create_path_id(db, command_data[:cwd])

    # Use RETURNING clause for thread-safe ID retrieval (SQLite 3.35+)
    result = db.execute(
      "INSERT INTO commands (session_id, cmd_text_id, path_old_id, is_private, is_assisted, start_time) VALUES (?, ?, ?, ?, ?, ?) RETURNING id",
      [
        command_data[:session_id],
        cmd_text_id,
        path_old_id,
        is_private,
        is_assisted,
        Time.now.to_f
      ]
    )
    # Return the command row id from the RETURNING clause
    command_id = result[0][0] if result && result[0]

    # Parse command arguments for path tracking (use clean command)
    if command_id
      parse_command_arguments(db, command_id, clean_command)
    end

    return command_id
  rescue SQLite3::Exception => e
    # Fallback to last_insert_row_id if RETURNING is not supported
    if e.message.include?("syntax error") || e.message.include?("RETURNING")
      STDERR.puts "Warning: RETURNING clause not supported, using fallback method"
      begin
        # Detect if command is private (starts with space) and strip the space
        original_command = command_data[:command]
        is_private = original_command.start_with?(' ') ? 1 : 0
        clean_command = original_command.lstrip # Remove leading whitespace

        cmd_text_id = get_or_create_cmd_text_id(db, clean_command)
        path_old_id = get_or_create_path_id(db, command_data[:cwd])

        db.execute(
          "INSERT INTO commands (session_id, cmd_text_id, path_old_id, is_private, start_time) VALUES (?, ?, ?, ?, ?)",
          [
            command_data[:session_id],
            cmd_text_id,
            path_old_id,
            is_private,
            Time.now.to_f
          ]
        )
        command_id = db.last_insert_row_id

        # Parse command arguments for path tracking (use clean command)
        if command_id
          parse_command_arguments(db, command_id, clean_command)
        end

        return command_id
      rescue SQLite3::Exception => fallback_e
        STDERR.puts "Error storing command: #{fallback_e.message}"
        return nil
      end
    else
      STDERR.puts "Error storing command: #{e.message}"
      return nil
    end
  ensure
    db.close if db
  end
end

def parse_command_arguments(db, command_id, command_text)
  # Parse command into arguments and extract file/directory paths
  #
  # Path Detection Limitations:
  # - Only detects paths that currently exist on the filesystem
  # - Fish history stores raw arguments, but we need absolute paths for tracking
  # - Relative paths are resolved to absolute paths
  # - Non-existent paths are ignored (e.g., deleted files, typos, etc.)
  #
  # This is a simplified parser - could be enhanced for more complex cases
  args = command_text.scan(/(?:[^\s"']+|"[^"]*"|'[^']*')+/).map { |arg| arg.gsub(/^["']|["']$/, '') }

  args.each_with_index do |arg, position|
    # Skip arg0 (the command itself)
    next if position == 0
    # Skip arguments with null bytes or invalid characters
    next if arg.include?("\x00") || arg.empty?

    # Check if argument is a valid path
    begin
      if File.exist?(arg)
        abs_path = File.expand_path(arg)
        path_type = File.directory?(abs_path) ? 'd' : 'f'
        path_id = get_or_create_path_id(db, abs_path, path_type)
        existing = db.execute(
          "SELECT 1 FROM path_args WHERE command_id = ? AND path_id = ? AND arg_position = ? LIMIT 1", [command_id, path_id,
                                                                                                        position]
        )
        unless existing.any?
          db.execute(
            "INSERT INTO path_args (command_id, path_id, arg_position) VALUES (?, ?, ?)",
            [command_id, path_id, position]
          )
        end
      end
    rescue
      # Silently ignore errors
    end
  end
end

def update_command_completion(command_id, duration, exit_code)
  db = Histlog::DB.initialize_db
  begin
    # Get current working directory for cwd_new_id
    cwd_new_id = get_or_create_path_id(db, Dir.pwd)

    # Update commands row with completion data
    db.execute(
      "UPDATE commands SET duration = ?, exit_code = ?, path_new_id = ? WHERE id = ?",
      [duration, exit_code, cwd_new_id, command_id]
    )

    # Get the command text for argument parsing
    result = db.execute(
      "SELECT c.command FROM commands cmd JOIN cmd_texts c ON cmd.cmd_text_id = c.id WHERE cmd.id = ?",
      [command_id]
    )

    if result && result[0]
      command_text = result[0][0]
      # Parse and store command arguments that are valid paths
      parse_command_arguments(db, command_id, command_text)
    end
  rescue SQLite3::Exception => e
    STDERR.puts "Error updating command: #{e.message}"
  ensure
    db.close if db
  end
end

# Remove old function definitions - this is now in Histlog::CLI

# Execute the interactive query with filters
def execute_interactive_query(options)
  # Read-only queries should not create or mutate the database.
  db_path = Histlog::DB.path
  unless File.exist?(db_path)
    STDERR.puts "No histlog.db found in current directory"
    return
  end

  # Open the existing database for read-only queries
  db = SQLite3::Database.new(db_path)
  db.results_as_hash = true
  begin
    # Helper: parse time span strings into seconds.
    # Accepts relative shorthand: 120s, 40m, 4h, 7d, 2w and combined tokens like '1h30m'
    # Accepts verbose forms: '1 hour', '30 minutes', possibly combined ('1 hour 30 minutes')
    # Also accepts absolute timestamps in these example patterns:
    #  - '2025-09-27 19:52:17'
    #  - '2025-09-27 19:52'
    #  - '09-27 19:52' (assumes current year, if in future uses previous year)
    #  - '19:52' (assumes today; if in future uses yesterday)
    # Returns:
    #  - Numeric seconds (>= 0) representing the duration from parsed time to now
    #  - -1 if parsed absolute timestamp is in the future
    #  - nil if parsing fails
    def parse_time_span_to_seconds(str)
      return nil if str.nil?

      raw = str.strip
      s = raw.downcase
      now = Time.now

      # Try absolute timestamp parsing with various formats
      timestamp_formats = [
        '%Y-%m-%d %H:%M:%S',
        '%Y-%m-%d %H:%M',
        '%Y-%m-%d',
        '%m-%d %H:%M:%S',
        '%m-%d %H:%M',
        '%m-%d',
        '%H:%M:%S',
        '%H:%M'
      ]

      timestamp_formats.each do |fmt|
        begin
          parsed = nil
          if fmt.start_with?('%Y')
            parsed = Time.strptime(raw, fmt) rescue nil
          elsif fmt.start_with?('%m-%d')
            # attach current year
            try = Time.strptime("#{now.year}-#{raw}", "%Y-#{fmt}") rescue nil
            parsed = try
            # if parsed is in the future, try previous year
            if parsed && parsed > now
              parsed = Time.new(parsed.year - 1, parsed.month, parsed.day, parsed.hour, parsed.min, parsed.sec)
            end
          else
            # time-only formats: assume today
            try = Time.strptime(raw, fmt) rescue nil
            if try
              parsed = Time.new(now.year, now.month, now.day, try.hour, try.min, try.sec)
              # if the parsed time is in the future, assume yesterday
              if parsed > now
                parsed -= 86400
              end
            end
          end

          if parsed
            seconds = (now.to_f - parsed.to_f)
            return -1 if seconds < 0

            return seconds
          end
        rescue ArgumentError
          # try next format
        end
      end

      # Otherwise parse relative tokens (combined and decimals)
      total = 0.0
      matched = false

      # Shorthand tokens like '1.5h', repeated tokens '1h30m'
      s.scan(/(\d+(?:\.\d+)?)\s*([smhdw])/) do |num_s, unit|
        num = num_s.to_f
        matched = true
        case unit
        when 's' then total += num
        when 'm' then total += num * 60
        when 'h' then total += num * 3600
        when 'd' then total += num * 86400
        when 'w' then total += num * 7 * 86400
        end
      end

      # Verbose tokens like '1 hour', '30 minutes'
      s.scan(/(\d+(?:\.\d+)?)\s*(second|seconds|minute|minutes|hour|hours|day|days|week|weeks)/) do |num_s, word|
        num = num_s.to_f
        matched = true
        case word
        when 'second', 'seconds' then total += num
        when 'minute', 'minutes' then total += num * 60
        when 'hour', 'hours' then total += num * 3600
        when 'day', 'days' then total += num * 86400
        when 'week', 'weeks' then total += num * 7 * 86400
        end
      end

      return nil unless matched

      total % 1 == 0 ? total.to_i : total
    end
    # Build the base query
    query_parts = []
    params = []

    # Base SELECT with joins
    base_query = <<-SQL
    SELECT
      c.id AS command_id,
      COALESCE(cmd.command, '') AS cmd_text,
      c.created_at,
      c.start_time,
      c.duration,
      c.exit_code,
      c.is_private,
      c.is_assisted,
      p_old.path as cwd_old,
      p_new.path as cwd_new,
      s.id as session_id,
      s.pid,
      sh.path as shell_path,
      t.device as tty_device
  FROM commands c
  LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
      LEFT JOIN sessions s ON c.session_id = s.id
      LEFT JOIN shells sh ON s.shell_id = sh.id
      LEFT JOIN ttys t ON s.tty_id = t.id
      LEFT JOIN paths p_old ON c.path_old_id = p_old.id
      LEFT JOIN paths p_new ON c.path_new_id = p_new.id
    SQL

    # Add WHERE conditions based on options
    where_conditions = []

    # Search term filter (optional)
    if options[:regex] && options[:search_term] && !options[:search_term].empty?
      where_conditions << "cmd.command REGEXP ?"
      params << options[:search_term]
    elsif options[:search_term] && !options[:search_term].empty?
      where_conditions << "cmd.command LIKE ?"
      params << "%#{options[:search_term]}%"
    end

    # Session filter
    if options[:session]
      if options[:session_id]
        where_conditions << "s.id = ?"
        params << options[:session_id]
      else
        # Find current session from environment variable set by shell integration
        # Read current session id from environment (new name matching table `sessions`)
        current_session_id = ENV['__histlog_session_id']
        if current_session_id
          where_conditions << "s.id = ?"
          params << current_session_id.to_i
        else
          # If no current session ID, return no results
          where_conditions << "s.id IS NULL"
        end
      end
    end

    # Directory filter
    if options[:dir]
      dir_path = options[:dir_path] || Dir.pwd
      abs_dir = File.expand_path(dir_path)
      where_conditions << "p_old.path = ?"
      params << abs_dir
    end

    # Status filters
    if options[:failed]
      where_conditions << "c.exit_code != 0"
    elsif options[:success]
      where_conditions << "c.exit_code = 0"
    elsif options[:exit_code]
      where_conditions << "c.exit_code = ?"
      params << options[:exit_code]
    end

    # Private command filters
    if options[:private]
      where_conditions << "c.is_private = 1"
    elsif options[:no_private]
      where_conditions << "c.is_private = 0"
      # Default: show private commands unless explicitly excluded
    end

    # AI-assisted command filters
    if options[:assisted]
      where_conditions << "c.is_assisted = 1"
    elsif options[:no_assisted]
      where_conditions << "c.is_assisted != 1"
      # Default: show all commands regardless of AI assistance unless explicitly filtered
    end

    # Imported / non-imported filtering
    if options[:imported]
      # Imported commands have no session ID
      where_conditions << "c.session_id IS NULL"
    elsif options[:no_imported]
      # Only show commands that belong to sessions
      where_conditions << "c.session_id IS NOT NULL"
    end

    # Time filters
    if options[:today]
      # Convert start of today to Julian day
      today_start_unix = Time.new(Time.now.year, Time.now.month, Time.now.day).to_f
      today_start_julian = (today_start_unix / 86400.0) + 2440587.5
      where_conditions << "c.created_at >= ?"
      params << today_start_julian
    elsif options[:yesterday]
      # Start of yesterday (00:00) and start of today (exclusive upper bound)
      today_start_unix = Time.new(Time.now.year, Time.now.month, Time.now.day).to_f
      yesterday_start_unix = (Time.new(Time.now.year, Time.now.month, Time.now.day) - 86400).to_f
      yesterday_start_julian = (yesterday_start_unix / 86400.0) + 2440587.5
      today_start_julian = (today_start_unix / 86400.0) + 2440587.5
      where_conditions << "c.created_at >= ?"
      params << yesterday_start_julian
      where_conditions << "c.created_at < ?"
      params << today_start_julian
    elsif options[:week]
      # Get start of week (Monday)
      now = Time.now
      days_since_monday = (now.wday + 6) % 7 # Convert Sunday=0 to Monday=0
      week_start_unix = (Time.new(now.year, now.month, now.day) - (days_since_monday * 86400)).to_f
      week_start_julian = (week_start_unix / 86400.0) + 2440587.5
      where_conditions << "c.created_at >= ?"
      params << week_start_julian
    elsif options[:since]
      # Parse relative time from flexible formats like '120s', '40m', '4h', '7d', '2w' or verbose '1 hour'
      seconds = parse_time_span_to_seconds(options[:since])
      if seconds.nil?
        STDERR.puts "Invalid time span for --since: '#{options[:since]}'. Use formats like 120s, 40m, 4h, 7d, 2w or '1 hour', or absolute timestamps like '2025-09-27 19:52'."
        db.close if db
        exit 2
      end
      if seconds < 0
        STDERR.puts "The absolute timestamp provided for --since is in the future: '#{options[:since]}'"
        db.close if db
        exit 2
      end
      since_unix = Time.now.to_f - seconds
      since_julian = (since_unix / 86400.0) + 2440587.5
      where_conditions << "c.created_at >= ?"
      params << since_julian
    elsif options[:after]
      # Parse date
      begin
        after_unix = Time.parse(options[:after]).to_f
        after_julian = (after_unix / 86400.0) + 2440587.5
        where_conditions << "c.created_at >= ?"
        params << after_julian
      rescue ArgumentError
        STDERR.puts "Invalid date format: #{options[:after]}"
        return
      end
    end

    # Performance filters (duration-based)
    if options[:quick]
      where_conditions << "c.duration < 1.0"
    elsif options[:slow]
      where_conditions << "c.duration > 10.0"
    elsif options[:fast]
      where_conditions << "c.duration < 0.1"
    elsif options[:instant]
      where_conditions << "c.duration < 0.01"
    elsif options[:background]
      where_conditions << "c.duration > 60.0"
    end

    # Command length filters
    if options[:long]
      where_conditions << "LENGTH(cmd.command) > 50"
    end

    # Shell and TTY filters
    if options[:shell]
      where_conditions << "sh.path LIKE ?"
      params << "%#{options[:shell]}%"
    end

    if options[:tty]
      where_conditions << "t.device LIKE ?"
      params << "%#{options[:tty]}%"
    end

    # Path-related filters
    if options[:has_paths]
      base_query += " JOIN path_args a ON c.id = a.command_id"
      where_conditions << "a.path_id IS NOT NULL"
    end

    if options[:path]
      base_query += " JOIN path_args a ON c.id = a.command_id JOIN paths p_arg ON a.path_id = p_arg.id"
      where_conditions << "p_arg.path LIKE ?"
      params << "%#{options[:path]}%"
    end

    # Argument count filters
    if options[:with_args]
      # Select commands with at least one argument (not just path_args)
      where_conditions << "(LENGTH(TRIM(cmd.command)) - LENGTH(REPLACE(TRIM(cmd.command), ' ', ''))) > 0"
    elsif options[:no_args]
      # Select commands with no arguments (not just no path_args)
      where_conditions << "(LENGTH(TRIM(cmd.command)) - LENGTH(REPLACE(TRIM(cmd.command), ' ', ''))) = 0"
    elsif options[:arg_count]
      # Select commands with exactly N arguments (argument count = number of spaces)
      where_conditions << "(LENGTH(TRIM(cmd.command)) - LENGTH(REPLACE(TRIM(cmd.command), ' ', ''))) = ?"
      params << options[:arg_count]
    end

    # Frequency filters require subqueries
    if options[:rare] || options[:frequent]
      frequency_subquery = <<-SQL
  (SELECT COUNT(*) FROM commands c2 WHERE c2.cmd_text_id = c.cmd_text_id)
      SQL

      if options[:rare]
        where_conditions << "#{frequency_subquery} < 3"
      elsif options[:frequent]
        where_conditions << "#{frequency_subquery} > 10"
      end
    end

    # Unique filter - show only first occurrence of each command (deduplication)
    if options[:unique]
      where_conditions << "c.id = (SELECT MIN(c2.id) FROM commands c2 WHERE c2.cmd_text_id = c.cmd_text_id)"
    end

    # Combine query parts
    full_query = base_query
    if where_conditions.any?
      full_query += " WHERE " + where_conditions.join(" AND ")
    end

    # Add GROUP BY to handle potential duplicates from JOINs, but preserve individual command executions
    full_query += " GROUP BY c.id"

    # Order by start_time (actual execution time), then created_at, then command_id for strict chronological order
    # For limited results, we need to get the most recent N commands first, then apply user's sort preference
    if options[:limit]
      # If limit is negative, user asked for the earliest N results (first N)
      if options[:limit] < 0
        full_query += " ORDER BY c.start_time ASC, c.created_at ASC, c.id ASC"
      else
        # Always get the most recent N commands first
        full_query += " ORDER BY c.start_time DESC, c.created_at DESC, c.id DESC"
      end
    else
      # For unlimited results, apply user's sort preference directly (default: oldest first - chronological)
      if options[:desc]
        order = "DESC"
      else
        order = "ASC" # Default behavior - chronological order
      end
      full_query += " ORDER BY c.start_time #{order}, c.created_at #{order}, c.id #{order}"
    end

    # We'll handle LIMIT at execution time to account for any rows filtered out in Ruby
    # (for example, excluding currently-running commands where duration IS NULL).
    # Do not append a SQL LIMIT here; instead we'll iteratively fetch enough rows below.

    # Execute query. If a limit was requested, do an iterative fetch that
    # over-requests rows (exponential backoff) until we have enough non-running
    # rows or there are no more rows to fetch. This avoids returning fewer
    # results than the requested limit when some rows are filtered out in Ruby.
    begin
      if options[:limit]
        raw_limit = options[:limit]
        # Negative limit now means: return the first (earliest) N results.
        # Use absolute value for requested count; start at offset 0.
        requested = raw_limit < 0 ? raw_limit.abs : raw_limit
        start_offset = 0
        current_limit = [requested * 2, 50].max
        max_limit = 5000
        results = []
        offset = start_offset

        loop do
          # Build limited query for this iteration
          limited_query = full_query + " LIMIT #{current_limit} OFFSET #{offset}"
          all_results = db.execute(limited_query, params)

          # Filter out running commands (duration nil)
          filtered = all_results.reject { |row| row['duration'].nil? }

          # Append unique new results
          results.concat(filtered)

          # If we have enough results, stop
          break if results.size >= requested

          # If fewer rows were returned than requested in SQL, no more data available
          break if all_results.size < current_limit

          # Otherwise, advance offset and increase limit to fetch more rows
          offset += current_limit
          current_limit = [current_limit * 2, max_limit].min
          # If we've reached the max_limit, avoid infinite loop
          break if current_limit >= max_limit
        end

        # Truncate to requested size
        results = results.take(requested)
        # When we fetched limited results we used ORDER BY DESC to pick the most recent set.
        # Ensure display order is chronological (oldest -> newest) unless the user explicitly
        # requested descending output with --desc. Use explicit sort by start_time to be robust.
        unless options[:desc]
          results = results.sort_by { |r| r['start_time'] || 0 }
        end
      else
        all_results = db.execute(full_query, params)
        results = all_results.reject do |row|
          # Exclude if duration is null (still running)
          row['duration'].nil?
        end
      end
    rescue SQLite3::SQLException => e
      # Fallback: if REGEXP is not supported, filter in Ruby
      if options[:regex] && options[:search_term] && e.message =~ /no such function: REGEXP/
        results = db.execute(full_query.sub(/cmd\.command REGEXP \?/, '1'), params[0..-2]) # get all
        begin
          re = Regexp.new(options[:search_term])
          results = results.select { |row| row['cmd_text'] =~ re }
        rescue RegexpError => re_err
          STDERR.puts "Invalid regex: #{re_err.message}"
          results = []
        end
      else
        raise e
      end
    end

    # Handle delete options
    if options[:delete] || options[:force_delete]
      if results.empty?
        puts "No matching commands to delete."
        db.close
        return
      end
      # List matching commands
      puts "Matching commands to delete:"
      results.each do |row|
        puts "  [ID: #{row['command_id']}] #{row['cmd_text']}"
      end
      if options[:delete]
        print "Are you sure you want to delete these commands? Type 'yes' to confirm: "
        confirm = STDIN.gets.strip
        unless confirm.downcase == 'yes'
          puts "Aborted. No commands deleted."
          db.close
          return
        end
      end
      # Delete matching commands
      ids = results.map { |row| row['command_id'] }
      ids.each do |id|
        db.execute("DELETE FROM commands WHERE id = ?", [id])
        db.execute("DELETE FROM path_args WHERE command_id = ?", [id])
      end
      puts "Deleted #{ids.size} commands."

      # Cleanup orphaned entries after deletion
      cleanup_orphaned_entries(db)
      db.close
      return
    end

    # Output results
    if options[:format]
      output_formatted_results(results, options)
    else
      output_interactive_results(results, options)
    end
  rescue SQLite3::Exception => e
    STDERR.puts "Database error: #{e.message}"
  ensure
    db.close if db
  end
end

# Remove old function definitions - these are now in Histlog::Reporting and Histlog::Import

module Histlog
  # MCP (Model Context Protocol) server module
  module MCP
    module_function

    def handle_mcp_server(args)
      require 'json'

      options = {
        trace_level: nil # basic, verbose, full, debug
      }

      OptionParser.new do |opts|
        opts.banner = "Usage: histlog mcp [--trace=LEVEL]"
        opts.on("--trace=LEVEL", ["basic", "verbose", "full", "debug"],
                "Enable tracing (basic: method calls + timing, verbose: + request/response summaries, full: + complete JSON payloads, debug: + internal state + SQL queries)") do |level|
          options[:trace_level] = level
        end
        opts.on("-h", "--help", "Show this help") do
          show_mcp_help
          exit 0
        end
      end.parse!(args)

      # Set global trace level for use in server functions
      @mcp_trace_level = options[:trace_level]

      run_mcp_stdio_server
    end

    # MCP Logging helpers - support multiple trace levels
    def mcp_log(level, message)
      return unless @mcp_trace_level

      # Check if current trace level includes the requested level
      levels = ["basic", "verbose", "full", "debug"]
      current_index = levels.index(@mcp_trace_level)
      requested_index = levels.index(level.to_s)

      return if current_index.nil? || requested_index.nil? || requested_index > current_index

      timestamp = Time.now.strftime('%Y-%m-%d %H:%M:%S.%3N')
      STDERR.puts "[#{timestamp}] MCP #{level.upcase}: #{message}"
    end

    # Convenience methods for different trace levels
    def mcp_log_basic(message)
      mcp_log(:basic, message)
    end

    def mcp_log_verbose(message)
      mcp_log(:verbose, message)
    end

    def mcp_log_full(message)
      mcp_log(:full, message)
    end

    def mcp_log_debug(message)
      mcp_log(:debug, message)
    end

    def run_mcp_stdio_server
      STDERR.puts "Starting MCP server using stdio transport..."
      mcp_log_basic("MCP stdio server initialized")

      loop do
        begin
          line = STDIN.gets
          break if line.nil?

          line = line.strip
          next if line.empty?

          request = JSON.parse(line)
          mcp_log_full("Request: #{JSON.generate(request)}")

          response = handle_mcp_request(request)

          mcp_log_full("Response: #{JSON.generate(response)}")
          puts JSON.generate(response)
          STDOUT.flush
        rescue JSON::ParserError => e
          mcp_log_basic("Parse error: #{e.message}")
          error_response = {
            jsonrpc: "2.0",
            error: {
              code: -32700,
              message: "Parse error: #{e.message}"
            }
          }
          puts JSON.generate(error_response)
          STDOUT.flush
        rescue => e
          STDERR.puts "MCP Server error: #{e.message}"
          STDERR.puts e.backtrace.join("\n")
        end
      end
    end

    def handle_mcp_request(request)
      method = request["method"]
      params = request["params"] || {}
      id = request["id"]

      mcp_log_basic("Processing method: #{method}")

      case method
      when "initialize"
        mcp_log_verbose("Initialize request")
        {
          jsonrpc: "2.0",
          id: id,
          result: {
            protocolVersion: "2024-11-05",
            capabilities: {
              tools: {}
            },
            serverInfo: {
              name: "histlog",
              version: "1.0.0"
            }
          }
        }

      when "tools/list"
        mcp_log_verbose("Tools list request")
        {
          jsonrpc: "2.0",
          id: id,
          result: {
            tools: [
              {
                name: "query_commands",
                description: "Search command history with optional filters",
                inputSchema: {
                  type: "object",
                  properties: {
                    search_term: { type: "string", description: "Search term to filter commands" },
                    limit: { type: "integer", description: "Maximum number of results (default: 50)" },
                    session: { type: "integer", description: "Filter by session ID" },
                    dir: { type: "string", description: "Filter by working directory path" },
                    failed: { type: "boolean", description: "Only show failed commands (exit code != 0)" },
                    success: { type: "boolean", description: "Only show successful commands (exit code = 0)" },
                    exitcode: { type: "integer", description: "Filter by specific exit code" },
                    unique: { type: "boolean", description: "Show only unique commands (deduplicated)" },
                    shell: { type: "string", description: "Filter by shell name (fish, zsh, bash, etc.)" },
                    private: { type: "boolean", description: "Filter by private status (commands starting with space)" },
                    imported: { type: "boolean",
                                description: "Filter by import status (true for imported, false for live commands)" },
                    assisted: { type: "boolean", description: "Filter by AI assistance status" },
                    today: { type: "boolean", description: "Only show commands from today" },
                    week: { type: "boolean", description: "Only show commands from this week" }
                  }
                }
              },
              {
                name: "get_command_stats",
                description: "Get usage statistics and most frequent commands",
                inputSchema: {
                  type: "object",
                  properties: {
                    limit: { type: "integer", description: "Number of top commands to show (default: 10)" }
                  }
                }
              },
              {
                name: "get_database_info",
                description: "Get information about the histlog database",
                inputSchema: {
                  type: "object",
                  properties: {}
                }
              },
              {
                name: "analyze_patterns",
                description: "Analyze command usage patterns and provide insights",
                inputSchema: {
                  type: "object",
                  properties: {
                    days: { type: "integer", description: "Number of days to analyze (default: 30)" }
                  }
                }
              },
              {
                name: "query_paths",
                description: "Search and filter filesystem paths tracked by histlog",
                inputSchema: {
                  type: "object",
                  properties: {
                    search_term: { type: "string", description: "Search term to filter paths" },
                    type: { type: "string", enum: ["file", "dir", "both"],
                            description: "Filter by path type (default: both)" },
                    limit: { type: "integer", description: "Maximum number of results (default: 50)" },
                    sort_by: { type: "string", enum: ["path", "usage", "exec_count", "arg_count"],
                               description: "Sort results by (default: usage)" }
                  }
                }
              },
              {
                name: "get_path_stats",
                description: "Get statistics about filesystem path usage",
                inputSchema: {
                  type: "object",
                  properties: {
                    limit: { type: "integer", description: "Number of top paths to show (default: 10)" }
                  }
                }
              },
              {
                name: "analyze_path_patterns",
                description: "Analyze filesystem path usage patterns and access frequency",
                inputSchema: {
                  type: "object",
                  properties: {
                    days: { type: "integer", description: "Number of days to analyze (default: 30)" },
                    depth: { type: "integer", description: "Directory depth to analyze (default: 3)" }
                  }
                }
              }
            ]
          }
        }

      when "tools/call"
        tool_name = params["name"]
        tool_args = params["arguments"] || {}

        mcp_log_basic("Tool call: #{tool_name}")
        mcp_log_verbose("Tool args: #{JSON.generate(tool_args)}")

        start_time = Time.now
        case tool_name
        when "query_commands"
          result = mcp_query_commands(tool_args)
        when "get_command_stats"
          result = mcp_get_command_stats(tool_args)
        when "get_database_info"
          result = mcp_get_database_info(tool_args)
        when "analyze_patterns"
          result = mcp_analyze_patterns(tool_args)
        when "query_paths"
          result = mcp_query_paths(tool_args)
        when "get_path_stats"
          result = mcp_get_path_stats(tool_args)
        when "analyze_path_patterns"
          result = mcp_analyze_path_patterns(tool_args)
        else
          mcp_log_basic("Unknown tool requested: #{tool_name}")
          return {
            jsonrpc: "2.0",
            id: id,
            error: {
              code: -32601,
              message: "Unknown tool: #{tool_name}"
            }
          }
        end

        duration = ((Time.now - start_time) * 1000).round(2)
        mcp_log_basic("Tool #{tool_name} completed in #{duration}ms")

        {
          jsonrpc: "2.0",
          id: id,
          result: {
            content: [
              {
                type: "text",
                text: result
              }
            ]
          }
        }

      else
        mcp_log_basic("Unknown method requested: #{method}")
        {
          jsonrpc: "2.0",
          id: id,
          error: {
            code: -32601,
            message: "Unknown method: #{method}"
          }
        }
      end
    rescue => e
      mcp_log_basic("Request error: #{e.message}")
      mcp_log_debug("Error backtrace: #{e.backtrace.join('\n')}")
      {
        jsonrpc: "2.0",
        id: id,
        error: {
          code: -32603,
          message: "Internal error: #{e.message}"
        }
      }
    end

    # MCP Tool Implementations

    def mcp_query_commands(args)
      mcp_log_debug("query_commands called with args: #{args.inspect}")

      search_term = args["search_term"]
      limit = args["limit"] || 50
      session_id = args["session"]
      dir_filter = args["dir"]
      failed = args["failed"]
      success = args["success"]
      exitcode = args["exitcode"]
      unique = args["unique"]
      shell_filter = args["shell"]
      private_filter = args["private"]
      imported_filter = args["imported"]
      assisted_filter = args["assisted"]
      today = args["today"]
      week = args["week"]

      db = Histlog::DB.initialize_db
      db.results_as_hash = true

      # Base query with all joins needed for filters
      query = <<~SQL
        SELECT #{unique ? 'DISTINCT' : ''}
          c.id as command_id,
          COALESCE(cmd.command, '') AS cmd_text,
          c.start_time,
          c.exit_code,
          c.is_private,
          c.is_assisted,
          c.duration,
          c.session_id,
          s.shell_id,
          sh.path as shell_path,
          po.path as old_path,
          pn.path as new_path
        FROM commands c
        LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
        LEFT JOIN sessions s ON c.session_id = s.id
        LEFT JOIN shells sh ON s.shell_id = sh.id
        LEFT JOIN paths po ON c.path_old_id = po.id
        LEFT JOIN paths pn ON c.path_new_id = pn.id
        WHERE 1=1
      SQL

      params = []

      # Add all the filter conditions
      if search_term
        query << " AND cmd.command LIKE ?"
        params << "%#{search_term}%"
      end

      if session_id
        query << " AND c.session_id = ?"
        params << session_id
      end

      if dir_filter
        query << " AND (po.path LIKE ? OR pn.path LIKE ?)"
        params << "%#{dir_filter}%"
        params << "%#{dir_filter}%"
      end

      if exitcode
        query << " AND c.exit_code = ?"
        params << exitcode
      elsif failed
        query << " AND c.exit_code != 0"
      elsif success
        query << " AND c.exit_code = 0"
      end

      if shell_filter
        query << " AND sh.path LIKE ?"
        params << "%#{shell_filter}%"
      end

      if private_filter == true
        query << " AND c.is_private = 1"
      elsif private_filter == false
        query << " AND c.is_private = 0"
      end

      if imported_filter == true
        # Imported commands typically have no session_id
        query << " AND c.session_id IS NULL"
      elsif imported_filter == false
        # Live commands have session_id
        query << " AND c.session_id IS NOT NULL"
      end

      if assisted_filter == true
        query << " AND c.is_assisted = 1"
      elsif assisted_filter == false
        query << " AND c.is_assisted = 0"
      end

      if today
        query << " AND date(c.start_time, 'unixepoch') = date('now')"
      elsif week
        query << " AND c.start_time > (strftime('%s', 'now') - 7 * 24 * 3600)"
      end

      query << " ORDER BY c.start_time DESC LIMIT ?"
      params << limit

      mcp_log_debug("Executing SQL query: #{query}")
      mcp_log_debug("Query parameters: #{params.inspect}")

      begin
        results = db.execute(query, params)

        mcp_log_debug("Query returned #{results.length} results")

        if results.empty?
          return "No commands found matching the criteria."
        end

        # Dracula color codes
        # Timestamp: #6272a4, Command: default, Result: âœ“ #50fa7b, âœ— #ff5555, Duration: #bd93f9
        output = ""
        results.each do |row|
          timestamp = row['start_time'] ? Time.at(row['start_time']).strftime('%Y-%m-%d %H:%M:%S') : 'Unknown'
          exit_code = row['exit_code'] || 0
          duration = row['duration'] ? sprintf('%.3fs', row['duration']) : 'Unknown'
          status = exit_code == 0 ? "\e[38;5;84mâœ“\e[0m" : "\e[38;5;203mâœ—#{exit_code}\e[0m"
          ts_col = "\e[38;5;61m"
          dur_col = "\e[38;5;141m"
          output << "[#{ts_col}#{timestamp}\e[0m] #{row['cmd_text']} #{status} #{dur_col}#{duration}\e[0m\n"
        end
        return output
      ensure
        db.close if db
      end
    end

    def mcp_get_command_stats(args)
      limit = args["limit"] || 10

      db = Histlog::DB.initialize_db
      db.results_as_hash = true

      begin
        # Get total commands
        total = db.get_first_value("SELECT COUNT(*) FROM commands")

        # Get most used commands
        most_used = db.execute(<<~SQL, [limit])
          SELECT
            cmd.command,
            COUNT(*) as usage_count,
            AVG(c.duration) as avg_duration
          FROM commands c
          LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
          WHERE cmd.command IS NOT NULL AND cmd.command != ''
          GROUP BY cmd.command
          ORDER BY usage_count DESC
          LIMIT ?
        SQL

        # Get success rate
        success_stats = db.execute(<<~SQL).first
          SELECT
            COUNT(*) as total,
            SUM(CASE WHEN exit_code = 0 THEN 1 ELSE 0 END) as successful,
            AVG(duration) as avg_duration
          FROM commands
          WHERE exit_code IS NOT NULL
        SQL

        output = "=== Command Statistics ===\n\n"
        output << "Total commands: #{total}\n"

        if success_stats && success_stats['total'] > 0
          success_rate = (success_stats['successful'].to_f / success_stats['total'] * 100).round(1)
          avg_duration = success_stats['avg_duration'] ? "#{success_stats['avg_duration'].round(2)}s" : 'Unknown'
          output << "Success rate: #{success_rate}% (#{success_stats['successful']}/#{success_stats['total']})\n"
          output << "Average duration: #{avg_duration}\n"
        end

        output << "\n=== Most Used Commands ===\n"
        most_used.each_with_index do |row, i|
          avg_dur = row['avg_duration'] ? "#{row['avg_duration'].round(2)}s" : 'N/A'
          output << "#{i + 1}. #{row['command']} (#{row['usage_count']} times, avg: #{avg_dur})\n"
        end

        return output
      ensure
        db.close if db
      end
    end

    def mcp_get_database_info(args)
      db_path = Histlog::DB.path

      unless File.exist?(db_path)
        return "No histlog database found at #{db_path}"
      end

      db = Histlog::DB.initialize_db
      db.results_as_hash = true

      begin
        file_size = File.size(db_path)
        file_size_mb = (file_size / 1024.0 / 1024.0).round(2)
        last_modified = File.mtime(db_path).strftime('%Y-%m-%d %H:%M:%S')

        commands_count = db.get_first_value("SELECT COUNT(*) FROM commands")
        cmd_texts_count = db.get_first_value("SELECT COUNT(*) FROM cmd_texts")
        paths_count = db.get_first_value("SELECT COUNT(*) FROM paths")
        sessions_count = db.get_first_value("SELECT COUNT(*) FROM sessions")

        # Get date range
        date_range = db.execute("SELECT MIN(start_time) as earliest, MAX(start_time) as latest FROM commands WHERE start_time IS NOT NULL").first

        output = "=== Histlog Database Information ===\n\n"
        output << "Database path: #{db_path}\n"
        output << "File size: #{file_size_mb} MB (#{file_size} bytes)\n"
        output << "Last modified: #{last_modified}\n\n"

        output << "=== Record Counts ===\n"
        output << "Commands: #{commands_count}\n"
        output << "Unique command texts: #{cmd_texts_count}\n"
        output << "Tracked paths: #{paths_count}\n"
        output << "Sessions: #{sessions_count}\n\n"

        if date_range && date_range['earliest'] && date_range['latest']
          earliest = Time.at(date_range['earliest']).strftime('%Y-%m-%d %H:%M:%S')
          latest = Time.at(date_range['latest']).strftime('%Y-%m-%d %H:%M:%S')
          output << "=== Date Range ===\n"
          output << "Earliest command: #{earliest}\n"
          output << "Latest command: #{latest}\n"
        end

        return output
      ensure
        db.close if db
      end
    end

    def mcp_analyze_patterns(args)
      days = args["days"] || 30

      db = Histlog::DB.initialize_db
      db.results_as_hash = true

      begin
        cutoff_time = Time.now.to_i - (days * 24 * 3600)

        # Commands by hour of day
        hourly_pattern = db.execute(<<~SQL, [cutoff_time])
          SELECT
            strftime('%H', start_time, 'unixepoch', 'localtime') as hour,
            COUNT(*) as count
          FROM commands
          WHERE start_time > ? AND start_time IS NOT NULL
          GROUP BY hour
          ORDER BY hour
        SQL

        # Commands by day of week
        daily_pattern = db.execute(<<~SQL, [cutoff_time])
          SELECT
            strftime('%w', start_time, 'unixepoch', 'localtime') as dow,
            COUNT(*) as count
          FROM commands
          WHERE start_time > ? AND start_time IS NOT NULL
          GROUP BY dow
          ORDER BY dow
        SQL

        # Most failed commands
        failed_commands = db.execute(<<~SQL, [cutoff_time, 5])
          SELECT
            cmd.command,
            COUNT(*) as failure_count,
            COUNT(*) * 100.0 / (
              SELECT COUNT(*) FROM commands c2
              LEFT JOIN cmd_texts cmd2 ON c2.cmd_text_id = cmd2.id
              WHERE cmd2.command = cmd.command AND c2.start_time > ?
            ) as failure_rate
          FROM commands c
          LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
          WHERE c.exit_code != 0 AND c.start_time > ?
            AND cmd.command IS NOT NULL AND cmd.command != ''
          GROUP BY cmd.command
          HAVING COUNT(*) > 1
          ORDER BY failure_count DESC
          LIMIT ?
        SQL

        output = "=== Command Usage Patterns (Last #{days} Days) ===\n\n"

        if hourly_pattern.any?
          output << "=== Usage by Hour of Day ===\n"
          hourly_pattern.each do |row|
            hour = row['hour'].to_i
            count = row['count']
            bar = 'â–ˆ' * [(count / 10.0).ceil, 1].max
            output << "#{hour.to_s.rjust(2)}:00 #{bar} #{count}\n"
          end
          output << "\n"
        end

        if daily_pattern.any?
          days_of_week = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
          output << "=== Usage by Day of Week ===\n"
          daily_pattern.each do |row|
            dow = row['dow'].to_i
            count = row['count']
            day_name = days_of_week[dow]
            bar = 'â–ˆ' * [(count / 50.0).ceil, 1].max
            output << "#{day_name.ljust(9)} #{bar} #{count}\n"
          end
          output << "\n"
        end

        if failed_commands.any?
          output << "=== Most Frequently Failed Commands ===\n"
          failed_commands.each do |row|
            output << "#{row['command']} (#{row['failure_count']} failures, #{row['failure_rate'].round(1)}% failure rate)\n"
          end
        end

        return output
      ensure
        db.close if db
      end
    end

    def show_mcp_help
      puts "histlog MCP (Model Context Protocol) Server"
      puts "==========================================="
      puts ""
      puts "The MCP server provides programmatic access to histlog data through the"
      puts "Model Context Protocol using stdio transport, enabling AI assistants and"
      puts "other clients to query command history, analyze patterns, and access"
      puts "filesystem path data."
      puts ""
      puts "Usage: histlog mcp [--trace=LEVEL]"
      puts ""
      puts "Trace Options:"
      puts "  --trace=basic     Method calls + timing"
      puts "  --trace=verbose   + request/response summaries"
      puts "  --trace=full      + complete JSON payloads"
      puts "  --trace=debug     + internal state + SQL queries"
      puts ""
      puts "Available MCP Tools:"
      puts "  query_commands        Search command history with optional filters"
      puts "  get_command_stats     Get usage statistics and most frequent commands"
      puts "  get_database_info     Show database size, record counts, date ranges"
      puts "  analyze_patterns      Analyze command usage patterns over time"
      puts "  query_paths          Search tracked filesystem paths"
      puts "  get_path_stats       Get filesystem usage statistics"
      puts "  analyze_path_patterns Analyze path access patterns"
      puts ""
      puts "Examples:"
      puts "  histlog mcp                    # Start stdio server (no tracing)"
      puts "  histlog mcp --trace=basic      # Basic tracing: methods + timing"
      puts "  histlog mcp --trace=verbose    # + request/response summaries"
      puts "  histlog mcp --trace=full       # + complete JSON payloads"
      puts "  histlog mcp --trace=debug      # + internal state + SQL queries"
      puts ""
      puts "VS Code Integration:"
      puts "Add to your VS Code mcp.json file:"
      puts '  "histlog": {'
      puts '    "command": "/path/to/histlog",'
      puts '    "args": ["mcp"]'
      puts '  }'
      puts ""
      puts "The server uses stdio transport and provides rich querying capabilities"
      puts "with filters for sessions, directories, exit codes, time ranges, and more."
      puts "Perfect for command analysis, troubleshooting, and development workflow insights."
    end
  end
end

# Show help function
def show_help(show_plumbing = false)
  puts "Usage: histlog <command> [options]"
  puts ""
  puts "Commands:"
  puts "  help            Show this help message"
  puts "  init [SHELL]    Generate shell configuration (fish, zsh, nu)"
  puts "  query [STRING]  Command search and display"
  puts "  stats           Show command history statistics"
  puts "  paths           List all unique file or directory paths (--files, --dirs)"
  puts "  sessions        Show session information"
  puts "  import [FILE]   Import history from shell history files"
  puts "  cleanup         Remove orphaned entries from database"
  puts "  info            Show database and system information"
  puts "  mcp [--trace=LEVEL] Start Model Context Protocol server using stdio transport"
  puts "  maintain        Run database maintenance (see options)"
  puts ""
  puts "Query Filters:"
  puts "  --session [ID]  Commands from current session (requires __histlog_session_id) or specific session ID"
  puts "  --dir [PATH]    Commands executed in current or specific directory"
  puts "  --failed        Only failed commands (exit != 0)"
  puts "  --success       Only successful commands (exit = 0)"
  puts "  --today         Commands from today"
  puts "  --week          Commands from this week"
  puts "  --private       Show only private commands (started with space)"
  puts "  --no-private    Exclude private commands"
  puts "  --quick         Fast commands (< 1s)"
  puts "  --slow          Slow commands (> 10s)"
  puts "  --has-paths     Commands that accessed filesystem paths"
  puts "  --json          Output as JSON"
  puts "  --yaml          Output as YAML"
  puts "  --format FORMAT Output in shell history format (json, yaml, fish, zsh, nu, bash, powershell, plain)"
  puts ""

  if show_plumbing
    puts ""
    puts "Plumbing Commands (for shell integration only):"
    puts "  _on_session     Create new shell session"
    puts "  _on_preexec     Record command start"
    puts "  _on_postcmd     Record command completion"
    puts ""
    puts "These commands are called automatically by shell hooks."
    puts "Users should not invoke them directly."
  end

  puts ""
  puts "Use 'histlog --help-all' to see plumbing commands"
  puts "Use 'histlog query --help' for complete filter options"
  puts "Use 'histlog mcp --help' for MCP server options and examples"
end

def show_mcp_help
  puts "histlog MCP (Model Context Protocol) Server"
  puts "==========================================="
  puts ""
  puts "The MCP server provides programmatic access to histlog data through the"
  puts "Model Context Protocol using stdio transport, enabling AI assistants and"
  puts "other clients to query command history, analyze patterns, and access"
  puts "filesystem path data."
  puts ""
  puts "Usage: histlog mcp [--trace=LEVEL]"
  puts ""
  puts "Trace Options:"
  puts "  --trace=basic     Method calls + timing"
  puts "  --trace=verbose   + request/response summaries"
  puts "  --trace=full      + complete JSON payloads"
  puts "  --trace=debug     + internal state + SQL queries"
  puts ""
  puts "Available MCP Tools:"
  puts "  query_commands        Search command history with optional filters"
  puts "  get_command_stats     Get usage statistics and most frequent commands"
  puts "  get_database_info     Show database size, record counts, date ranges"
  puts "  analyze_patterns      Analyze command usage patterns over time"
  puts "  query_paths          Search tracked filesystem paths"
  puts "  get_path_stats       Get filesystem usage statistics"
  puts "  analyze_path_patterns Analyze path access patterns"
  puts ""
  puts "Examples:"
  puts "  histlog mcp                    # Start stdio server (no tracing)"
  puts "  histlog mcp --trace=basic      # Basic tracing: methods + timing"
  puts "  histlog mcp --trace=verbose    # + request/response summaries"
  puts "  histlog mcp --trace=full       # + complete JSON payloads"
  puts "  histlog mcp --trace=debug      # + internal state + SQL queries"
  puts ""
  puts "VS Code Integration:"
  puts "Add to your VS Code mcp.json file:"
  puts '  "histlog": {'
  puts '    "command": "/path/to/histlog",'
  puts '    "args": ["mcp"]'
  puts '  }'
  puts ""
  puts "The server uses stdio transport and provides rich querying capabilities"
  puts "with filters for sessions, directories, exit codes, time ranges, and more."
  puts "Perfect for command analysis, troubleshooting, and development workflow insights."
end

# Shell configuration functions
def fish_config
  histlog_path = File.expand_path(__FILE__)
  <<~FISH
    #!/usr/bin/env fish
    # histlog configuration for fish shell
    # Add this to your config.fish or source this file

    status --is-interactive; or exit

    if test -z "$__histlog_session_id"
      set -gx __histlog_path "#{histlog_path}"
      set -gx __histlog_session_id (
        $__histlog_path _on_session
      )
    end

    function __histlog_preexec --on-event fish_preexec
      set -gx __histlog_command_id (
        $__histlog_path _on_preexec $argv[1] $__histlog_session_id
      )
    end

    function __histlog_postcmd --on-event fish_postexec
      $__histlog_path _on_postcmd $__histlog_command_id $CMD_DURATION $status
      set --erase __histlog_command_id
    end
  FISH
end

def zsh_config
  histlog_path = File.expand_path(__FILE__)
  <<~ZSH
    #!/usr/bin/env zsh
    # histlog configuration for zsh shell
    # Add this to ~/.zshrc or source this file

    [[ $- != *i* ]] && return

    if [[ -z $__histlog_session_id ]]; then
      export __histlog_path="#{histlog_path}"
      export __histlog_session_id="$($__histlog_path _on_session)"
    fi

    function __histlog_preexec() {
      export __histlog_command_id="$($__histlog_path _on_preexec "$1" "$__histlog_session_id")"
    }

    function __histlog_postexec() {
      $__histlog_path _on_postcmd "$__histlog_command_id" "$CMD_DURATION" "$?"
      unset __histlog_command_id
    }

    autoload -Uz add-zsh-hook
    add-zsh-hook preexec __histlog_preexec
    add-zsh-hook precmd __histlog_postexec
  ZSH
end

def nu_config
  histlog_path = File.expand_path(__FILE__)
  <<~NUSHELL
    #!/usr/bin/env nu
    # histlog configuration for nushell
    # Add this to your config.nu

    if (not $env.INTERACTIVE) { return }

    if ($env.__histlog_session_id? | is-empty) {
      $env.__histlog_path = "#{histlog_path}"
      $env.__histlog_session_id = ^$env.__histlog_path _on_session
    }

    $env.config.hooks = {
      pre_execution: [
        { $env.__histlog_command_id = (^$env.__histlog_path _on_preexec (commandline) $env.__histlog_session_id) }
      ]
      pre_prompt: [
        { ^$env.__histlog_path _on_postcmd $env.__histlog_command_id $env.CMD_DURATION_MS $env.LAST_EXIT_CODE }
        { $env.__histlog_command_id = null }
      ]
    }
  NUSHELL
end

# Main application class
# MCP Server Implementation
# Provides Model Context Protocol server with histlog data access via stdio transport
def handle_mcp_server(args)
  require 'json'

  options = {
    trace_level: nil # basic, verbose, full, debug
  }

  OptionParser.new do |opts|
    opts.banner = "Usage: histlog mcp [--trace=LEVEL]"
    opts.on("--trace=LEVEL", ["basic", "verbose", "full", "debug"],
            "Enable tracing (basic: method calls + timing, verbose: + request/response summaries, full: + complete JSON payloads, debug: + internal state + SQL queries)") do |level|
      options[:trace_level] = level
    end
    opts.on("-h", "--help", "Show this help") do
      show_mcp_help
      exit 0
    end
  end.parse!(args)

  # Set global trace level for use in server functions
  @mcp_trace_level = options[:trace_level]

  run_mcp_stdio_server
end

# MCP Logging helpers - support multiple trace levels
def mcp_log(level, message)
  return unless @mcp_trace_level

  # Check if current trace level includes the requested level
  levels = ["basic", "verbose", "full", "debug"]
  current_index = levels.index(@mcp_trace_level)
  requested_index = levels.index(level.to_s)

  return if current_index.nil? || requested_index.nil? || requested_index > current_index

  timestamp = Time.now.strftime('%Y-%m-%d %H:%M:%S.%3N')
  STDERR.puts "[#{timestamp}] MCP #{level.upcase}: #{message}"
end

# Convenience methods for different trace levels
def mcp_log_basic(message)
  mcp_log(:basic, message)
end

def mcp_log_verbose(message)
  mcp_log(:verbose, message)
end

def mcp_log_full(message)
  mcp_log(:full, message)
end

def mcp_log_debug(message)
  mcp_log(:debug, message)
end

def run_mcp_stdio_server
  STDERR.puts "Starting MCP server using stdio transport..."
  mcp_log_basic("MCP stdio server initialized")

  loop do
    begin
      line = STDIN.gets
      break if line.nil?

      line = line.strip
      next if line.empty?

      request = JSON.parse(line)
      mcp_log_full("Request: #{JSON.generate(request)}")

      response = handle_mcp_request(request)

      mcp_log_full("Response: #{JSON.generate(response)}")
      puts JSON.generate(response)
      STDOUT.flush
    rescue JSON::ParserError => e
      mcp_log_basic("Parse error: #{e.message}")
      error_response = {
        jsonrpc: "2.0",
        error: {
          code: -32700,
          message: "Parse error: #{e.message}"
        }
      }
      puts JSON.generate(error_response)
      STDOUT.flush
    rescue => e
      STDERR.puts "MCP Server error: #{e.message}"
      STDERR.puts e.backtrace.join("\n")
    end
  end
end

def handle_mcp_request(request)
  method = request["method"]
  params = request["params"] || {}
  id = request["id"]

  mcp_log_basic("Processing method: #{method}")

  case method
  when "initialize"
    mcp_log_verbose("Initialize request")
    {
      jsonrpc: "2.0",
      id: id,
      result: {
        protocolVersion: "2024-11-05",
        capabilities: {
          tools: {}
        },
        serverInfo: {
          name: "histlog",
          version: "1.0.0"
        }
      }
    }

  when "tools/list"
    mcp_log_verbose("Tools list request")
    {
      jsonrpc: "2.0",
      id: id,
      result: {
        tools: [
          {
            name: "query_commands",
            description: "Search command history with optional filters",
            inputSchema: {
              type: "object",
              properties: {
                search_term: { type: "string", description: "Search term to filter commands" },
                limit: { type: "integer", description: "Maximum number of results (default: 50)" },
                session: { type: "integer", description: "Filter by session ID" },
                dir: { type: "string", description: "Filter by working directory path" },
                failed: { type: "boolean", description: "Only show failed commands (exit code != 0)" },
                success: { type: "boolean", description: "Only show successful commands (exit code = 0)" },
                exitcode: { type: "integer", description: "Filter by specific exit code" },
                unique: { type: "boolean", description: "Show only unique commands (deduplicated)" },
                shell: { type: "string", description: "Filter by shell name (fish, zsh, bash, etc.)" },
                private: { type: "boolean", description: "Filter by private status (commands starting with space)" },
                imported: { type: "boolean",
                            description: "Filter by import status (true for imported, false for live commands)" },
                assisted: { type: "boolean", description: "Filter by AI assistance status" },
                today: { type: "boolean", description: "Only show commands from today" },
                week: { type: "boolean", description: "Only show commands from this week" }
              }
            }
          },
          {
            name: "get_command_stats",
            description: "Get usage statistics and most frequent commands",
            inputSchema: {
              type: "object",
              properties: {
                limit: { type: "integer", description: "Number of top commands to show (default: 10)" }
              }
            }
          },
          {
            name: "get_database_info",
            description: "Get information about the histlog database",
            inputSchema: {
              type: "object",
              properties: {}
            }
          },
          {
            name: "analyze_patterns",
            description: "Analyze command usage patterns and provide insights",
            inputSchema: {
              type: "object",
              properties: {
                days: { type: "integer", description: "Number of days to analyze (default: 30)" }
              }
            }
          },
          {
            name: "query_paths",
            description: "Search and filter filesystem paths tracked by histlog",
            inputSchema: {
              type: "object",
              properties: {
                search_term: { type: "string", description: "Search term to filter paths" },
                type: { type: "string", enum: ["file", "dir", "both"],
                        description: "Filter by path type (default: both)" },
                limit: { type: "integer", description: "Maximum number of results (default: 50)" },
                sort_by: { type: "string", enum: ["path", "usage", "exec_count", "arg_count"],
                           description: "Sort results by (default: usage)" }
              }
            }
          },
          {
            name: "get_path_stats",
            description: "Get statistics about filesystem path usage",
            inputSchema: {
              type: "object",
              properties: {
                limit: { type: "integer", description: "Number of top paths to show (default: 10)" }
              }
            }
          },
          {
            name: "analyze_path_patterns",
            description: "Analyze filesystem path usage patterns and access frequency",
            inputSchema: {
              type: "object",
              properties: {
                days: { type: "integer", description: "Number of days to analyze (default: 30)" },
                depth: { type: "integer", description: "Directory depth to analyze (default: 3)" }
              }
            }
          }
        ]
      }
    }

  when "tools/call"
    tool_name = params["name"]
    tool_args = params["arguments"] || {}

    mcp_log_basic("Tool call: #{tool_name}")
    mcp_log_verbose("Tool args: #{JSON.generate(tool_args)}")

    start_time = Time.now
    case tool_name
    when "query_commands"
      result = mcp_query_commands(tool_args)
    when "get_command_stats"
      result = mcp_get_command_stats(tool_args)
    when "get_database_info"
      result = mcp_get_database_info(tool_args)
    when "analyze_patterns"
      result = mcp_analyze_patterns(tool_args)
    when "query_paths"
      result = mcp_query_paths(tool_args)
    when "get_path_stats"
      result = mcp_get_path_stats(tool_args)
    when "analyze_path_patterns"
      result = mcp_analyze_path_patterns(tool_args)
    else
      mcp_log_basic("Unknown tool requested: #{tool_name}")
      return {
        jsonrpc: "2.0",
        id: id,
        error: {
          code: -32601,
          message: "Unknown tool: #{tool_name}"
        }
      }
    end

    duration = ((Time.now - start_time) * 1000).round(2)
    mcp_log_basic("Tool #{tool_name} completed in #{duration}ms")

    {
      jsonrpc: "2.0",
      id: id,
      result: {
        content: [
          {
            type: "text",
            text: result
          }
        ]
      }
    }

  else
    mcp_log_basic("Unknown method requested: #{method}")
    {
      jsonrpc: "2.0",
      id: id,
      error: {
        code: -32601,
        message: "Unknown method: #{method}"
      }
    }
  end
rescue => e
  mcp_log_basic("Request error: #{e.message}")
  mcp_log_debug("Error backtrace: #{e.backtrace.join('\n')}")
  {
    jsonrpc: "2.0",
    id: id,
    error: {
      code: -32603,
      message: "Internal error: #{e.message}"
    }
  }
end

# MCP Tool Implementations

def mcp_query_commands(args)
  mcp_log_debug("query_commands called with args: #{args.inspect}")

  search_term = args["search_term"]
  limit = args["limit"] || 50
  session_id = args["session"]
  dir_filter = args["dir"]
  failed = args["failed"]
  success = args["success"]
  exitcode = args["exitcode"]
  unique = args["unique"]
  shell_filter = args["shell"]
  private_filter = args["private"]
  imported_filter = args["imported"]
  assisted_filter = args["assisted"]
  today = args["today"]
  week = args["week"]

  db = Histlog::DB.initialize_db
  db.results_as_hash = true

  # Base query with all joins needed for filters
  query = <<~SQL
    SELECT #{unique ? 'DISTINCT' : ''}
      c.id as command_id,
      COALESCE(cmd.command, '') AS cmd_text,
      c.start_time,
      c.exit_code,
      c.is_private,
      c.is_assisted,
      c.duration,
      c.session_id,
      s.shell_id,
      sh.path as shell_path,
      po.path as old_path,
      pn.path as new_path
    FROM commands c
    LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
    LEFT JOIN sessions s ON c.session_id = s.id
    LEFT JOIN shells sh ON s.shell_id = sh.id
    LEFT JOIN paths po ON c.path_old_id = po.id
    LEFT JOIN paths pn ON c.path_new_id = pn.id
    WHERE 1=1
  SQL

  params = []

  # Add all the filter conditions
  if search_term
    query << " AND cmd.command LIKE ?"
    params << "%#{search_term}%"
  end

  if session_id
    query << " AND c.session_id = ?"
    params << session_id
  end

  if dir_filter
    query << " AND (po.path LIKE ? OR pn.path LIKE ?)"
    params << "%#{dir_filter}%"
    params << "%#{dir_filter}%"
  end

  if exitcode
    query << " AND c.exit_code = ?"
    params << exitcode
  elsif failed
    query << " AND c.exit_code != 0"
  elsif success
    query << " AND c.exit_code = 0"
  end

  if shell_filter
    query << " AND sh.path LIKE ?"
    params << "%#{shell_filter}%"
  end

  if private_filter == true
    query << " AND c.is_private = 1"
  elsif private_filter == false
    query << " AND c.is_private = 0"
  end

  if imported_filter == true
    # Imported commands typically have no session_id
    query << " AND c.session_id IS NULL"
  elsif imported_filter == false
    # Live commands have session_id
    query << " AND c.session_id IS NOT NULL"
  end

  if assisted_filter == true
    query << " AND c.is_assisted = 1"
  elsif assisted_filter == false
    query << " AND c.is_assisted = 0"
  end

  if today
    query << " AND date(c.start_time, 'unixepoch') = date('now')"
  elsif week
    query << " AND c.start_time > (strftime('%s', 'now') - 7 * 24 * 3600)"
  end

  query << " ORDER BY c.start_time DESC LIMIT ?"
  params << limit

  mcp_log_debug("Executing SQL query: #{query}")
  mcp_log_debug("Query parameters: #{params.inspect}")

  begin
    results = db.execute(query, params)

    mcp_log_debug("Query returned #{results.length} results")

    if results.empty?
      return "No commands found matching the criteria."
    end

    # Dracula color codes
    # Timestamp: #6272a4, Command: default, Result: âœ“ #50fa7b, âœ— #ff5555, Duration: #bd93f9
    output = ""
    results.each do |row|
      timestamp = row['start_time'] ? Time.at(row['start_time']).strftime('%Y-%m-%d %H:%M:%S') : 'Unknown'
      exit_code = row['exit_code'] || 0
      duration = row['duration'] ? sprintf('%.3fs', row['duration']) : 'Unknown'
      status = exit_code == 0 ? "\e[38;5;84mâœ“\e[0m" : "\e[38;5;203mâœ—#{exit_code}\e[0m"
      ts_col = "\e[38;5;61m"
      dur_col = "\e[38;5;141m"
      output << "[#{ts_col}#{timestamp}\e[0m] #{row['cmd_text']} #{status} #{dur_col}#{duration}\e[0m\n"
    end
    return output
  ensure
    db.close if db
  end
end

def mcp_get_command_stats(args)
  limit = args["limit"] || 10

  db = Histlog::DB.initialize_db
  db.results_as_hash = true

  begin
    # Get total commands
    total = db.get_first_value("SELECT COUNT(*) FROM commands")

    # Get most used commands
    most_used = db.execute(<<~SQL, [limit])
      SELECT
        cmd.command,
        COUNT(*) as usage_count,
        AVG(c.duration) as avg_duration
      FROM commands c
      LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
      WHERE cmd.command IS NOT NULL AND cmd.command != ''
      GROUP BY cmd.command
      ORDER BY usage_count DESC
      LIMIT ?
    SQL

    # Get success rate
    success_stats = db.execute(<<~SQL).first
      SELECT
        COUNT(*) as total,
        SUM(CASE WHEN exit_code = 0 THEN 1 ELSE 0 END) as successful,
        AVG(duration) as avg_duration
      FROM commands
      WHERE exit_code IS NOT NULL
    SQL

    output = "=== Command Statistics ===\n\n"
    output << "Total commands: #{total}\n"

    if success_stats && success_stats['total'] > 0
      success_rate = (success_stats['successful'].to_f / success_stats['total'] * 100).round(1)
      avg_duration = success_stats['avg_duration'] ? "#{success_stats['avg_duration'].round(2)}s" : 'Unknown'
      output << "Success rate: #{success_rate}% (#{success_stats['successful']}/#{success_stats['total']})\n"
      output << "Average duration: #{avg_duration}\n"
    end

    output << "\n=== Most Used Commands ===\n"
    most_used.each_with_index do |row, i|
      avg_dur = row['avg_duration'] ? "#{row['avg_duration'].round(2)}s" : 'N/A'
      output << "#{i + 1}. #{row['command']} (#{row['usage_count']} times, avg: #{avg_dur})\n"
    end

    return output
  ensure
    db.close if db
  end
end

def mcp_get_database_info(args)
  db_path = Histlog::DB.path

  unless File.exist?(db_path)
    return "No histlog database found at #{db_path}"
  end

  db = Histlog::DB.initialize_db
  db.results_as_hash = true

  begin
    file_size = File.size(db_path)
    file_size_mb = (file_size / 1024.0 / 1024.0).round(2)
    last_modified = File.mtime(db_path).strftime('%Y-%m-%d %H:%M:%S')

    commands_count = db.get_first_value("SELECT COUNT(*) FROM commands")
    cmd_texts_count = db.get_first_value("SELECT COUNT(*) FROM cmd_texts")
    paths_count = db.get_first_value("SELECT COUNT(*) FROM paths")
    sessions_count = db.get_first_value("SELECT COUNT(*) FROM sessions")

    # Get date range
    date_range = db.execute("SELECT MIN(start_time) as earliest, MAX(start_time) as latest FROM commands WHERE start_time IS NOT NULL").first

    output = "=== Histlog Database Information ===\n\n"
    output << "Database path: #{db_path}\n"
    output << "File size: #{file_size_mb} MB (#{file_size} bytes)\n"
    output << "Last modified: #{last_modified}\n\n"

    output << "=== Record Counts ===\n"
    output << "Commands: #{commands_count}\n"
    output << "Unique command texts: #{cmd_texts_count}\n"
    output << "Tracked paths: #{paths_count}\n"
    output << "Sessions: #{sessions_count}\n\n"

    if date_range && date_range['earliest'] && date_range['latest']
      earliest = Time.at(date_range['earliest']).strftime('%Y-%m-%d %H:%M:%S')
      latest = Time.at(date_range['latest']).strftime('%Y-%m-%d %H:%M:%S')
      output << "=== Date Range ===\n"
      output << "Earliest command: #{earliest}\n"
      output << "Latest command: #{latest}\n"
    end

    return output
  ensure
    db.close if db
  end
end

def mcp_analyze_patterns(args)
  days = args["days"] || 30

  db = Histlog::DB.initialize_db
  db.results_as_hash = true

  begin
    cutoff_time = Time.now.to_i - (days * 24 * 3600)

    # Commands by hour of day
    hourly_pattern = db.execute(<<~SQL, [cutoff_time])
      SELECT
        strftime('%H', start_time, 'unixepoch', 'localtime') as hour,
        COUNT(*) as count
      FROM commands
      WHERE start_time > ? AND start_time IS NOT NULL
      GROUP BY hour
      ORDER BY hour
    SQL

    # Commands by day of week
    daily_pattern = db.execute(<<~SQL, [cutoff_time])
      SELECT
        strftime('%w', start_time, 'unixepoch', 'localtime') as dow,
        COUNT(*) as count
      FROM commands
      WHERE start_time > ? AND start_time IS NOT NULL
      GROUP BY dow
      ORDER BY dow
    SQL

    # Most failed commands
    failed_commands = db.execute(<<~SQL, [cutoff_time, 5])
      SELECT
        cmd.command,
        COUNT(*) as failure_count,
        COUNT(*) * 100.0 / (
          SELECT COUNT(*) FROM commands c2
          LEFT JOIN cmd_texts cmd2 ON c2.cmd_text_id = cmd2.id
          WHERE cmd2.command = cmd.command AND c2.start_time > ?
        ) as failure_rate
      FROM commands c
      LEFT JOIN cmd_texts cmd ON c.cmd_text_id = cmd.id
      WHERE c.exit_code != 0 AND c.start_time > ?
        AND cmd.command IS NOT NULL AND cmd.command != ''
      GROUP BY cmd.command
      HAVING COUNT(*) > 1
      ORDER BY failure_count DESC
      LIMIT ?
    SQL

    output = "=== Command Usage Patterns (Last #{days} Days) ===\n\n"

    if hourly_pattern.any?
      output << "=== Usage by Hour of Day ===\n"
      hourly_pattern.each do |row|
        hour = row['hour'].to_i
        count = row['count']
        bar = 'â–ˆ' * [(count / 10.0).ceil, 1].max
        output << "#{hour.to_s.rjust(2)}:00 #{bar} #{count}\n"
      end
      output << "\n"
    end

    if daily_pattern.any?
      days_of_week = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
      output << "=== Usage by Day of Week ===\n"
      daily_pattern.each do |row|
        dow = row['dow'].to_i
        count = row['count']
        day_name = days_of_week[dow]
        bar = 'â–ˆ' * [(count / 50.0).ceil, 1].max
        output << "#{day_name.ljust(9)} #{bar} #{count}\n"
      end
      output << "\n"
    end

    if failed_commands.any?
      output << "=== Most Frequently Failed Commands ===\n"
      failed_commands.each do |row|
        output << "#{row['command']} (#{row['failure_count']} failures, #{row['failure_rate'].round(1)}% failure rate)\n"
      end
    end

    return output
  ensure
    db.close if db
  end
end

class HistlogApp
  def initialize(argv)
    @argv = argv
    @command = @argv.shift
  end

  def run
    # Handle help flags first
    if @command == '--help-all'
      show_help(true)

      return
    elsif @command == '-h' || @command == '--help' || @command.nil?
      show_help(false)
      return
    end

    # Define known commands
    known_commands = ['query', 'stats', 'history', 'sessions', 'import', 'help', 'init', 'paths', 'cleanup', 'info',
                      'mcp', 'maintain', '_on_session', '_on_preexec', '_on_postcmd']

    if !known_commands.include?(@command) && !@command.start_with?('-')
      STDERR.puts "Error: Unknown command '#{@command}'"
      STDERR.puts "Use 'histlog help' to see available commands"
      exit 1
    end

    case @command
    when 'help'
      Histlog::CLI.show_help(false)
    when '--help-all'
      Histlog::CLI.show_help(true)
    when 'init'
      Histlog::CLI.handle_init
    when 'query'
      Histlog::CLI.query_interactive(@argv)
    when 'stats'
      Histlog::CLI.show_advanced_stats(@argv)
    when 'history'
      Histlog::CLI.show_history_list(@argv)
    when 'sessions'
      Histlog::CLI.query_sessions(@argv)
    when 'import'
      Histlog::Import.import_shell_history(@argv)
    when 'paths'
      Histlog::CLI.show_paths_command(@argv)
    when 'cleanup'
      Histlog::CLI.handle_cleanup(@argv)
    when 'info'
      Histlog::CLI.handle_info(@argv)
    when 'mcp'
      Histlog::MCP.handle_mcp_server(@argv)
    when 'maintain'
      Histlog::CLI.handle_maintain(@argv)
    when '_on_session'
      handle_on_session
    when '_on_preexec'
      handle_on_preexec
    when '_on_postcmd'
      handle_on_postcmd
    else
      # This case may be triggered by unhandled options passed as commands
      # Re-insert the "command" and let query_interactive handle it
      @argv.unshift(@command)
      query_interactive(@argv)
    end
  end

  private

  def handle_init
    shell = @argv[0]
    case shell
    when 'fish'
      puts "# Add to ~/.config/fish/config.fish:"
      puts "# histlog init fish | source"
      puts ""
      puts fish_config
    when 'zsh'
      puts "# Add to ~/.zshrc:"
      puts "# eval \"$(histlog init zsh)\""
      puts ""
      puts zsh_config
    when 'nu', 'nushell'
      puts "# Add to ~/.config/nushell/config.nu:"
      puts "# histlog init nu | save /tmp/histlog-nu-config.nu; source /tmp/histlog-nu-config.nu"
      puts ""
      puts nu_config
    else
      STDERR.puts "Error: Unsupported shell '#{shell}'"
      STDERR.puts "Supported shells: fish, zsh, nu"
      STDERR.puts "Usage: histlog init <shell>"
      exit 1
    end
  end

  # Unified maintenance command
  def handle_maintain(args)
    require 'optparse'
    options = {
      cleanup: false,
      optimize: false,
      vacuum: false,
      integrity: false,
      all: false
    }

    OptionParser.new do |opts|
      opts.banner = "Usage: histlog maintain [options]"
      opts.on("--cleanup", "Remove orphaned entries from database") { options[:cleanup] = true }
      opts.on("--optimize", "Optimize database (ANALYZE, REINDEX, VACUUM)") { options[:optimize] = true }
      opts.on("--vacuum", "Run VACUUM to defragment database") { options[:vacuum] = true }
      opts.on("--integrity", "Run PRAGMA integrity_check") { options[:integrity] = true }
      opts.on("--all", "Run all maintenance actions") { options[:all] = true }
      opts.on("-h", "--help", "Show this help") do
        puts opts
        exit 0
      end
    end.parse!(args)

    db_path = Histlog::DB.path
    unless File.exist?(db_path)
      puts "No histlog.db found in current directory"
      return
    end

    db = SQLite3::Database.new(db_path)
    db.results_as_hash = true

    actions = []
    actions << :cleanup if options[:cleanup] || options[:all]
    actions << :optimize if options[:optimize] || options[:all]
    actions << :vacuum if options[:vacuum] || options[:all]
    actions << :integrity if options[:integrity] || options[:all]

    if actions.empty?
      # No options: show short report and ask for confirmation
      puts "=== Histlog Maintenance Preview ==="
      # Preview orphaned entries
      orphan_paths = db.get_first_value(<<-SQL)
        SELECT COUNT(*) FROM paths p
        LEFT JOIN commands c1 ON p.id = c1.path_old_id
        LEFT JOIN commands c2 ON p.id = c2.path_new_id
        LEFT JOIN path_args pa ON p.id = pa.path_id
        WHERE c1.id IS NULL AND c2.id IS NULL AND pa.command_id IS NULL
      SQL
      orphan_cmd_texts = db.get_first_value(<<-SQL)
        SELECT COUNT(*) FROM cmd_texts ct
        LEFT JOIN commands c ON ct.id = c.cmd_text_id
        WHERE c.id IS NULL
      SQL
      orphan_path_args = db.get_first_value(<<-SQL)
        SELECT COUNT(*) FROM path_args pa
        LEFT JOIN paths p ON pa.path_id = p.id
        LEFT JOIN commands c ON pa.command_id = c.id
        WHERE p.id IS NULL OR c.id IS NULL
      SQL
      orphan_sessions = db.get_first_value(<<-SQL)
        SELECT COUNT(*) FROM sessions s
        LEFT JOIN commands c ON s.id = c.session_id
        WHERE c.id IS NULL
      SQL
      puts "Orphaned paths:      #{orphan_paths}"
      puts "Orphaned cmd_texts:  #{orphan_cmd_texts}"
      puts "Orphaned path_args:  #{orphan_path_args}"
      puts "Orphaned sessions:   #{orphan_sessions}"
      # Integrity check
      integrity = db.get_first_value("PRAGMA integrity_check")
      puts "Integrity check:     #{integrity}"
      # Database size
      original_size = File.size(db_path)
      puts "Database size:      #{format_bytes(original_size)}"
      puts "\nThis will run: cleanup, optimize, vacuum, integrity check."
      print "Proceed with all maintenance steps? [y/N]: "
      answer = $stdin.gets.strip.downcase
      if answer == 'y' || answer == 'yes'
        actions = [:cleanup, :optimize, :vacuum, :integrity]
      else
        puts "Aborted. No changes made."
        db.close if db
        return
      end
    end

    actions.each do |action|
      case action
      when :cleanup
        puts "\n--- Running cleanup ---"
        cleanup_orphaned_entries(db, true)
      when :optimize
        puts "\n--- Running optimize ---"
        begin
          puts "Running ANALYZE..."
          db.execute "ANALYZE"
          puts "Rebuilding indexes..."
          db.execute "REINDEX"
          puts "Running VACUUM..."
          db.execute "VACUUM"
          puts "Optimize complete."
        rescue => e
          STDERR.puts "Error optimizing database: #{e.message}"
        end
      when :vacuum
        puts "\n--- Running VACUUM ---"
        begin
          db.execute "VACUUM"
          puts "VACUUM complete."
        rescue => e
          STDERR.puts "Error running VACUUM: #{e.message}"
        end
      when :integrity
        puts "\n--- Running integrity check ---"
        begin
          integrity = db.get_first_value("PRAGMA integrity_check")
          puts "Integrity check: #{integrity}"
        rescue => e
          STDERR.puts "Integrity check failed: #{e.message}"
        end
      end
    end

    # Print summary after execution
    db.close if db
    puts "\n=== Maintenance Summary ==="
    old_size = defined?(original_size) ? original_size : File.size(db_path)
    new_size = File.size(db_path)
    puts "Database size before: #{format_bytes(old_size)}"
    puts "Database size after:  #{format_bytes(new_size)}"
    savings = old_size - new_size
    percentage = savings > 0 ? (savings.to_f / old_size * 100).round(2) : 0
    if savings > 0
      puts "Space saved:         #{format_bytes(savings)} (#{percentage}%)"
    else
      puts "Space saved:         0 (already optimized)"
    end
    # Reopen DB for integrity check
    db2 = SQLite3::Database.new(db_path)
    db2.results_as_hash = true
    integrity = db2.get_first_value("PRAGMA integrity_check")
    puts "Integrity check:     #{integrity}"
    db2.close if db2
    puts "Maintenance complete."

    db.close if db
  end

  def handle_on_session
    session_data = {
      shell: ENV['SHELL'],
      tty: get_tty,
      cwd: Dir.pwd,
      pid: Process.pid,
      parent_pid: Process.ppid,
      timezone: get_timezone
    }

    # Store session in SQLite database and get the generated session_id
    session_id = Histlog::DB.store_session(session_data)

    if session_id
      puts session_id
    else
      STDERR.puts "Failed to create session"
      exit 1
    end
  end

  def handle_on_preexec
    cmd = @argv[0]
    session_id = @argv[1]&.to_i # Convert to integer
    dir = Dir.pwd

    # Store command in database
    command_data = {
      session_id: session_id,
      command: cmd,
      cwd: dir
    }

    history_id = store_command(command_data)

    if history_id
      puts history_id
    else
      STDERR.puts "Failed to store command"
      exit 1
    end
  end

  def handle_on_postcmd
    history_id = @argv[0]&.to_i # Convert to integer
    duration = @argv[1].to_f / 1000.0 # convert ms to s, keep float
    exit_code = @argv[2]&.to_i

    # Update command with completion data
    update_command_completion(history_id, duration.round(3), exit_code)
  end
end

# Main execution
if __FILE__ == $0
  app = HistlogApp.new(ARGV)
  app.run
end
