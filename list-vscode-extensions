#!/usr/bin/env ruby
# frozen_string_literal: true

# Usage: ruby list_vscode_extensions_with_details.rb
# Requires: VS Code CLI (`code`) and Ruby with 'net/http' and 'json' (standard)

require 'net/http'
require 'json'
require 'optparse'
require 'io/console'
require 'yaml'
require 'time'

options = { workers: 10 }
OptionParser.new do |opts|
  opts.on('--format=FMT', 'Output in specified format (json, markdown, recommend, yaml)') do |f|
    options[:format] = f
  end
  opts.on('-r', '--recommend', 'Output in recommendations format') { options[:format] = 'recommend' }
  opts.on('-j', '--json', 'Output in JSON format') { options[:format] = 'json' }
  opts.on('-m', '--markdown', 'Output in Markdown format') { options[:format] = 'markdown' }
  opts.on('-y', '--yaml', 'Output in YAML format') { options[:format] = 'yaml' }
  opts.on('--workers=N', Integer, 'Number of parallel workers (default: 10)') { |n| options[:workers] = n }
end.parse!


# Get list of installed extensions with versions
extensions_with_versions = `code --list-extensions --show-versions`.split("\n").map(&:strip).reject(&:empty?)
extensions = extensions_with_versions.map { |ext_with_version| ext_with_version.split('@').first }
extension_versions = Hash[extensions_with_versions.map { |ext_with_version|
  parts = ext_with_version.split('@')
  [parts.first, parts.last] if parts.size > 1
}.compact]

# Query VS Marketplace for extension details
def fetch_extension_details(extension_id)

  ext = {
		'id' => extension_id,
		'marketplace' => "https://marketplace.visualstudio.com/items?itemName=#{extension_id}"
	  }

  uri = URI('https://marketplace.visualstudio.com/_apis/public/gallery/extensionquery')
  req = Net::HTTP::Post.new(uri)
  req['Content-Type'] = 'application/json'
  req['Accept'] = 'application/json;api-version=3.0-preview.1'
  req.body = {
    filters: [
      { criteria: [ { filterType: 7, value: extension_id } ] }
    ],
    flags: 914
  }.to_json

  http = Net::HTTP.new(uri.hostname, uri.port)
  http.use_ssl = true
  http.open_timeout = 5  # 5 seconds timeout for opening connection
  http.read_timeout = 10 # 10 seconds timeout for reading data

  res = http.request(req)


  if res.code.to_i == 200
    json = JSON.parse(res.body)
    data = json.dig('results', 0, 'extensions', 0)

    data['shortDescription'] ||= 'No description available...'
    ext.merge(data) if data
  else
    if res.code.to_i == 429
      reset_time = res['X-RateLimit-Reset'] || 'unknown'
      reset_datetime = reset_time != 'unknown' ? Time.at(reset_time.to_i).strftime('%Y-%m-%d %H:%M:%S') : 'unknown'
      remaining = res['X-RateLimit-Remaining'] || 0
      limit = res['X-RateLimit-Limit'] || 'unknown'
      STDERR.puts "\nRate limit exceeded for #{extension_id}: Remaining: #{remaining}/#{limit}, Reset: #{reset_datetime}"
    else
      STDERR.puts "\nAPI error for #{extension_id}: #{res.code} - #{res.message}"
    end
    ext.merge({ 'shortDescription' => 'Error fetching details...' })
  end
rescue => e
  STDERR.puts "\nError fetching #{extension_id}: #{e.message}"
  ext.merge({ 'shortDescription' => 'Error fetching details...' })
end

completed = 0
mutex = Mutex.new

def print_progress(current, total)
  bar_width = 40
  percent = (current.to_f / total * 100).to_i
  filled = (bar_width * current / total.to_f).to_i
  bar = '=' * filled + ' ' * (bar_width - filled)
  STDERR.print "\r[#{bar}] #{current}/#{total} (#{percent}%)"
  STDERR.flush
end

# Helper to extract statistics
STAT_NAMES = {
  install: 'install',
  rating: 'weightedRating',
  rating_count: 'ratingcount'
}
def extract_stat(details, stat)
  details['statistics']&.find { |s| s['statisticName'] == STAT_NAMES[stat] }&.dig('value')
end

def format_last_updated(details)
  last_updated = details['publishedDate'] || details['lastUpdated']
  last_updated ? Time.parse(last_updated).strftime('%Y-%m-%d') : 'unknown'
end

# Parallel fetching with specified number of workers
queue = Queue.new
extensions.each_with_index { |ext, idx| queue << [idx, ext] }
results = Array.new(extensions.size)
mutex = Mutex.new
completed = 0
failed = 0

workers = options[:workers].times.map do
  Thread.new do
    while true
      begin
        item = mutex.synchronize { queue.pop(true) } # Will raise error when queue is empty
      rescue ThreadError
        break  # Queue is empty, exit the thread
      end

      idx, ext = item
      begin
        details = fetch_extension_details(ext)
        mutex.synchronize do
          results[idx] = details
          completed += 1
          if details['shortDescription'].empty? && details['id']
            failed += 1
          end
        end
      rescue => e
        mutex.synchronize do
          STDERR.puts "\nUnhandled error processing #{ext}: #{e.message}"
          results[idx] = { 'id' => ext, 'shortDescription' => "Error: #{e.message}", 'marketplace' => "https://marketplace.visualstudio.com/items?itemName=#{ext}" }
          completed += 1
          failed += 1
        end
      ensure
        print_progress(completed, extensions.size)
      end
    end
  end
end

workers.each(&:join)
STDERR.puts "\nCompleted #{completed}/#{extensions.size} extensions (#{failed} with errors)"

# Process only valid results, sort by id
valid_results = results.compact.sort_by { |d| d['id'] }
STDERR.puts "Retrieved #{valid_results.size} extension details"

if options[:format] == 'recommend'
  puts '{'
  puts '  "recommendations": ['
  valid_results.each_with_index do |details, idx|
    last_updated_date = format_last_updated(details)
    installs = extract_stat(details, :install).to_i
    rating = extract_stat(details, :rating)&.round(1)
    rating_count = extract_stat(details, :rating_count).to_i
    puts
    puts "    \"#{details['id']}\", // #{details['versions']&.first&.dig('version') || 'unknown'} [#{details['flags']}]"
    puts "    // #{details['shortDescription']}"
    puts "    // Last Updated: #{last_updated_date}, Installs: #{installs}, Rating: #{rating} (#{rating_count} ratings) on #{Time.now.strftime("%Y-%m-%d")}"
    puts "    // #{details['marketplace']}"
  end
  puts '  ]'
  puts '}'
elsif options[:format] == 'markdown'
  puts "# VS Code Extensions"
  puts
  valid_results.each do |details|
    last_updated_date = format_last_updated(details)
    installs = extract_stat(details, :install).to_i
    rating = extract_stat(details, :rating)&.round(1)
    rating_count = extract_stat(details, :rating_count).to_i
    puts "- [#{details['id']}](#{details['marketplace']}) #{details['versions']&.first&.dig('version') || 'unknown'} [#{details['flags']}]"
    puts "  > #{details['shortDescription']}"
    puts "  > Last Updated: #{last_updated_date}, Installs: #{installs}, Rating: #{rating} (#{rating_count} ratings)"
    puts
  end
elsif options[:format] == 'json'
  puts JSON.pretty_generate(valid_results)
elsif options[:format] == 'yaml'
  puts valid_results.to_yaml
else
  valid_results.each do |details|
    last_updated_date = format_last_updated(details)
    installs = extract_stat(details, :install).to_i
    rating = extract_stat(details, :rating)&.round(1)
    rating_count = extract_stat(details, :rating_count).to_i
    puts "#{details['id']} #{details['versions']&.first&.dig('version') || 'unknown'} [#{details['flags']}]"
    puts "  Description: #{details['shortDescription']}"
    puts "  Last Updated: #{last_updated_date} Installs: #{installs},  Rating: #{rating} (#{rating_count} ratings)"
    puts "  Marketplace: #{details['marketplace']}"
    puts
  end
end
