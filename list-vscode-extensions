#!/usr/bin/env ruby
# frozen_string_literal: true

# Usage: ruby list_vscode_extensions_with_details.rb
# Requires: VS Code CLI (`code`) and Ruby with 'net/http' and 'json' (standard)

require 'net/http'
require 'json'
require 'optparse'
require 'io/console'
require 'yaml'
require 'time'
require 'erb'

options = { workers: 10 }
OptionParser.new do |opts|
  opts.on('--format=FMT', 'Output in specified format (json, markdown, recommend, yaml)') do |f|
    options[:format] = f
  end
  opts.on('-r', '--recommend', 'Output in recommendations format') { options[:format] = 'recommend' }
  opts.on('-j', '--json', 'Output in JSON format') { options[:format] = 'json' }
  opts.on('-m', '--markdown', 'Output in Markdown format') { options[:format] = 'markdown' }
  opts.on('-y', '--yaml', 'Output in YAML format') { options[:format] = 'yaml' }
  opts.on('--workers=N', Integer, 'Number of parallel workers (default: 10)') { |n| options[:workers] = n }
  opts.on('-o', '--output=FILE', 'Write output to FILE instead of stdout') { |file| options[:output] = file }
  opts.on('-i', '--input=FILE', 'Read extension list from FILE') { |file| options[:input] = file }
  opts.on('--id-with-version', 'Include version in extension id in output') { options[:id_with_version] = true }
end.parse!

# Helper to read extension list from stdin, file, or VS Code CLI
def read_extensions(options)
  input_lines = []
  if !STDIN.tty? && !STDIN.closed? && !STDIN.eof?
    input_lines = STDIN.read.split("\n")
  elsif options[:input]
    input_lines = File.read(options[:input]).split("\n")
  end
  input_lines = input_lines.map(&:strip).reject(&:empty?)
  if input_lines.empty?
    # fallback to installed extensions
    input_lines = `code --list-extensions --show-versions`.split("\n").map(&:strip).reject(&:empty?)
  end
  # Remove duplicates
  input_lines.uniq
end

# Parse extension list into [id, version] pairs
def parse_extensions(ext_lines)
  ext_lines.map do |line|
    if line.include?('@')
      id, version = line.split('@', 2)
      [id, version]
    else
      [line, nil]
    end
  end
end

ext_lines = read_extensions(options)
ext_pairs = parse_extensions(ext_lines)
ext_ids = ext_pairs.map(&:first)
ext_versions = Hash[ext_pairs.select { |id, v| v }.map { |id, v| [id, v] }]

# Query VS Marketplace for extension details
def fetch_extension_details(extension_id)

  ext = {
		'id' => extension_id,
		'marketplace' => "https://marketplace.visualstudio.com/items?itemName=#{extension_id}"
	  }

  uri = URI('https://marketplace.visualstudio.com/_apis/public/gallery/extensionquery')
  req = Net::HTTP::Post.new(uri)
  req['Content-Type'] = 'application/json'
  req['Accept'] = 'application/json;api-version=3.0-preview.1'
  req.body = {
    filters: [
      { criteria: [ { filterType: 7, value: extension_id } ] }
    ],
    flags: 914
  }.to_json

  http = Net::HTTP.new(uri.hostname, uri.port)
  http.use_ssl = true
  http.open_timeout = 5  # 5 seconds timeout for opening connection
  http.read_timeout = 10 # 10 seconds timeout for reading data

  res = http.request(req)


  if res.code.to_i == 200
    json = JSON.parse(res.body)
    data = json.dig('results', 0, 'extensions', 0)

    data['shortDescription'] ||= 'No description available...'
    ext.merge(data) if data
  else
    if res.code.to_i == 429
      reset_time = res['X-RateLimit-Reset'] || 'unknown'
      reset_datetime = reset_time != 'unknown' ? Time.at(reset_time.to_i).strftime('%Y-%m-%d %H:%M:%S') : 'unknown'
      remaining = res['X-RateLimit-Remaining'] || 0
      limit = res['X-RateLimit-Limit'] || 'unknown'
      STDERR.puts "\nRate limit exceeded for #{extension_id}: Remaining: #{remaining}/#{limit}, Reset: #{reset_datetime}"
    else
      STDERR.puts "\nAPI error for #{extension_id}: #{res.code} - #{res.message}"
    end
    ext.merge({ 'shortDescription' => 'Error fetching details...' })
  end
rescue => e
  STDERR.puts "\nError fetching #{extension_id}: #{e.message}"
  ext.merge({ 'shortDescription' => 'Error fetching details...' })
end

completed = 0
mutex = Mutex.new

def print_progress(current, total)
  bar_width = 40
  percent = (current.to_f / total * 100).to_i
  filled = (bar_width * current / total.to_f).to_i
  bar = '=' * filled + ' ' * (bar_width - filled)
  STDERR.print "\r[#{bar}] #{current}/#{total} (#{percent}%)"
  STDERR.flush
end

# Helper to extract statistics
STAT_NAMES = {
  install: 'install',
  rating: 'weightedRating',
  rating_count: 'ratingcount'
}
def extract_stat(details, stat)
  details['statistics']&.find { |s| s['statisticName'] == STAT_NAMES[stat] }&.dig('value')
end

def format_last_updated(details)
  last_updated = details['publishedDate'] || details['lastUpdated']
  last_updated ? Time.parse(last_updated).strftime('%Y-%m-%d') : 'unknown'
end

def id_with_version(details, ext_versions, options)
  if options[:id_with_version]
    version = ext_versions[details['id']] || details['versions']&.first&.dig('version') || 'unknown'
    "#{details['id']}@#{version}"
  else
    details['id']
  end
end

# Add helper to format flags
def format_flags(details)
  details['flags'] ? details['flags'].split(',').map(&:strip).map { |f| "*#{f}*" }.join(' ') : ''
end

# Add helper to format flags in brackets for default output
def bracket_flags(details)
  flags = details['flags'] ? details['flags'].split(',').map(&:strip).join(', ') : ''
  flags.empty? ? '' : "[#{flags}]"
end

# Parallel fetching with specified number of workers
queue = Queue.new
ext_ids.each_with_index { |ext, idx| queue << [idx, ext] }
results = Array.new(ext_ids.size)
mutex = Mutex.new
completed = 0
failed = 0

workers = options[:workers].times.map do
  Thread.new do
    while true
      begin
        item = mutex.synchronize { queue.pop(true) } # Will raise error when queue is empty
      rescue ThreadError
        break  # Queue is empty, exit the thread
      end

      idx, ext = item
      begin
        details = fetch_extension_details(ext)
        mutex.synchronize do
          results[idx] = details
          completed += 1
          if details['shortDescription'].empty? && details['id']
            failed += 1
          end
        end
      rescue => e
        mutex.synchronize do
          STDERR.puts "\nUnhandled error processing #{ext}: #{e.message}"
          results[idx] = { 'id' => ext, 'shortDescription' => "Error: #{e.message}", 'marketplace' => "https://marketplace.visualstudio.com/items?itemName=#{ext}" }
          completed += 1
          failed += 1
        end
      ensure
        print_progress(completed, ext_ids.size)
      end
    end
  end
end

workers.each(&:join)
STDERR.puts "\nCompleted #{completed}/#{ext_ids.size} extensions (#{failed} with errors)"

# Process only valid results, sort by id
valid_results = results.compact.sort_by { |d| d['id'] }
STDERR.puts "Retrieved #{valid_results.size} extension details"

# Output to file or stdout
output_io = options[:output] ? File.open(options[:output], 'w') : $stdout

def output_puts(io, str)
  io.puts str
end

def output_close(io, options)
  io.close if options[:output]
end

def render_erb_template(template_str, locals)
  valid_results = locals[:valid_results]
  ext_versions  = locals[:ext_versions]
  options       = locals[:options]
  ERB.new(template_str, trim_mode: '-').result(binding)
end

recommend_template = %q{
<% valid_results.each do |details| %>
    "<%= id_with_version(details, ext_versions, options) %>",  // <%= format_flags(details) %>
    // <%= details['shortDescription'] %>
    // Latest <%= details['versions']&.first&.dig('version') || 'unknown' %> - <%= format_last_updated(details) %>, Installs: <%= extract_stat(details, :install).to_i %>, Rating: <%= extract_stat(details, :rating)&.round(1) %> (<%= extract_stat(details, :rating_count).to_i %> ratings) on <%= Time.now.strftime('%Y-%m-%d') %>
    // <%= details['marketplace'] %>
<% end %>
}

markdown_template = %q{
# VS Code Extensions
<% valid_results.each do |details| %>
- [<%= id_with_version(details, ext_versions, options) %>](<%= details['marketplace'] %>)<%= format_flags(details).empty? ? '' : " #{format_flags(details)}" %>
  > <%= details['shortDescription'] %>
  > Latest <%= details['versions']&.first&.dig('version') || 'unknown' %> - <%= format_last_updated(details) %>, Installs: <%= extract_stat(details, :install).to_i %>, Rating: <%= extract_stat(details, :rating)&.round(1) %> (<%= extract_stat(details, :rating_count).to_i %> ratings)
<% end %>
}

json_template = %q{
<%= JSON.pretty_generate(valid_results.map { |details| d = details.dup; d['id'] = id_with_version(details, ext_versions, options); d }) %>
}

yaml_template = %q{
<%= valid_results.map { |details| d = details.dup; d['id'] = id_with_version(details, ext_versions, options); d }.to_yaml %>
}

default_template = %q{
<% valid_results.each do |details| %>
<%= details['id'] %><%= options[:id_with_version] ? "@#{ext_versions[details['id']] || '0.1.0'}" : "" %><%= format_flags(details).empty? ? '' : " #{format_flags(details)}" %>
  Description: <%= details['shortDescription'] %>
  Latest <%= details['versions']&.first&.dig('version') || 'unknown' %> - <%= format_last_updated(details) %> Installs: <%= extract_stat(details, :install).to_i %>,  Rating: <%= extract_stat(details, :rating)&.round(1) %> (<%= extract_stat(details, :rating_count).to_i %> ratings)
  Marketplace: <%= details['marketplace'] %>
<% end %>
}
case options[:format]
when 'recommend'
  output_puts(output_io, render_erb_template(recommend_template,
    {valid_results: valid_results, ext_versions: ext_versions, options: options}))
when 'markdown'
  output_puts(output_io, render_erb_template(markdown_template,
    {valid_results: valid_results, ext_versions: ext_versions, options: options}))
when 'json'
  output_puts(output_io, render_erb_template(json_template,
    {valid_results: valid_results, ext_versions: ext_versions, options: options}))
when 'yaml'
  output_puts(output_io, render_erb_template(yaml_template,
    {valid_results: valid_results, ext_versions: ext_versions, options: options}))
else
  output_puts(output_io, render_erb_template(default_template,
    {valid_results: valid_results, ext_versions: ext_versions, options: options}))
end
output_close(output_io, options)
